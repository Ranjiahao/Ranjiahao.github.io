<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ranjiahao.github.io/"/>
  <updated>2020-04-02T16:00:00.000Z</updated>
  <id>https://ranjiahao.github.io/</id>
  
  <author>
    <name>Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>交换排序</title>
    <link href="https://ranjiahao.github.io/2020/04/03/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/03/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h1><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾<br>时间复杂度：<br>最好：正序 比较次数n 移动次数0<br>最坏：反序 比较次数n<sup>2</sup> 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)<br>空间复杂度：O(1)<br>稳定性：稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> isSorted = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">        <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j + <span class="number">1</span>]);</span><br><span class="line">                isSorted = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2><p>我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sortBorder = size; sortBorder &gt; <span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 无序 [0, sortBorder - 1]</span></span><br><span class="line">        <span class="comment">// 有序 [sortBorder, size - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j + <span class="number">1</span>]);</span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortBorder = lastExchangeIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br>每一层的Partition：<br>时间复杂度 O(n)<br>空间复杂度 O(1)<br>快速排序时间复杂度：<br>最好：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>  </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=2T(n/2)+O(n)=&gt;T(n)=O(n\;log\,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>最坏：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T(n-1)+O(n)=&gt;T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mfrac><mn>2</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>T</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>  </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\frac1{n}\sum_{k=1}^n(T(n-k)+T(k-1))+n=\frac2{n}\sum_{k=1}^nT(k)+n=&gt;T(n)=O(n\;log\,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>快速排序空间复杂度：<br>空间消耗在于递归调用的栈帧消耗，最终消耗的情况是二叉树的高度，二叉树的高度在log(n) ~ n变化<br>最好：O(log n)<br>最坏：O(n)<br>平均：O(log n)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hover</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left;    <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right - <span class="number">1</span>; <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[right]; <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt;= pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt;= pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值和begin所在的下标交换，和第一个比pivot大的数交换</span></span><br><span class="line">    swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖坑</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left; <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right;  <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[right]; <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt;= pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[end] = <span class="built_in">array</span>[begin];</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt;= pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[begin] = <span class="built_in">array</span>[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[begin] = pivot;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_3</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[d]);</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>[d], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortInner</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="comment">// size &lt;= 1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 确定基准值</span></span><br><span class="line">    <span class="comment">// 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标</span></span><br><span class="line">    <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">    <span class="comment">// [left, right]  的区间被分成三部分</span></span><br><span class="line">    <span class="comment">// [left, d - 1]  &lt;= pivot</span></span><br><span class="line">    <span class="comment">// [d]            == pivot</span></span><br><span class="line">    <span class="comment">// [d + 1, right] &gt;= pivot</span></span><br><span class="line">    <span class="comment">// 3. 分治处理所有两个小区间</span></span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, left, d - <span class="number">1</span>);</span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, d + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortNoR</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存要排序区间的左右边界</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(size - <span class="number">1</span>); <span class="comment">// right</span></span><br><span class="line">    <span class="built_in">stack</span>.push(<span class="number">0</span>);        <span class="comment">// left</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">        <span class="comment">// [d + 1, right]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(right);</span><br><span class="line">        <span class="built_in">stack</span>.push(d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// [left, d - 1]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(d - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">stack</span>.push(left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-2"><a class="markdownIt-Anchor" href="#优化-2"></a> 优化</h2><ol><li>上面的版本我们选择array[right]作为基准值，这其实是一种很不聪明的取法，当初始序列一开始就是有序的，则快速排序时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T(n-1)+O(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>所以pivot最好用三数取中法来选取</li><li>Partition函数中，如果有元素正好等于pivot，最好停下来做交换，虽然这样做了很多无谓的交换，但是最后i和j会停在比较中间的位置，主元也会被换在在比较中间的位置，这样做每一次递归的时候，原始序列基本被等分成两个等长的序列这样时间复杂度为O(n * log n)；如果不停下来交换而继续移动指针，这样其中一个指针是不动的，导致主元被放在一个端点，这样就成了O(n<sup>2</sup>)复杂度的算法了</li><li>对于大规模数据我们用递归，而对于递归的数据规模充分的小的时候则停止递归，直接调用简单排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUTOFF 7 <span class="comment">// 数组长度阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Median3</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[center]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[center]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[center] &gt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[center], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时A[left] &lt;= A[center] &lt;= A[right]</span></span><br><span class="line">    swap(<span class="built_in">array</span>[center], <span class="built_in">array</span>[right - <span class="number">1</span>]); <span class="comment">// 将基准pivot藏到右边</span></span><br><span class="line">    <span class="comment">// 只需要考虑A[left + 1] … A[right - 2]</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">array</span>[right - <span class="number">1</span>];  <span class="comment">// 返回基准Pivot</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = Median3(<span class="built_in">array</span>, left, right); <span class="comment">// 基准值</span></span><br><span class="line">    <span class="comment">// 只需要考虑A[left + 1] … A[right - 2]</span></span><br><span class="line">    <span class="keyword">int</span> begin = left + <span class="number">1</span>; <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right - <span class="number">2</span>;  <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">     <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt; pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt; pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值和begin所在的下标交换，和第一个比pivot大的数交换</span></span><br><span class="line">    swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortInner</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((right - left) &gt; CUTOFF) &#123;</span><br><span class="line">        <span class="comment">// 调用快速排序</span></span><br><span class="line">        <span class="comment">// 1. 确定基准值</span></span><br><span class="line">        <span class="comment">// 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标</span></span><br><span class="line">        <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">        <span class="comment">// [left, right]  的区间被分成三部分</span></span><br><span class="line">        <span class="comment">// [left, d - 1]  &lt;= pivot</span></span><br><span class="line">        <span class="comment">// [d]            == pivot</span></span><br><span class="line">        <span class="comment">// [d + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="comment">// 3. 分治处理所有两个小区间</span></span><br><span class="line">        QuickSortInner(<span class="built_in">array</span>, left, d - <span class="number">1</span>);</span><br><span class="line">        QuickSortInner(<span class="built_in">array</span>, d + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InsertSort(<span class="built_in">array</span> + left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h1&gt;&lt;p&gt;从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="冒泡排序" scheme="https://Ranjiahao.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://Ranjiahao.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="https://ranjiahao.github.io/2020/04/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接选择排序"><a class="markdownIt-Anchor" href="#直接选择排序"></a> 直接选择排序</h1><p>每一次从待排序的数据元素中选出最小（和最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完<br>时间复杂度：O(n<sup>2</sup>) 数据不敏感<br>比较次数n<sup>2</sup><br>移动次数正序为0，反序为n<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">        <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 要查找整个无序区间的最大值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt;= <span class="built_in">array</span>[maxIdx]) &#123;</span><br><span class="line">                maxIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// maxIdx 记录着无序区间部分最大的数的下标</span></span><br><span class="line">        <span class="comment">// 和无序区间的最后一个位置的数进行交换</span></span><br><span class="line">        swap(<span class="built_in">array</span>[maxIdx], <span class="built_in">array</span>[size - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSortOP</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 有序 [0, begin - 1]  最小的数</span></span><br><span class="line">    <span class="comment">// 有序 [end + 1, size - 1] 最大的数</span></span><br><span class="line">    <span class="comment">// 无序 [begin, end]</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = begin;</span><br><span class="line">        <span class="keyword">int</span> max = begin;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[min]) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小的数放到无序区间的最开始</span></span><br><span class="line">        <span class="comment">// 最大的数放到无序区间的最末尾</span></span><br><span class="line">        swap(<span class="built_in">array</span>[min], <span class="built_in">array</span>[begin]);</span><br><span class="line">        <span class="keyword">if</span> (max == begin) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[max], <span class="built_in">array</span>[end]);</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1><p>从最大（小）堆顶不断取走堆顶元素放到有序序列中，直到堆的元素被全部取完<br>时间复杂度：O(n * log n) 数据不敏感<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; <span class="built_in">array</span>[right] &gt; <span class="built_in">array</span>[left]) &#123;</span><br><span class="line">        max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[index] &gt;= <span class="built_in">array</span>[max]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>[max], <span class="built_in">array</span>[index]);</span><br><span class="line">    Heapify(<span class="built_in">array</span>, size, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点，一直到 0，不断的向下调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Heapify(<span class="built_in">array</span>, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建大堆</span></span><br><span class="line">    CreateHeap(<span class="built_in">array</span>, size); <span class="comment">// n</span></span><br><span class="line">    <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">    <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// n * log n</span></span><br><span class="line">        <span class="comment">// 交换最大的数和无序区间的最后一个数</span></span><br><span class="line">        swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[size - <span class="number">1</span> - i]);</span><br><span class="line">        <span class="comment">// 堆的性质被破坏了，要调整的是剩余无序部分的长度 size - 1 - i</span></span><br><span class="line">        Heapify(<span class="built_in">array</span>, size - <span class="number">1</span> - i, <span class="number">0</span>); <span class="comment">// log n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建堆时间复杂度：<br>对满二叉树而言，第i层(根为第0层)有2<sup>i</sup>个节点<br>由于建堆过程自底向上，以交换作为主要操作，因此第i层任意节点在最不利情况下，需要经过(n−i)次交换操作才能完成以该节点为堆根节点的建堆过程<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n)=2^0(n−0)+2^1(n−1)+...+2^n(n−n)=\sum_{i=0}^n{(2^i(n-i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.124374em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">2T(n)=2^1(n-0)+2^2(n-1)+2^{n+1}(n-n)=\sum_{i=1}^{n+1}{(2^i(n-i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.954008em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>2</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2T(n)-T(n)=2^{n+1}-2-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span><br>总节点数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">1+2+4+...+2^n=2^{n+1}−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span><br>忽略减1取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">＝</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N＝2^{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">＝</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">−</mi><mn>2</mn><mi mathvariant="normal">−</mi><mi>n</mi><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>N</mi></mrow><mi>N</mi></mfrac><mi mathvariant="normal">−</mi><mfrac><mn>2</mn><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo>≈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N)=2^{n+1}−2−n=N(1−\frac{log\,N}{N}−\frac2N)≈N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">2</span><span class="mord">−</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-.345em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9322159999999999em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.01968em">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:.03588em">g</span><span class="mspace mtight" style="margin-right:.19516666666666668em"></span><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span><br>堆排序时间复杂度：<br>调整堆顶n-1次，总共比较次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mn>2</mn><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(log(n-1)+log(n-2)+...+log2)&lt;2n(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>因此，堆排序时间复杂度为O(n * log n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接选择排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#直接选择排序&quot;&gt;&lt;/a&gt; 直接选择排序&lt;/h1&gt;&lt;p&gt;每一次从待排序的数据元素中选出最小（和最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完&lt;br&gt;时间复杂
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="直接选择排序" scheme="https://Ranjiahao.github.io/tags/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://Ranjiahao.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="https://ranjiahao.github.io/2020/04/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h1><p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列<br>时间复杂度：<br>最好：正序 比较次数n 移动次数0<br>最坏：反序 比较次数n<sup>2</sup> 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)<br>空间复杂度：O(1)<br>稳定性：稳定</p><p>利用二分查找实现插入排序<br>最好：正序 比较次数n * log n 移动次数0<br>最坏：反序 比较次数n * log n 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)</p><p>数据越少、越接近有序排序性能越好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; key; j--) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二分查找实现插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSortBS</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 有序 [0, i - 1]</span></span><br><span class="line">        <span class="comment">// 无序 [i, size - 1]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[mid] == <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 是要插入的位置的下标</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; left; k--) &#123;</span><br><span class="line">            <span class="built_in">array</span>[k] = <span class="built_in">array</span>[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[left] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h1><p>由于插入排序数据越少、越接近有序排序性能越好，希尔排序就是利用插入排序的这两个特点实现的，希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br>时间复杂度：<br>最好：O(n)<br>最坏：O(n<sup>2</sup>)<br>平均：O(1.3)<br>希尔排序的时间复杂度与增量的选取有关，Hibbard增量序列O(n<sup>5/4</sup>)，Sedgewick增量序列O(n<sup>7/6</sup>)<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSortWithGap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; key; j -= gap) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j + gap] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + gap] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = size;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 原始增量序列</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// gap = gap / 3 + 1;</span></span><br><span class="line">        InsertSortWithGap(<span class="built_in">array</span>, size, gap);</span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接插入排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#直接插入排序&quot;&gt;&lt;/a&gt; 直接插入排序&lt;/h1&gt;&lt;p&gt;把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列&lt;br
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="直接插入排序" scheme="https://Ranjiahao.github.io/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://Ranjiahao.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>deque原理以及stack、queue、priority_queue模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/03/31/deque%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Astack%E3%80%81queue%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/03/31/deque%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Astack%E3%80%81queue%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-30T16:00:00.000Z</published>
    <updated>2020-03-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>容器适配器是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素<br>stack底层可以用vector、deque、list默认使用deque<br>queue若使用vector来封装效率太低，所以底层可以用deque、list默认使用deque<br>priority_queue底层可以用vector和deque默认使用vector</p><p>deque:<br>与vector比较，头插效率高，不需要搬移元素，扩容时，也不需要搬移大量的元素<br>与list比较，空间利用率比较高，并且支持随机访问<br>deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下</p><p>stack和queue不需要遍历，只需要在固定的一端或者两端进行操作，stack中元素增长时，deque比vector的效率高（扩容时不需要搬移大量数据），queue中的元素增长时，deque不仅效率高，而且内存使用率高</p><p>deque采用指针数组map作为主控。每个元素指向另一段连续线性空间，称为缓冲区。缓冲区是deque的储存空间主体，如果map数组就再申请一块更大的连续空间供map数组使用，将原有数据（很多指针）拷贝到新的map数组中，然后释放旧的空间</p><p>deque的迭代器定义了四个指针，first和last指向缓冲区的首尾，cur指向当前遍历节点，node指向中控器中当前缓冲区是一个二级指针<br>图中begin()和end()分别返回start迭代器和finish迭代器<br>迭代器++时，cur往后走一位，当cur==last时，通过node访问下一个缓冲区的first并对cur重新赋值<br>迭代器–时，先判断cur是否为first，若为first则通过node访问上一个缓冲区的last，否则返回–cur<br>随机访问底层调用operator+，operator+再调用operator+=因此效率不高</p><p><img src="img1.png" alt="img1"></p><p>模拟实现stack，queue，priority_queue:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Con</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _c.empty(); &#125;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _c.size(); &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; _c.push_back(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; _c.pop_back(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Con _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Con</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _c.empty(); &#125;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _c.size(); &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.front(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _c.front(); &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _c.back(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; _c.push_back(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; _c.pop_front(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Con _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Con</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Priority_Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Priority_Queue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Priority_Queue</span>(<span class="title">Iterator</span> <span class="title">first</span>, <span class="title">Iterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">        :</span> c(first, last) &#123;</span><br><span class="line">        <span class="comment">// 将c中的元素调整成堆的结构</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (c.size() - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            AdjustDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        c.push_back(data);</span><br><span class="line">        AdjustUP(c.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!empty()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(c.front(), c.back());</span><br><span class="line">            c.pop_back();</span><br><span class="line">            AdjustDown(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AdjustUP</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = ((i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (i &amp;&amp; Compare()(c[parent], c[i])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(c[i], c[parent]);</span><br><span class="line">            i = parent;</span><br><span class="line">            parent = ((i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; c.size()) &#123;</span><br><span class="line">            <span class="comment">// 找以parent为根的较大（默认less比较规则）的孩子</span></span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; c.size() &amp;&amp; Compare()(c[child], c[child + <span class="number">1</span>])) &#123;</span><br><span class="line">                child += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检测双亲是否满足情况</span></span><br><span class="line">            <span class="keyword">if</span> (Compare()(c[parent], c[child])) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(c[child], c[parent]);</span><br><span class="line">                parent = child;</span><br><span class="line">                child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Con c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器适配器是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素&lt;br&gt;stack底层可以用vector、deque、list默认使用deque&lt;br&gt;queue若使用vector来封装效率太低，所以底层可以用deque、list默认使用deque&lt;br&gt;pr
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="deque" scheme="https://Ranjiahao.github.io/tags/deque/"/>
    
      <category term="stack" scheme="https://Ranjiahao.github.io/tags/stack/"/>
    
      <category term="queue" scheme="https://Ranjiahao.github.io/tags/queue/"/>
    
      <category term="priority_queue" scheme="https://Ranjiahao.github.io/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>list模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/03/30/list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/03/30/list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ListNode(<span class="keyword">const</span> T&amp; val = T())</span><br><span class="line">        : _prev(<span class="literal">nullptr</span>)</span><br><span class="line">        , _next(<span class="literal">nullptr</span>)</span><br><span class="line">        , _data(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ListNode&lt;T&gt;* _prev;</span><br><span class="line">    ListNode&lt;T&gt;* _next;</span><br><span class="line">    T _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个模板参数可以兼容普通迭代器和const迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ptr, <span class="keyword">typename</span> Ref&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ListIterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> _ListIterator&lt;T, Ptr, Ref&gt; Self;</span><br><span class="line"></span><br><span class="line">    _ListIterator(Node* node = <span class="literal">nullptr</span>)</span><br><span class="line">        : _node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Ref <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ptr <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(_node-&gt;_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++iterator</span></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterator++</span></span><br><span class="line">    Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        _node = _node-&gt;_next;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --iterator</span></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterator--</span></span><br><span class="line">    Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="function">Self <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        _node = _node-&gt;_prev;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node == it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ListNode&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> _ListIterator&lt;T, T*, T&amp;&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> _ListIterator&lt;T, <span class="keyword">const</span> T*, <span class="keyword">const</span> T&amp;&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">    List()</span><br><span class="line">        : _head(<span class="keyword">new</span> Node) &#123;</span><br><span class="line">        _head-&gt;_next = _head;</span><br><span class="line">        _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List(<span class="keyword">size_t</span> n, <span class="keyword">const</span> T&amp; val = T())</span><br><span class="line">        : List() &#123;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            push_back(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List(<span class="keyword">const</span> List&lt;T&gt;&amp; lst)</span><br><span class="line">        : List() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">            push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List(List&lt;T&gt;&amp;&amp; lst)</span><br><span class="line">        : List() &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(_head, lst._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&amp; lst)</span><br><span class="line">        : List() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">            push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt;&amp; <span class="keyword">operator</span>=(List&lt;T&gt; lst) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(_head, lst._head);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~List() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_head) &#123;</span><br><span class="line">            clear();</span><br><span class="line">            <span class="keyword">delete</span> _head;</span><br><span class="line">            _head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_head-&gt;_next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> const_iterator(_head-&gt;_next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> const_iterator(_head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;</span><br><span class="line">        Node* cur = _head-&gt;_next;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != _head) &#123;</span><br><span class="line">            ++size;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        insert(begin(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        erase(begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        insert(end(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        erase(--end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line"></span><br><span class="line">        newNode-&gt;_next = cur;</span><br><span class="line">        newNode-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        cur-&gt;_prev = newNode;</span><br><span class="line">        prev-&gt;_next = newNode;</span><br><span class="line">        <span class="keyword">return</span> --pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除：迭代器会失效，返回下一个元素的位置</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">        assert(pos != end());</span><br><span class="line">        Node* cur = pos._node;</span><br><span class="line">        Node* prev = cur-&gt;_prev;</span><br><span class="line">        Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line">        prev-&gt;_next = next;</span><br><span class="line">        next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">        pos = iterator(next);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&amp; lst)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(_head, lst._head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_head) &#123;</span><br><span class="line">            Node* cur = _head-&gt;_next;</span><br><span class="line">            <span class="keyword">while</span> (cur != _head) &#123;</span><br><span class="line">                Node* next = cur-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            _head-&gt;_next = _head;</span><br><span class="line">            _head-&gt;_prev = _head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="list" scheme="https://Ranjiahao.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>vector模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/03/18/vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/03/18/vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-17T16:00:00.000Z</published>
    <updated>2020-03-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line"></span><br><span class="line">    Vector();</span><br><span class="line">    Vector(<span class="keyword">size_t</span> n, <span class="keyword">const</span> T&amp; value = T());</span><br><span class="line">    Vector(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v);</span><br><span class="line">    Vector(Vector&lt;T&gt;&amp;&amp; v);</span><br><span class="line">    Vector(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&amp; lst);</span><br><span class="line">    ~Vector();</span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(Vector&lt;T&gt; v);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">const</span> T&amp; val = T())</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos);</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Vector&lt;T&gt;&amp; v)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _start = <span class="literal">nullptr</span>;</span><br><span class="line">    T* _finish = <span class="literal">nullptr</span>;</span><br><span class="line">    T* _endOfStorage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::Vector()</span><br><span class="line">    : _start(<span class="literal">nullptr</span>)</span><br><span class="line">    , _finish(<span class="literal">nullptr</span>)</span><br><span class="line">    , _endOfStorage(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::Vector(<span class="keyword">size_t</span> n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">    : Vector() &#123;</span><br><span class="line">    reserve(n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::Vector(<span class="keyword">const</span> Vector&lt;T&gt;&amp; v)</span><br><span class="line">    : _start(<span class="keyword">new</span> T[v.capacity()])</span><br><span class="line">    , _finish(_start + v.size())</span><br><span class="line">    , _endOfStorage(_start + v.capacity()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">        _start[i] = v[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; v)</span><br><span class="line">    : Vector() &#123;</span><br><span class="line">    swap(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::Vector(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&amp; lst)</span><br><span class="line">    : _start(<span class="keyword">new</span> T[lst.size()])</span><br><span class="line">    , _finish(_start)</span><br><span class="line">    , _endOfStorage(_start + lst.size()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">        *_finish = e;</span><br><span class="line">        ++_finish;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::~Vector() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_start) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _start;</span><br><span class="line">        _start = _finish = _endOfStorage = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>=(Vector&lt;T&gt; v) &#123;</span><br><span class="line">    swap(v);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::begin() &#123;</span><br><span class="line">    <span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::const_iterator Vector&lt;T&gt;::begin() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::end() &#123;</span><br><span class="line">    <span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::const_iterator Vector&lt;T&gt;::end() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Vector&lt;T&gt;::size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _finish - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::resize(<span class="keyword">size_t</span> n, <span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= size()) &#123;</span><br><span class="line">        _finish = _start + n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; capacity()) &#123;</span><br><span class="line">            reserve(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (_finish &lt; _start + n) &#123;</span><br><span class="line">            *_finish++ = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Vector&lt;T&gt;::capacity() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _endOfStorage - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Vector&lt;T&gt;::empty() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::reserve(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">this</span>-&gt;size();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; capacity()) &#123;</span><br><span class="line">        T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line">        <span class="keyword">if</span> (_start) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size(); i++) &#123;</span><br><span class="line">                tmp[i] = _start[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _start = tmp;</span><br><span class="line">        _finish = _start + size;</span><br><span class="line">        _endOfStorage = _start + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) &#123;</span><br><span class="line">    assert(pos &lt; size());</span><br><span class="line">    <span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(pos &lt; size());</span><br><span class="line">    <span class="keyword">return</span> _start[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">    insert(end(), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::pop_back() &#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    erase(end() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::insert(iterator pos, <span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">    assert(pos &gt;= begin() &amp;&amp; pos &lt;= end());</span><br><span class="line">    <span class="keyword">size_t</span> len = pos - _start;</span><br><span class="line">    <span class="keyword">if</span> (_finish == _endOfStorage) &#123;</span><br><span class="line">        <span class="comment">// 实际会根据一定算法开辟空间</span></span><br><span class="line">        <span class="keyword">size_t</span> newC = capacity() == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">2</span> * capacity();</span><br><span class="line">        reserve(newC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新迭代器，增容导致迭代器失效</span></span><br><span class="line">    pos = _start + len;</span><br><span class="line">    iterator end = _finish;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; pos) &#123;</span><br><span class="line">        *end = *(end - <span class="number">1</span>);</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = val;</span><br><span class="line">    ++_finish;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Vector&lt;T&gt;::iterator Vector&lt;T&gt;::erase(iterator pos) &#123;</span><br><span class="line">    assert(pos &lt; _finish &amp;&amp; pos &gt;= _start);</span><br><span class="line">    iterator begin = pos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; _finish) &#123;</span><br><span class="line">        *(begin - <span class="number">1</span>) = *begin;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    --_finish;</span><br><span class="line">    <span class="comment">// 删除导致迭代器失效，返回下一个元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::swap(Vector&lt;T&gt;&amp; v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(_start, v._start);</span><br><span class="line">    <span class="built_in">std</span>::swap(_finish, v._finish);</span><br><span class="line">    <span class="built_in">std</span>::swap(_endOfStorage, v._endOfStorage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::clear() &#123;</span><br><span class="line">    _finish = _start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="vector" scheme="https://Ranjiahao.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>string模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/03/16/string%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/03/16/string%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; _cin, String&amp; s);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; _cout, <span class="keyword">const</span> String&amp; s);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>* Iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span>* const_Iterator;</span><br><span class="line"> </span><br><span class="line">    String(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">""</span>);</span><br><span class="line">    String(String&amp;&amp; s);</span><br><span class="line">    ~String();</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String s);</span><br><span class="line"> </span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">const_Iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">const_Iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">char</span> c = <span class="string">'\0'</span>)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="keyword">char</span> c);</span><br><span class="line">    <span class="function">String&amp; <span class="title">insert</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line">    <span class="function">String&amp; <span class="title">insert</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>;</span><br><span class="line">    <span class="function">String&amp; <span class="title">erase</span><span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(String&amp; s)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> find(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> pos = <span class="number">0</span>) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> find_first_of(<span class="keyword">char</span> c, <span class="keyword">size_t</span> pos = <span class="number">0</span>) <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> npos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="keyword">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// string.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; _cin, String&amp; s) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = _cin.get(); !<span class="built_in">isspace</span>(c); _cin.get(c)) &#123;</span><br><span class="line">        s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; _cout, <span class="keyword">const</span> String&amp; s) &#123;</span><br><span class="line">    _cout &lt;&lt; s._str;</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">    : _size(<span class="number">0</span>)</span><br><span class="line">    , _capacity(<span class="number">0</span>)</span><br><span class="line">    , _str(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="function">String <span class="title">tmp</span><span class="params">(s._str)</span></span>;</span><br><span class="line">    swap(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : _size(<span class="built_in">strlen</span>(str))</span><br><span class="line">    , _capacity(_size)</span><br><span class="line">    , _str(<span class="keyword">new</span> <span class="keyword">char</span>[_capacity + <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(String&amp;&amp; s)</span><br><span class="line">    : String() &#123;</span><br><span class="line">    swap(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~String() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_str) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        _str = <span class="literal">nullptr</span>;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _capacity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(String s) &#123;</span><br><span class="line">    swap(s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::Iterator String::begin() &#123;</span><br><span class="line">    <span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::const_Iterator String::begin() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::Iterator String::end() &#123;</span><br><span class="line">    <span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::const_Iterator String::end() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> String::size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::resize(<span class="keyword">size_t</span> n, <span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; _size) &#123;</span><br><span class="line">        _size = n;</span><br><span class="line">        _str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; _capacity) &#123;</span><br><span class="line">            reserve(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = _size; i &lt; n; i++) &#123;</span><br><span class="line">            _str[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        _size = n;</span><br><span class="line">        _str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> String::capacity() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::reserve(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; _capacity) &#123;</span><br><span class="line">        <span class="keyword">char</span>* tmp = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; <span class="comment">// 实际会根据一定算法开辟空间</span></span><br><span class="line">        <span class="keyword">if</span> (_str) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line">            <span class="keyword">delete</span>[] _str;</span><br><span class="line">        &#125;</span><br><span class="line">        _str = tmp;</span><br><span class="line">        _capacity = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::clear() &#123;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    _str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> String::empty() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) &#123;</span><br><span class="line">    assert(pos &lt;= _size);</span><br><span class="line">    <span class="keyword">return</span> _str[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(pos &lt;= _size);</span><br><span class="line">    <span class="keyword">return</span> _str[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="keyword">const</span> String&amp; s) &#123;</span><br><span class="line">    insert(_size, s._str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">    insert(_size, str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="keyword">char</span> c) &#123;</span><br><span class="line">    insert(_size, <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::insert(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">    assert(pos &lt;= _size);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (_size + len &gt; _capacity) &#123;</span><br><span class="line">        reserve(_size + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> end = _size + len;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; pos + len - <span class="number">1</span>) &#123;</span><br><span class="line">        _str[end] = _str[end - len];</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        _str[pos++] = *str++;</span><br><span class="line">    &#125;</span><br><span class="line">    _size += len;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::insert(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="keyword">char</span> c) &#123;</span><br><span class="line">    assert(pos &lt;= _size);</span><br><span class="line">    <span class="keyword">if</span> (_size + n &gt; _capacity) &#123;</span><br><span class="line">        reserve(_size + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> end = _size + n;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; pos + n - <span class="number">1</span>) &#123;</span><br><span class="line">        _str[end] = _str[end - n];</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        _str[pos++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    _size += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::erase(<span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(pos &lt; _size);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= _size - pos) &#123;</span><br><span class="line">        _size = pos;</span><br><span class="line">        _str[_size] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> begin = pos + n;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= _size) &#123;</span><br><span class="line">            _str[pos++] = _str[begin];</span><br><span class="line">            ++begin;</span><br><span class="line">        &#125;</span><br><span class="line">        _size -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::swap(String&amp; s) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(_str, s._str);</span><br><span class="line">    <span class="built_in">std</span>::swap(_size, s._size);</span><br><span class="line">    <span class="built_in">std</span>::swap(_capacity, s._capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* String::c_str() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> String::find(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">char</span>* ret = <span class="built_in">strstr</span>(_str + pos, str);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret - _str;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> String::find_first_of(<span class="keyword">char</span> c, <span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = pos; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_str[i] == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> String::npos = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="string" scheme="https://Ranjiahao.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>模板总结</title>
    <link href="https://ranjiahao.github.io/2020/03/13/%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
    <id>https://ranjiahao.github.io/2020/03/13/%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-12T16:00:00.000Z</published>
    <updated>2020-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h1><p>template开始，后跟一个模板参数列表（在模板定义中，模板参数列表不能为空）</p><p>typename是用来定义模板参数关键字（C++98之后），也可以 使用class(切记：不能使用struct代替class)</p><h1 id="实例化"><a class="markdownIt-Anchor" href="#实例化"></a> 实例化</h1><p>隐式实例化：让编译器根据实参推演模板参数的实际类型，编译器一般不会进行类型转换操作，形参和实参类型必须完全匹配</p><p>显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型。如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错</p><h1 id="非类型模板参数"><a class="markdownIt-Anchor" href="#非类型模板参数"></a> 非类型模板参数</h1><p>用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用</p><ol><li>浮点数、类对象以及字符串不可作为非类型模板参数</li><li>非类型的模板参数必须在编译期就能确认结果</li></ol><h1 id="模板参数的匹配原则"><a class="markdownIt-Anchor" href="#模板参数的匹配原则"></a> 模板参数的匹配原则</h1><p>对于非模板函数和同名函数模板，如果其他条件都相同，在隐式实例化时会优先调用非模板函数，不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板。模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</p><h1 id="函数模板特化"><a class="markdownIt-Anchor" href="#函数模板特化"></a> 函数模板特化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须要先有一个基础的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">IsEqual</span>(<span class="title">T</span>&amp; <span class="title">left</span>, <span class="title">T</span>&amp; <span class="title">right</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> left == right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字template后面接一对空的尖括号&lt;&gt;，函数名后跟一对尖括号，尖括号中指定需要特化的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> IsEqual&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">char</span>*&amp; left, <span class="keyword">char</span>*&amp; right) &#123;</span><br><span class="line">    <span class="comment">// 函数形参表必须和模板函数的基础参数类型相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(left, right) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下为了实现简单通常都是将函数直接给出</p><h1 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h1><p>类模板中函数放在类外进行定义时，需要加模板参数列表<br>类模板实例化需要在类模板名字后跟&lt;&gt;，实例化的类型放在&lt;&gt;中，类模板名字不是真正的类，而实例化的结果才是真正的类</p><h1 id="类模板特化"><a class="markdownIt-Anchor" href="#类模板特化"></a> 类模板特化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;int, char&gt; &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;T1, int&gt; &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>&lt;T1*, T2*&gt; &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="类型萃取"><a class="markdownIt-Anchor" href="#类型萃取"></a> 类型萃取</h1><p><strong>实现Copy函数，使其可以拷贝任意类型</strong></p><p>单使用memcpy，可以拷贝内置类型，如果涉及到深拷贝(比如string)，就会出错<br>单使用循环赋值，效率很低</p><p>通过增加bool参数判断是否内置类型，就可将两种拷贝的优势结合。但用户需要根据所拷贝元素的类型传递第三个参数，那出错的可能性就增加</p><p>所以需要通过类型萃取来判断是否内置类型，但需要将所有类型遍历一遍，每次比较都是字符串的比较，效率比较低</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPODType</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* arrType[] = &#123; <span class="string">"char"</span>, <span class="string">"short"</span>, <span class="string">"int"</span>, <span class="string">"long"</span>, <span class="string">"long long"</span>, <span class="string">"float"</span>,</span><br><span class="line"><span class="string">"double"</span>, <span class="string">"long double"</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arrType) / <span class="keyword">sizeof</span>(arrType[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(strType, arrType[i]) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Copy</span>(<span class="title">T</span>* <span class="title">dst</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (IsPODType(<span class="keyword">typeid</span>(T).name())) <span class="comment">// RTTI</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, <span class="keyword">sizeof</span>(T)*size);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型萃取一般写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表自定义类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> FalseType IsPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> TrueType IsPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> TrueType IsPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 将所有内置类型都特化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Copy</span>(<span class="title">T</span>* <span class="title">dst</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (TypeTraits&lt;T&gt;::IsPODType::Get()) <span class="comment">// RTTI</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, <span class="keyword">sizeof</span>(T) * size);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stl中写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrueType</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FalseType</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> FalseType IsPodType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> TrueType IsPODType;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeTraits</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> TrueType IsPODType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 将所有内置类型都特化，包括有符号和无符号，比如：对于int类型，必须特化三个，int、signed int、unsigned int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Copy</span>(<span class="title">T</span>* <span class="title">dst</span>, <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>, <span class="title">TrueType</span>) &#123;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, <span class="keyword">sizeof</span>(T)* size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Copy</span>(<span class="title">T</span>* <span class="title">dst</span>, <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>, <span class="title">FalseType</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Copy</span>(<span class="title">T</span>* <span class="title">dst</span>, <span class="title">T</span>* <span class="title">src</span>, <span class="title">size_t</span> <span class="title">size</span>) &#123;</span></span><br><span class="line">    _Copy(dst, src, size, TypeTraits&lt;T&gt;::IsPodType()); <span class="comment">// RTTI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板分离编译"><a class="markdownIt-Anchor" href="#模板分离编译"></a> 模板分离编译</h1><p>如果将模板的声明放在.h文件中，将其定义放在其他.cpp中，在main.cpp中实例化就会出现链接错误</p><p>因为头文件不参与编译，编译器对工程中的多个源文件单独编译，然后将多个obj文件链接</p><p>在定义的.cpp文件中编译器找不到对模板的实例化，不会生成对应的函数</p><p>所以在main.cpp中call找不到对应函数的地址</p><p>有两种方法可以解决：</p><ol><li>将声明和定义放到一个文件 “xxx.hpp” 里面或者xxx.h其实也是可以的</li><li>模板定义的位置显式实例化，这种方法不推荐使用</li></ol><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>模板复用了代码，更快迭代开发，增强了代码的灵活性，但是会导致代码膨胀问题，编译时间变长，出现模板编译错误时，不易定位错误</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h1&gt;&lt;p&gt;template开始，后跟一个模板参数列表（在模板定义中，模板参数列表不能为空）&lt;/p&gt;&lt;p&gt;typename是用来定义模板参数关键字（C++98
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="模板" scheme="https://Ranjiahao.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="类型萃取" scheme="https://Ranjiahao.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>C++引用详解</title>
    <link href="https://ranjiahao.github.io/2020/03/08/C++%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2020/03/08/C++%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用变量"><a class="markdownIt-Anchor" href="#引用变量"></a> 引用变量</h1><p>引用是已定义的变量的别名，它和它引用的变量共用同一块内存空间<br>其主要用途是用作函数的形参，通过这种用法使用原始数据而不是副本</p><ul><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦引用一个实体，再不能引用其他实体</li></ul><h2 id="临时变量"><a class="markdownIt-Anchor" href="#临时变量"></a> 临时变量</h2><p>如果引用参数是const，则编译器将在下面两种情况下生成临时变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span> + <span class="number">3</span>; <span class="comment">// 1. 实参类型正确，但不是左值</span></span><br><span class="line">    <span class="comment">// int&amp; a = 1 + 3; 错误</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; b = <span class="number">3.14</span>;  <span class="comment">// 2. 实参类型不正确，但可以转换成正确类型</span></span><br><span class="line">    <span class="comment">// int&amp; b = 3.14; 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种情况下编译器都生成一个临时匿名变量，这些临时变量出了作用域后自动消失</p><p><strong>为什么常量引用这种行为可以，其他情况不行？</strong><br>从编译器的角度来看，不难发现，如果不加const显然就有可能对变量进行修改，如果此时引用了临时变量，就无法对原来的变量进行修改，所以编译器默认只能用const的引用来指向临时变量</p><h2 id="引用和指针"><a class="markdownIt-Anchor" href="#引用和指针"></a> 引用和指针</h2><p>语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间；<br>底层实现上实际是有空间的，因为引用是按照指针方式来实现的<br><code>int a = 0; int&amp; ra = a; ra = 1;</code><br><code>int a = 0; int* pa = &amp;a; *a = 1;</code><br>这两段代码的反汇编是一模一样的</p><h1 id="c11右值引用"><a class="markdownIt-Anchor" href="#c11右值引用"></a> C++11右值引用</h1><p>C++11中，右值分为纯右值和将亡值</p><ul><li>临时变量，常量、一些运算表达式(1+3)等叫纯右值</li><li>声明周期将要结束的对象叫将亡值</li></ul><p>右值引用只能指向右值，使用&amp;&amp;声明，定义时必须初始化<br>左值引用可以引用左值，也可以引用右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯右值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = <span class="number">3.14</span> + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示将亡值</span></span><br><span class="line"><span class="function">String <span class="title">GetString</span><span class="params">(<span class="keyword">char</span>* pStr)</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">strTemp</span><span class="params">(pStr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> strTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">s1</span><span class="params">(GetString(<span class="string">"hehe"</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器用调用GetString，创造一个匿名对象strTemp，返回的临时对像（可能会优化成直接返回）<br>若String类中未写右值引用版本拷贝构造，则默认使用左值引用版本重新拷贝一份资源给s1，然后释放临时对象。这样就造成不必要的拷贝<br>在string类中加入以下函数即可优化上述步骤：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String(String&amp;&amp; s)</span><br><span class="line">    : _str(s._str)</span><br><span class="line">    , _size(s._size)</span><br><span class="line">    , _capacity(s._capacity) &#123;</span><br><span class="line">    s._str = <span class="literal">nullptr</span>;</span><br><span class="line">    s._size = <span class="number">0</span>;</span><br><span class="line">    s._capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认移动构造赋值"><a class="markdownIt-Anchor" href="#默认移动构造赋值"></a> 默认移动构造/赋值</h2><p>编译器隐式生成一个(如果没有用到则不会生成)移动构造函数，如果声明了移动构造或拷贝构造或移动赋值，则编译器不会生成默认版本。编译器生成的默认移动构造函数是浅拷贝</p><p>同理，编译器默认生成移动赋值，如果声明了移动赋值或赋值运算符重载或移动构造，则编译器不会生成默认版本</p><p>注意：在C++11中，拷贝构造/移动构造/赋值/移动赋值函数必须提供，或者同时不提供，程序才能保证类同时具有拷贝和移动语义</p><h2 id="move"><a class="markdownIt-Anchor" href="#move"></a> move()</h2><p>将一个左值强制转化为右值引用，搭配移动构造使用，可以达到类似对象数据转移的效果</p><p>如果将移动构造函数声明为常右值引用或者返回右值的函数声明为常量，都会导致移动语义无法实现</p><h2 id="完美转发"><a class="markdownIt-Anchor" href="#完美转发"></a> 完美转发</h2><p>函数模板在向其他函数传递自身形参时，如果相应实参是左值，它就应该被转发为左值；如果相应实参是右值，它就应该被转发为右值。<br>C++11通过forward函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; Fun(<span class="built_in">std</span>::forward&lt;T&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PerfectForward(<span class="number">10</span>);           <span class="comment">// rvalue ref</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    PerfectForward(a);            <span class="comment">// lvalue ref</span></span><br><span class="line">    PerfectForward(<span class="built_in">std</span>::move(a)); <span class="comment">// rvalue ref</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    PerfectForward(b);            <span class="comment">// const lvalue ref</span></span><br><span class="line">    PerfectForward(<span class="built_in">std</span>::move(b)); <span class="comment">// const rvalue ref</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引用变量&quot;&gt;&lt;/a&gt; 引用变量&lt;/h1&gt;&lt;p&gt;引用是已定义的变量的别名，它和它引用的变量共用同一块内存空间&lt;br&gt;其主要用途是用作函数的形参，通过这种用法使用原始数据而不是副本&lt;/
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="右值引用" scheme="https://Ranjiahao.github.io/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="完美转发" scheme="https://Ranjiahao.github.io/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++11 lambda表达式</title>
    <link href="https://ranjiahao.github.io/2020/03/06/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://ranjiahao.github.io/2020/03/06/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c11-lambda表达式"><a class="markdownIt-Anchor" href="#c11-lambda表达式"></a> C++11 lambda表达式</h1><p>如果想要对一个数据集合中的元素进行排序，可以使用std::sort方法<br>但在想要自定义比较规则时必须提供仿函数对象<br>C++11 中lambda表达式可以简化这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AAA(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> AAA&amp; a, <span class="keyword">const</span> AAA&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a._a &gt; b._a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;AAA&gt; v&#123; &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125; , &#123;<span class="number">4</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 必须提供仿函数的比较方法</span></span><br><span class="line">    sort(v.begin(), v.end(), Greater());</span><br><span class="line">    sort(v.begin(), v.end(),</span><br><span class="line">         [](AAA&amp; a, AAA&amp; b)-&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a._a &gt; b._a;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e._a &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式是一个匿名函数，可借助auto将其赋值给一个变量，然后调用</p><h2 id="表达式格式"><a class="markdownIt-Anchor" href="#表达式格式"></a> 表达式格式</h2><p><strong>[捕捉列表] (参数列表) mutable -&gt; 返回值类型 { 函数体 }</strong></p><p><strong>[]捕捉列表</strong><br>获取父作用域的变量，供函数使用，编译器根据[]来判断接下来<br>的代码是否为lambda函数<br>[a, b]: 以值的形式获取父作用域的变量a,b<br>[=]: 以值的形式获取父作用域的所有变量, 变量的属性都为const(包括this)<br>[=, a]: 错误写法，捕捉a重复<br>[=, &amp;a]: 正确写法，除了a，其他以值的形式获取父作用域变量， a以引用的形式获取<br>[&amp;] : 以引用的形式获取父作用域的所有变量，(包括this)<br>[this]: 获取成员变量的this指针，只能在成员函数内部使用<br><strong>()参数列表</strong><br>如果不需要参数传递，则可以连同()一起省略<br><strong>mutable</strong><br>可选，删除捕捉列表中以值的形式获取的变量的const属性，使用该修饰符时，参数列表不可省略(即使参数为空)<br><strong>-&gt;返回值类型</strong><br>用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导<br><strong>{}函数体</strong><br>在函数体内，可以使用参数外，以及所有捕获到的变量。<br><strong>使用注意事项</strong></p><ul><li>在块作用域以外的lambda函数捕捉列表必须为空</li><li>在块作用域中的lambda函数仅能捕捉父作用域中局部变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*PF)();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = []&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> f2 = []&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    <span class="comment">//f1 = f2; // 编译失败---&gt;提示找不到operator=() lambda表达式之间不能相互赋值</span></span><br><span class="line">    <span class="comment">// 允许使用一个lambda表达式拷贝构造一个新的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">f3</span><span class="params">(f2)</span></span>;</span><br><span class="line">    <span class="comment">// 可以将lambda表达式赋值给相同类型的函数指针</span></span><br><span class="line">    PF = f2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda底层</strong><br><img src="img1.png" alt="img1"><br>通过汇编我们可以清楚的看到，编译器会自动生成一个类，在其中重载了operator()</p><h1 id="c11-auto"><a class="markdownIt-Anchor" href="#c11-auto"></a> C++11 auto</h1><p>C++11中，auto声明的变量可以由编译器在编译时期推导而得，可以与lambda表达式，或范围for搭配使用<br>使用auto时必须进行初始化，编译阶段需根据初始化表达式来推导auto的实际类型<br>auto是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型<br>auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;<br>声明多个变量时，变量必须类型相同，否则会报错，编译器只对第一个进行推导，然后用推导出来的类型定义其他变量<br>auto不能作为函数的参数，不能直接用来声明数组，不能定义类的非静态成员变量<br>实例化模板时不能使用auto作为模板参数</p><h1 id="c11-decltype"><a class="markdownIt-Anchor" href="#c11-decltype"></a> C++11 decltype</h1><p>根据表达式的实际类型推演出定义变量时所用的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 用decltype推演a+b的实际类型，作为定义c的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(a+b) c;</span><br><span class="line">    <span class="comment">// 如果没有带参数，推导函数的类型</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>(Fuc)).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 如果带参数列表，推导的是函数返回值的类型，此处只推演，不会执行函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>(Fuc(<span class="number">0</span>))).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c11-基于范围的for循环"><a class="markdownIt-Anchor" href="#c11-基于范围的for循环"></a> C++11 基于范围的for循环</h1><p>for循环迭代的范围必须是确定的，对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end方法，begin和end就是for循环迭代的范围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : arr) <span class="comment">// arr为指针，编译器并不知道数组的范围所以报错</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代的对象要实现++和==的操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c11-lambda表达式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c11-lambda表达式&quot;&gt;&lt;/a&gt; C++11 lambda表达式&lt;/h1&gt;&lt;p&gt;如果想要对一个数据集合中的元素进行排序，可以使用std::sort方法&lt;br
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="lambda表达式" scheme="https://Ranjiahao.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="auto" scheme="https://Ranjiahao.github.io/tags/auto/"/>
    
      <category term="decltype" scheme="https://Ranjiahao.github.io/tags/decltype/"/>
    
      <category term="范围for" scheme="https://Ranjiahao.github.io/tags/%E8%8C%83%E5%9B%B4for/"/>
    
  </entry>
  
  <entry>
    <title>设计一个类，只能在栈/堆上创建对象</title>
    <link href="https://ranjiahao.github.io/2020/03/03/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E6%88%96%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/"/>
    <id>https://ranjiahao.github.io/2020/03/03/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E6%88%96%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计一个类只能在栈堆上创建对象"><a class="markdownIt-Anchor" href="#设计一个类只能在栈堆上创建对象"></a> 设计一个类，只能在栈/堆上创建对象</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapOnly</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HeapOnly* <span class="title">CreateObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将构造函数私有化</span></span><br><span class="line">    HeapOnly() &#123;&#125;</span><br><span class="line">    <span class="comment">// 防拷贝</span></span><br><span class="line">    HeapOnly(<span class="keyword">const</span> HeapOnly&amp;);</span><br><span class="line">    <span class="comment">// 防拷贝C++11写法</span></span><br><span class="line">    <span class="comment">// HeapOnly(const HeapOnly&amp;) = delete;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">HeapOnly</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HeapOnly() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">Destory</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存</span></span><br><span class="line">    ~HeapOnly() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOnly</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> StackOnly <span class="title">CreateObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StackOnly();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StackOnly() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOnly</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StackOnly() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计一个类只能在栈堆上创建对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计一个类只能在栈堆上创建对象&quot;&gt;&lt;/a&gt; 设计一个类，只能在栈/堆上创建对象&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>实现date类</title>
    <link href="https://ranjiahao.github.io/2020/03/01/%E5%AE%9E%E7%8E%B0date%E7%B1%BB/"/>
    <id>https://ranjiahao.github.io/2020/03/01/%E5%AE%9E%E7%8E%B0date%E7%B1%BB/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-02-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// date.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetMonthDay</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> monthArray[<span class="number">13</span>] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> ((month == <span class="number">2</span>)</span><br><span class="line">            &amp;&amp; ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">                || (year % <span class="number">400</span> == <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">29</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monthArray[month];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> Date&amp;d) <span class="keyword">const</span>;</span><br><span class="line">    Date&amp; <span class="keyword">operator</span>++();<span class="comment">// 前置++</span></span><br><span class="line">    Date <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">// 后置++</span></span><br><span class="line">    Date&amp; <span class="keyword">operator</span>--();<span class="comment">// 前置--</span></span><br><span class="line">    Date <span class="keyword">operator</span>--(<span class="keyword">int</span>);<span class="comment">// 后置--</span></span><br><span class="line">    Date <span class="keyword">operator</span>+(<span class="keyword">int</span> day) <span class="keyword">const</span>;</span><br><span class="line">    Date <span class="keyword">operator</span>-(<span class="keyword">int</span> day) <span class="keyword">const</span>;</span><br><span class="line">    Date&amp; <span class="keyword">operator</span>+=(<span class="keyword">int</span> day);</span><br><span class="line">    Date&amp; <span class="keyword">operator</span>-=(<span class="keyword">int</span> day);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// date.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Date.h"</span></span></span><br><span class="line"></span><br><span class="line">Date::Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) &#123;</span><br><span class="line">    <span class="keyword">if</span> (year &gt;= <span class="number">1900</span></span><br><span class="line">        &amp;&amp; month &gt; <span class="number">0</span> &amp;&amp; month &lt; <span class="number">13</span></span><br><span class="line">        &amp;&amp; day &gt; <span class="number">0</span> &amp;&amp; day &lt;= GetMonthDay(year, month)) &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input illegal,reset to default value"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        _year = <span class="number">1900</span>;</span><br><span class="line">        _month = <span class="number">1</span>;</span><br><span class="line">        _day = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d) &#123;</span><br><span class="line">    _cout &lt;&lt; d._year &lt;&lt; <span class="string">"-"</span> &lt;&lt; d._month &lt;&lt; <span class="string">"-"</span> &lt;&lt; d._day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, Date&amp; d) &#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    _cin &gt;&gt; year;</span><br><span class="line">    _cin &gt;&gt; month;</span><br><span class="line">    _cin &gt;&gt; day;</span><br><span class="line">    <span class="comment">// new(&amp;d)Date(year, month, day);</span></span><br><span class="line">    d = Date(year, month, day);</span><br><span class="line">    <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Date::<span class="keyword">operator</span>-(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="function">Date <span class="title">maxdate</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">mindate</span><span class="params">(d)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> &lt; d) &#123;</span><br><span class="line">        maxdate = d;</span><br><span class="line">        mindate = *<span class="keyword">this</span>;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (mindate != maxdate) &#123;</span><br><span class="line">        ++mindate;</span><br><span class="line">        ++days;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> days * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++d 前置++</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// d++ 后置++</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="function">Date <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --d 前置--</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    *<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// d-- 后置--</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    *<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>+(<span class="keyword">int</span> day) <span class="keyword">const</span> &#123;</span><br><span class="line">    Date ret = *<span class="keyword">this</span>;</span><br><span class="line">    ret += day;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>-(<span class="keyword">int</span> day) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="function">Date <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ret -= day;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="keyword">int</span> day) &#123;</span><br><span class="line">    <span class="keyword">if</span> (day &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> -= -day;</span><br><span class="line">    &#125;</span><br><span class="line">    _day += day;</span><br><span class="line">    <span class="keyword">while</span> (_day &gt; GetMonthDay(_year, _month)) &#123;</span><br><span class="line">        _day -= GetMonthDay(_year, _month);</span><br><span class="line">        _month++;</span><br><span class="line">        <span class="keyword">if</span> (_month == <span class="number">13</span>) &#123;</span><br><span class="line">            ++_year;</span><br><span class="line">            _month = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>-=(<span class="keyword">int</span> day) &#123;</span><br><span class="line">    <span class="keyword">if</span> (day &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> += -day;</span><br><span class="line">    &#125;</span><br><span class="line">    _day -= day;</span><br><span class="line">    <span class="keyword">while</span> (_day &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        --_month;</span><br><span class="line">        <span class="keyword">if</span> (_month == <span class="number">0</span>) &#123;</span><br><span class="line">            _month = <span class="number">12</span>;</span><br><span class="line">            --_year;</span><br><span class="line">        &#125;</span><br><span class="line">        _day += GetMonthDay(_year, _month);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_year &gt; d._year) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_year == d._year) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_month &gt; d._month) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_month == d._month) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_day &gt; d._day) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &gt; d || *<span class="keyword">this</span> == d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt;= d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Date::<span class="keyword">operator</span>!=(<span class="keyword">const</span> Date&amp; d) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date date;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; date &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="date类" scheme="https://Ranjiahao.github.io/tags/date%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>类的六个默认成员函数</title>
    <link href="https://ranjiahao.github.io/2020/01/07/%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>https://ranjiahao.github.io/2020/01/07/%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2020-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p>构造函数是一个特殊的成员函数，名字与类名相同，无返回值，可以重载，创建对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次，其主要任务是初始化对象</p><h2 id="使用构造函数"><a class="markdownIt-Anchor" href="#使用构造函数"></a> 使用构造函数</h2><p>C++提供了显式调用和隐式调用两种使用构造函数来初始化对象的方式<br>注意：如果通过隐式调用默认构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S(<span class="keyword">int</span> a = <span class="number">1</span>, <span class="built_in">string</span> s = <span class="string">"sss"</span>) &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _s = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="built_in">string</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s1 = S(<span class="number">3</span>, <span class="string">"Ran"</span>); <span class="comment">// 显示调用</span></span><br><span class="line">    <span class="function">S <span class="title">s2</span><span class="params">(<span class="number">3</span>, <span class="string">"ran"</span>)</span></span>;     <span class="comment">// 隐式调用</span></span><br><span class="line">    S s3;               <span class="comment">// S s3();为函数声明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认构造函数"><a class="markdownIt-Anchor" href="#默认构造函数"></a> 默认构造函数</h2><p>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且只能有一个<br>若未显式定义构造函数，则编译器会自动生成一个无参的默认构造函数，主要作用是调用自定类型成员的默认构造，一旦用户显式定义编译器将不再生成</p><h2 id="初始化列表"><a class="markdownIt-Anchor" href="#初始化列表"></a> 初始化列表</h2><p>构造函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，在初始化列表中,而构造函数体内可以多次赋值<br>声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a)</span><br><span class="line">        : _a(a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 冒号开始，以逗号分隔的数据成员列表，</span></span><br><span class="line">    <span class="comment">// 每个成员变量后面跟一个放在括号中的初始值或表达式</span></span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> ref)</span><br><span class="line">        : _aobj(a)</span><br><span class="line">        , _ref(ref)</span><br><span class="line">        , _n(<span class="number">10</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 引用成员变量、const成员变量、类类型成员（该类没有默认构造函数）</span></span><br><span class="line"><span class="comment">       必须放在初始化列表位置进行初始化 */</span></span><br><span class="line">    A _aobj;      <span class="comment">// 没有默认构造函数</span></span><br><span class="line">    <span class="keyword">int</span>&amp; _ref;    <span class="comment">// 引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> _n; <span class="comment">// const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单参构造"><a class="markdownIt-Anchor" href="#单参构造"></a> 单参构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S(<span class="keyword">int</span> s = <span class="number">1</span>) &#123;</span><br><span class="line">        _s = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S obj;</span><br><span class="line">    obj = <span class="number">1999</span>; <span class="comment">// 实际编译器会构造一个无名对象，最后用无名对象给obj进行赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> s = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    _s = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c11-成员初始化"><a class="markdownIt-Anchor" href="#c11-成员初始化"></a> C++11 成员初始化</h2><p>C++11支持非静态成员变量在声明时进行初始化赋值，但是要注意这里不是初始化，这里是给声明的成员变量缺省值。即，如果初始化列表和声明的时候都有初始化参数，会优先使用初始化列表初始化</p><h2 id="c11-委派构造函数"><a class="markdownIt-Anchor" href="#c11-委派构造函数"></a> C++11 委派构造函数</h2><p>通过委派其他构造函数，使多构造函数的类编写更容易</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委派构造函数将构造的任务委派给目标构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数</span></span><br><span class="line">    Info()</span><br><span class="line">        : _a(<span class="number">0</span>)</span><br><span class="line">        , _c(<span class="string">'a'</span>) &#123;</span><br><span class="line">        InitRSet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委派构造函数</span></span><br><span class="line">    Info(<span class="keyword">int</span> a)</span><br><span class="line">        : Info() &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委派构造函数</span></span><br><span class="line">    Info(<span class="keyword">char</span> c)</span><br><span class="line">        : Info() &#123;</span><br><span class="line">        _c = c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitRSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化其他变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">char</span> _c;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数不能同时“委派”和使用初始化列表</p><h1 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h1><p>本质是构造函数的一个重载形式，参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用<br>若未显示定义，编译器自动生成默认拷贝构造函数，默认的拷贝构造函数为浅拷贝<br>若显示定义拷贝构造，则编译器不会生成默认构造函数（拷贝构造是构造函数的重载）</p><h1 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h1><p>无参数无返回值，一个对象只有一个析构函数<br>若未显式定义，系统会自动生成默认的析构函数，对象在销毁时会自动调用析构函数，并对自定类型成员调用它的析构函数，完成类的一些资源清理工作<br>如果是在栈上创建多个对象，则最后创建的对象最先被删除，最先创建的对象最后被删除<br>注意：申请空间时候必须自己写析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S(<span class="keyword">int</span> a = <span class="number">1</span>, <span class="built_in">string</span> s = <span class="string">"sss"</span>) &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~S() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~S()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="built_in">string</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// 如果没有大括号，代码块将为整个main()，</span></span><br><span class="line">      <span class="comment">// 仅当main()执行完毕调析构，在窗口环境中可能无法看到~S()</span></span><br><span class="line">        S s = S();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果 ~S()<br>某些编译器可能输出两个 ~S()</p><p>C++标准允许编译器使用两种方式来执行<code>S s = S();</code></p><ol><li>第一种等价于<code>S s;</code>创建一个对象，执行一次析构</li><li>第二种会创造一个匿名临时对象，然后将匿名对象复制到s中，创建两个对象，执行两次析构</li></ol><p>所以尽量使用<code>S s;</code>这种隐式构造，通常效率更高</p><h1 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h1><p>运算符重载是一种形式的C++多态</p><ul><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型或者枚举类型的用户定义参数，防止用户为内置类型重载运算符。</li><li>必须遵守语法规则，如，不可将%重载成一个操作数。</li><li>.* :: sizeof ?: . typeid const_cast dynamic_cast reinterpret_cast static_cast 不可重载</li></ul><p>一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的浅拷贝<br>如果需要自己写赋值运算符重载，需要检查是否自己给自己赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符重载演示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S(<span class="keyword">int</span> a = <span class="number">1</span>, <span class="built_in">string</span> s = <span class="string">"sss"</span>) &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    S&amp; <span class="keyword">operator</span>+(S&amp; s) &#123;</span><br><span class="line">        _a += s._a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="built_in">string</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S a, b, c;</span><br><span class="line">    a = a + b + c;</span><br><span class="line">    <span class="comment">// a = a.operator+(b).operator+(c); 和上面代码等价</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="取地址及const取地址操作符重载"><a class="markdownIt-Anchor" href="#取地址及const取地址操作符重载"></a> 取地址及const取地址操作符重载</h1><p>将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改<br>const对象不能调用非const成员函数<br>const成员函数内不能调用其它的非const成员函数</p><p>取地址及const取地址操作符重载一般不用重新定义，编译器默认会生成<br><code>Type* operator&amp;() { return this; }</code><br><code>const Type* operator&amp;() const { return this; }</code></p><h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1><p>编译时，编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率，但是占用更多内存。</p><ul><li>当执行函数代码时间比处理函数调用机制时间长时，则节省的时间比例不高，不必声明为内联。当函数代码少，并且函数经常被调用，声明为内联可以提升程序运行效率</li><li>inline对于编译器而言只是一个建议，编译器会自动优化，如果函数体内有循环/递归等，编译器优化时会忽略掉内联</li><li>inline在类外定义时，只需在类实现部分中使用inline限定符，必须在每个使用它们的文件中都定义，防止链接错误，因为inline被展开，就没有函数地址了，链接就会找不到。所以直接将定义放在头文件中最简单</li></ul><p>由于宏定义的缺点，在C++中我们可以采用内联函数和const替换宏的函数和常量定义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#构造函数&quot;&gt;&lt;/a&gt; 构造函数&lt;/h1&gt;&lt;p&gt;构造函数是一个特殊的成员函数，名字与类名相同，无返回值，可以重载，创建对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="构造函数" scheme="https://Ranjiahao.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://Ranjiahao.github.io/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="运算符重载" scheme="https://Ranjiahao.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="内联函数" scheme="https://Ranjiahao.github.io/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>类和对象</title>
    <link href="https://ranjiahao.github.io/2019/12/03/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://ranjiahao.github.io/2019/12/03/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-12-02T16:00:00.000Z</published>
    <updated>2019-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>C语言中结构体中只能定义变量，C++中结构体内不仅可以定义变量，也可以定义函数，C++中更喜欢用class来代替。区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private</p><h1 id="定义方式"><a class="markdownIt-Anchor" href="#定义方式"></a> 定义方式</h1><ol><li>声明、定义全放类中。成员函数如果在类中定义，编译器可能会将其当成内联函数处理</li><li>声明放在.h文件中，定义放在.cpp文件中（推荐使用）</li></ol><h1 id="类的访问限定符及封装"><a class="markdownIt-Anchor" href="#类的访问限定符及封装"></a> 类的访问限定符及封装</h1><p>C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用，本质是一种管理</p><ol><li>public修饰的成员在类外可以直接被访问，protected和private修饰的成员在类外不能直接被访问</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li></ol><p>注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</p><h1 id="类对象模型"><a class="markdownIt-Anchor" href="#类对象模型"></a> 类对象模型</h1><p>对象中只保存成员变量，成员函数存放在公共的代码段<br>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐<br>注意空类的大小，编译器给了空类一个字节来唯一标识这个类</p><h1 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h1><p>C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象，函数体中所有成员变量的操作，都是通过该指针去访问。用户不需要来传递，编译器自动完成</p><ol><li>this指针类型：类类型* const</li><li>this指针是成员函数第一个隐含的指针形参，是对象调用成员函数时，将对象地址作为实参传递给this形参，一般情况由编译器通过ecx寄存器自动传递，不可显示写出，对象中不存储this指针</li><li>this指针可以为空，但是不可访问成员变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;Print();           <span class="comment">// 正确，只访问了公共代码段</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptr-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，不可访问成员变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S stuff1[<span class="number">4</span>]; <span class="comment">// 调用默认构造</span></span><br><span class="line">S stuff2[<span class="number">4</span>] = &#123;</span><br><span class="line">    S(<span class="number">0</span>,<span class="string">"aaa"</span>),</span><br><span class="line">    S(),</span><br><span class="line">    S(<span class="number">2</span>,<span class="string">"ccc"</span>),</span><br><span class="line">&#125;; <span class="comment">// stuff2[1] stuff2[3] 调用默认构造</span></span><br></pre></td></tr></table></figure><p>最好总是提供一个默认的构造函数。如果没有，则必须确保为数组中的每个对象提供一个初始化项</p><h1 id="c11-列表初始化"><a class="markdownIt-Anchor" href="#c11-列表初始化"></a> C++11 列表初始化</h1><p>C++11扩大了列表初始化的使用范围，使其可用于所有的内置类型和用户自定<br>义的类型，需要提供与构造函数的参数列表匹配的内容，使用时，可添加等号(=)，也可不添加</p><h2 id="内置类型的列表初始化"><a class="markdownIt-Anchor" href="#内置类型的列表初始化"></a> 内置类型的列表初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置类型变量</span></span><br><span class="line"><span class="keyword">int</span> x&#123; <span class="number">1</span> + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> arr[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态数组，在C++98中不支持</span></span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123; &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>,&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">4</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="自定义类型的列表初始化"><a class="markdownIt-Anchor" href="#自定义类型的列表初始化"></a> 自定义类型的列表初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S s1&#123;&#125;;</span><br><span class="line">S s2; <span class="comment">// s1 s2等价</span></span><br><span class="line"></span><br><span class="line">S s3&#123; <span class="number">3</span>,<span class="string">"ran"</span> &#125;; <span class="comment">// S s3 = &#123; 3, "ran"&#125;,可添加等号(=)，也可不添加</span></span><br><span class="line"><span class="function">S <span class="title">s4</span><span class="params">(<span class="number">3</span>, <span class="string">"ran"</span>)</span></span>;  <span class="comment">// s3 s4等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">S stuff[<span class="number">4</span>]&#123;</span><br><span class="line">    S(<span class="number">0</span>,<span class="string">"aaa"</span>),</span><br><span class="line">    S(),</span><br><span class="line">    S(<span class="number">2</span>,<span class="string">"ccc"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="容器类型的列表初始化"><a class="markdownIt-Anchor" href="#容器类型的列表初始化"></a> 容器类型的列表初始化</h2><p>实现vector类想要支持列表初始化，需给该类添加一个带有initializer_list类型参数的构造函数，否则<code>Vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6 };</code>就会报错，编译器以为要创建6个对象： <code>Vector&lt;int&gt; v[6]{ 1, 2, 3, 4, 5, 6 };</code><br>改进如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Vector(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&amp; lst)</span><br><span class="line">            : _start(<span class="keyword">new</span> T[lst.size()])</span><br><span class="line">            , _endOfStorage(_start + lst.size())</span><br><span class="line">            , _finish(_start) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">                *_finish = e;</span><br><span class="line">                ++_finish;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; lst) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _start;</span><br><span class="line">        _start = <span class="keyword">new</span> T[lst.size()];</span><br><span class="line">        _endOfStorage = _start + lst.size();</span><br><span class="line">        _finish = _start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">            *_finish = e;</span><br><span class="line">            ++_finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _start = <span class="literal">nullptr</span>;</span><br><span class="line">    T* _finish = <span class="literal">nullptr</span>;</span><br><span class="line">    T* _endOfStorage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6 };</code>创建一个对象，并将成员初始化。</p><p>initializer_list是系统自定义的类模板，该类模板中主要有三个方法：begin()、end()迭代器以及获取区间中元素个数的方法size()</p><h1 id="c11-默认函数控制"><a class="markdownIt-Anchor" href="#c11-默认函数控制"></a> C++11 默认函数控制</h1><p>显式缺省函数：<br>C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本<br>删除默认函数：<br>在函数声明加上=delete，编译器不生成对应函数的默认版本<br>与=default不同，=delete必须出现在函数第一次声明的时候</p><h1 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> const成员函数</h1><p>const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改<br>加上const修饰后，隐式的将 <code>类类型* const this</code> 变成 <code>const 类类型* const this</code></p><ul><li><p>非const对象/成员函数可以调用任何成员函数</p></li><li><p>const对象/成员函数只可以调用const成员函数</p></li></ul><h2 id="mutable"><a class="markdownIt-Anchor" href="#mutable"></a> mutable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">personInfo</span> &#123;</span></span><br><span class="line">        <span class="keyword">mutable</span> <span class="keyword">int</span> age=<span class="number">18</span>; <span class="comment">// 即使结构变量或类为const，其某个成员也可以被修改</span></span><br><span class="line">        <span class="keyword">int</span> expr = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    personInfo <span class="keyword">const</span> p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p1.age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="static成员"><a class="markdownIt-Anchor" href="#static成员"></a> static成员</h1><p>static可以声明成员函数和成员变量</p><ul><li>静态成员为所有类对象所共享，不属于某个具体的实例，静态成员变量必须在类外定义，定义时不添加static关键字</li><li>类静态成员即可用类名::静态成员或者对象.静态成员来访问</li><li>没有隐藏的this指针，不能访问任何非静态成员</li></ul><h1 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h1><p>类方法和友元只是表达类接口的两种不同机制。但友元会增加耦合度，破坏了封装，所以友元不宜多用</p><h2 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h2><ul><li>友元函数可访问类的私有成员，但不是类的成员函数，不能使用成员运算符来调用</li><li>定义在类外部，可以在类定义的任何地方声明，不受类访问限定符限制</li><li>当友元函数代码很短时，可以在声明时同时定义，可成为内联函数</li><li>一个函数可以是多个类的友元函数</li><li>友元函数不能用const修饰</li></ul><p>代替友元函数的办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    S&amp; <span class="keyword">operator</span>+(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        _a += n;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="built_in">string</span> _s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就可以避免突破封装了</span></span><br><span class="line">S&amp; <span class="keyword">operator</span>+(<span class="keyword">int</span> n, S&amp; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> s + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S obj;</span><br><span class="line">    obj = obj + <span class="number">1</span>; <span class="comment">// obj = obj.operator+(1);</span></span><br><span class="line">    obj = <span class="number">1</span> + obj; <span class="comment">// 调用S&amp; operator+(int n, S&amp; s)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h2><ul><li>友元类的所有成员函数都可以是另一个类的友元函数</li><li>单向，不可传递</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span>;</span> <span class="comment">// 类的不完全声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">AAA</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BBB() :_b(<span class="number">3</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问私有成员</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; _obj._b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BBB _obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AAA a;</span><br><span class="line">    a.Test(); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h1><p>内部类是一个独立的类，它不属于外部类，可以看作外部类的友元类，外部类对内部类没有任何优越的访问权限</p><ul><li>可以定义在外部类的任何地方</li><li>sizeof(外部类)=外部类，和内部类没有任何关系</li><li>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">aaa</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 3</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; RED &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 0</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; GREEN &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">enum</span> Color &#123;</span><br><span class="line">        RED,</span><br><span class="line">        GREEN</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> AAA::k = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AAA::aaa a;</span><br><span class="line">    a.Test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言中结构体中只能定义变量，C++中结构体内不仅可以定义变量，也可以定义函数，C++中更喜欢用class来代替。区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private&lt;/p&gt;&lt;h1 id=&quot;定义方式&quot;&gt;&lt;a clas
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="C++11列表初始化" scheme="https://Ranjiahao.github.io/tags/C-11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
      <category term="友元" scheme="https://Ranjiahao.github.io/tags/%E5%8F%8B%E5%85%83/"/>
    
      <category term="内部类" scheme="https://Ranjiahao.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>函数重载及原理详解</title>
    <link href="https://ranjiahao.github.io/2019/12/01/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2019/12/01/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h1><ol><li>半缺省参数必须从右往左依次来给出，不能间隔着给</li><li>缺省参数不能在函数声明和定义中同时出现</li><li>缺省值必须是常量或者全局变量</li></ol><h1 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h1><p>C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表参数<strong>个数 或 类型 或 顺序</strong>必须不同，可以通过函数重载实现编译时多态</p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><ol><li>由于函数传参为值拷贝，所以在没有最合适的匹配函数时，会生成临时变量来匹配对应实参</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fuc(<span class="number">3.14</span>); <span class="comment">// 生成临时变量3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当没有最合适匹配，但能匹配的函数不唯一时，编译器会报错</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">long</span> a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fuc(<span class="number">3.14</span>); <span class="comment">// 此时编译器并不知道调用哪个fuc函数，会出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以匹配成功的前提是：能匹配的函数唯一确定。或者有多个能匹配，但只有一个最合适匹配</strong><br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> a)</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fuc(<span class="number">3.14</span>); <span class="comment">// 匹配时，不区分const，有两个最合适匹配，会出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fuc(<span class="number">3.14</span>); <span class="comment">// 两个函数都能匹配，但是第二个函数最匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载引用指针参数"><a class="markdownIt-Anchor" href="#重载引用指针参数"></a> 重载引用/指针参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    Fuc(&amp;a); <span class="comment">// 只有第二个最匹配，调用Fuc(const int* a)</span></span><br><span class="line">    Fuc(&amp;b); <span class="comment">// 两个都匹配，但第一个最匹配，调用void Fuc(int* a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">double</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">(<span class="keyword">double</span> &amp;&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    Fuc(a); <span class="comment">// 可以匹配前两个，但是第二个最匹配，调用Fuc(double&amp; a)</span></span><br><span class="line">    Fuc(b); <span class="comment">// 只能匹配第二个，调用Fuc(const double&amp; a)</span></span><br><span class="line">    Fuc(<span class="number">3.14</span> + <span class="number">1</span>); <span class="comment">// 可以和二三匹配，但是和第三个最匹配，调用Fuc(double &amp;&amp; a)</span></span><br><span class="line">    Fuc(<span class="number">3.14</span>); <span class="comment">// vs下调用Fuc(double &amp;&amp; a) linux下会报错，应避免这样用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>拿这段代码来说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">double</span>* b, <span class="keyword">char</span>* c)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Print(<span class="number">3</span>, <span class="number">3.14</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux下执行命令objdump -d a.out |less反汇编。仅展示部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">000000000040062d &lt;_Z5Printidc&gt;:</span><br><span class="line">  40062d:       55                      push   %rbp</span><br><span class="line">  40062e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  400631:       89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">  400634:       f2 0f 11 45 f0          movsd  %xmm0,-0x10(%rbp)</span><br><span class="line">  400639:       89 f0                   mov    %esi,%eax</span><br><span class="line">  40063b:       88 45 f8                mov    %al,-0x8(%rbp)</span><br><span class="line">  40063e:       5d                      pop    %rbp</span><br><span class="line">  40063f:       c3                      retq   </span><br><span class="line"></span><br><span class="line">0000000000400640 &lt;_Z5PrintPiPdPc&gt;:</span><br><span class="line">  400640:       55                      push   %rbp</span><br><span class="line">  400641:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  400644:       48 89 7d f8             mov    %rdi,-0x8(%rbp)</span><br><span class="line">  400648:       48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">  40064c:       48 89 55 e8             mov    %rdx,-0x18(%rbp)</span><br><span class="line">  400650:       5d                      pop    %rbp</span><br><span class="line">  400651:       c3                      retq   </span><br><span class="line">  </span><br><span class="line">0000000000400652 &lt;main&gt;:</span><br><span class="line">  400652:       55                      push   %rbp</span><br><span class="line">  400653:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  400656:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  40065a:       48 b8 1f 85 eb 51 b8    movabs $0x40091eb851eb851f,%rax</span><br><span class="line">  400661:       1e 09 40 </span><br><span class="line">  400664:       be 61 00 00 00          mov    $0x61,%esi</span><br><span class="line">  400669:       48 89 45 f8             mov    %rax,-0x8(%rbp)</span><br><span class="line">  40066d:       f2 0f 10 45 f8          movsd  -0x8(%rbp),%xmm0</span><br><span class="line">  400672:       bf 03 00 00 00          mov    $0x3,%edi</span><br><span class="line">  400677:       e8 b1 ff ff ff          callq  40062d &lt;_Z5Printidc&gt;</span><br><span class="line">  40067c:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400681:       c9                      leaveq </span><br><span class="line">  400682:       c3                      retq</span><br></pre></td></tr></table></figure><p>Print(int a, double b, char c)的函数签名变为&lt;_Z5Printidc&gt;<br>Print(int* a, double* b, char* c)的函数签名变为&lt;_Z5PrintPiPdPc&gt;</p><p>验证其他代码后，可以发现大概是int-&gt;i，long-&gt;l，char-&gt;c，string-&gt;Ss…基本上都是用首字母代表</p><p>编译器实际在底层使用被重新修饰过的一个比较复杂的名字，被重新修饰后的名字中包含了：函数的名字以及参数类型。这就是为什么函数重载中几个同名函数要求其参数列表不同的原因。<br><strong>linux 下函数名修饰规则：_Z + 名称空间 + 函数字符个数 + 函数名 + 类型首字符</strong></p><p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span><span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Print(<span class="number">3</span>, <span class="number">3.14</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux下执行命令objdump -d a.out |less反汇编。仅展示部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">000000000040062d &lt;Print&gt;:</span><br><span class="line">  40062d:    55                       push   %rbp</span><br><span class="line">  40062e:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">  400631:    89 7d fc                 mov    %edi,-0x4(%rbp)</span><br><span class="line">  400634:    f2 0f 11 45 f0           movsd  %xmm0,-0x10(%rbp)</span><br><span class="line">  400639:    89 f0                    mov    %esi,%eax</span><br><span class="line">  40063b:    88 45 f8                 mov    %al,-0x8(%rbp)</span><br><span class="line">  40063e:    5d                       pop    %rbp</span><br><span class="line">  40063f:    c3                       retq</span><br></pre></td></tr></table></figure><p>由于C语言只是单纯的函数名。因此当工程中存在相同函数名的函数时，就会产生冲突</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;默认参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#默认参数&quot;&gt;&lt;/a&gt; 默认参数&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;半缺省参数必须从右往左依次来给出，不能间隔着给&lt;/li&gt;&lt;li&gt;缺省参数不能在函数声明和定义中同时出现&lt;/li&gt;&lt;li&gt;缺省
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="函数重载" scheme="https://Ranjiahao.github.io/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
      <category term="默认参数" scheme="https://Ranjiahao.github.io/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>命名空间与链接性</title>
    <link href="https://ranjiahao.github.io/2019/10/07/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E9%93%BE%E6%8E%A5%E6%80%A7/"/>
    <id>https://ranjiahao.github.io/2019/10/07/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E9%93%BE%E6%8E%A5%E6%80%A7/</id>
    <published>2019-10-06T16:00:00.000Z</published>
    <updated>2019-10-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++中，名称可以是变量、函数、结构、枚举、类、以及类和结构的成员。使用名称空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染</p><h1 id="传统c名称空间"><a class="markdownIt-Anchor" href="#传统c名称空间"></a> 传统C++名称空间</h1><h2 id="声明区域"><a class="markdownIt-Anchor" href="#声明区域"></a> 声明区域</h2><p>声明区域是可以在其中进行声明的区域。例如，全局变量的声明区域为其声明所在的文件；自动变量的声明区域为其声明所在的代码块</p><h2 id="潜在作用域和作用域"><a class="markdownIt-Anchor" href="#潜在作用域和作用域"></a> 潜在作用域和作用域</h2><p>变量的潜在作用域从声明点开始，到其声明区域的结尾<br>潜在作用域比声明区域小，因为变量必须定义后才能使用<br>变量并非在其潜在作用域都是可见的，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。变量对程序可见的范围被称为作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如全局变量a的潜在作用域是第2行<sub>第8行；作用域是第2行</sub>第3行<br>定义同名局部变量后构成同名变量隐藏，但通过::a可以访问</p><h1 id="新的名称空间特性"><a class="markdownIt-Anchor" href="#新的名称空间特性"></a> 新的名称空间特性</h1><p>通过定义一种新的声明区域来创建命名的名称空间<br>可以是全局的，也可以嵌套定义，但不能位于代码块中。默认情况下链接性为外部<br>同一个工程中允许存在多个相同名称的命名空间编译器最后会合成同一个命名空间中</p><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2><ul><li>加命名空间名称及作用域限定符</li><li>使用using将命名空间中成员引入（using声明）</li><li>使用using namespace命名空间名称引入（using编译指令）</li></ul><p>using声明如果发生名称冲突会报错，而using编译指令会构成同名隐藏，局部版本将隐藏名称空间版本<br>using编译指令可传递可以给名称空间创建别名，列如，namespace STD = std可以通过这种技术简化对嵌套名称的使用<br>优先使用::或using声明</p><h2 id="匿名名称空间"><a class="markdownIt-Anchor" href="#匿名名称空间"></a> 匿名名称空间</h2><p>潜在作用域和全局变量相似，其特性提供了链接性为内部的静态变量的替代品<br>例如全局静态变量static int counts;可以这样代替namespace { int counts; }</p><p>使用在已命名的名称空间中声明的变量代替外部全局变量、静态全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在内部会为这个命名空间生成一个唯一的名字，而且还会为这个匿名的命名空间生成一条using指令。所以上面的代码在效果上等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> __UNIQUE_NAME_ &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __UNIQUE_NAME_;</span><br></pre></td></tr></table></figure><h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spaceA.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SpaceA &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TestA();</span><br><span class="line">        ~TestA();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spaceA.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spaceA.h"</span></span></span><br><span class="line"></span><br><span class="line">SpaceA::TestA::TestA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">SpaceA::TestA::~TestA() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SpaceA::TestA::print() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"SpaceA::TestA::print()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spaceB.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前声明一下</span></span><br><span class="line"><span class="keyword">namespace</span> SpaceA &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestA</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SpaceB &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> eci;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TestB();</span><br><span class="line">        ~TestB();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SpaceA::TestA* a; <span class="comment">// 类的定义为内部链接，不能直接定义，除非写出类的完整声明，此处采用指针的方式</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spaceB.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spaceB.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spaceA.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SpaceB::a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">SpaceB::TestB::TestB() &#123;</span><br><span class="line">    a = <span class="keyword">new</span> SpaceA::TestA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpaceB::TestB::~TestB() &#123;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    a = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SpaceB::TestB::printB() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"SpaceB::TestB::printB()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spaceB.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpaceB::TestB b;</span><br><span class="line">    b.printB();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; SpaceB::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; SpaceB::ci &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; SpaceB::eci &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接性"><a class="markdownIt-Anchor" href="#链接性"></a> 链接性</h1><p>描述了名称在不同单元间共享</p><p>外部链接性：可以在文件间共享</p><ul><li>非inline函数、命名空间中非静态函数、类成员函数和类静态成员函数</li><li>类静态成员变量总有外部链接</li><li>命名空间(不包括无名命名空间)中非静态变量</li></ul><p>内部链接性：只能由一个文件中的函数共享，编译后不会产生修饰名字，因此不与链接器打交道</p><ul><li>所有的声明</li><li>命名空间(包括全局命名空间)中的静态自由函数、静态友元函数、静态变量的定义、const常量定义(除非在const限定声明之时或之前已经声明为extern)</li><li>enum定义</li><li>inline函数定义(包括自由函数和非自由函数)</li><li>类(class、struct、union)的定义</li></ul><p>无链接性：不能共享，具有局部作用域，如局部变量、函数形参等</p><p>跨语言链接：有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++中，名称可以是变量、函数、结构、枚举、类、以及类和结构的成员。使用名称空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染&lt;/p&gt;&lt;h1 id=&quot;传统c名称空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#传统c名称空间&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="命名空间" scheme="https://Ranjiahao.github.io/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="链接性" scheme="https://Ranjiahao.github.io/tags/%E9%93%BE%E6%8E%A5%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>预处理器</title>
    <link href="https://ranjiahao.github.io/2019/07/01/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://ranjiahao.github.io/2019/07/01/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>C预处理器不是编译器的组成部分，它是编译过程中一个单独的步骤，本质上是一个文本替换工具，其在源代码编译之前对其进行一些文本性质的操作，它主要任务包括删除注释、头文件展开、定义和替换宏定义的符号以及条件编译的展开</p><p>所有预处理器命令都是#开头，预处理指令不是语句，所以它们不会以分号结尾<br>预处理：选项gcc -E test.c -o test.i预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中<br>常见指令：#define，#include，#undef，#ifdef，#ifndef，#if，#else，#elif，#endif，#error，#pragma</p><h1 id="预定义宏"><a class="markdownIt-Anchor" href="#预定义宏"></a> 预定义宏</h1><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>__DATE__</td><td>文件被编译日期，一个以 “MMM DD YYYY” 格式表示的字符常量</td></tr><tr><td>__TIME__</td><td>文件被编译时间，一个以 “HH:MM:SS” 格式表示的字符常量</td></tr><tr><td>__FILE__</td><td>当前文件名，一个字符串常量</td></tr><tr><td>__LINE__</td><td>当前行号，一个十进制常量</td></tr><tr><td>__STDC__</td><td>当编译器以 ANSI 标准编译时，则定义为 1</td></tr></tbody></table><h1 id="define"><a class="markdownIt-Anchor" href="#define"></a> #define</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100 <span class="comment">// 将所有MAX替换为100，增强可读性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_forever for(;;) <span class="comment">//用更形象的符号来替换一种实现</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE break;case <span class="comment">//在写case语句的时候自动把break写上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_PRINT printf(<span class="meta-string">"file:%s\tline:%d\t \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                        date:%s\ttime:%s\n"</span>,   \</span></span><br><span class="line">                        __FILE__,__LINE__,     \</span><br><span class="line">                        __DATE__,__TIME__) <span class="comment">// 测试预定义宏</span></span><br></pre></td></tr></table></figure><h1 id="参数化的宏"><a class="markdownIt-Anchor" href="#参数化的宏"></a> 参数化的宏</h1><p>格式：<br>#define name(parament-list) stuff其中的parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中<br>注意：参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分</p><p>替换过程：</p><ol><li>对参数进行检查，是否包含任何由#define定义的符号。如果是，它们首先被替换</li><li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换</li><li>最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程</li></ol><p>注意事项：<br>由于宏替换的本质是文本替换所以在定义的时候需要注意符号优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) x * x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) ((x) * (x)) <span class="comment">// 这样写会避免因符号优先级带来的错误</span></span></span><br></pre></td></tr></table></figure><h1 id="与"><a class="markdownIt-Anchor" href="#与"></a> #与##</h1><p>把一个宏的参数转换为字符串常量时，使用字符串常量化运算符#</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(FORMAT, VALUE) \</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the value of "</span> #VALUE <span class="string">" is "</span>FORMAT <span class="string">"\n"</span>, VALUE);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PRINT(<span class="string">"%d"</span>, i+<span class="number">3</span>); <span class="comment">// the value of i+3 is 3</span></span><br></pre></td></tr></table></figure><p>宏定义内的标记粘贴运算符##会合并两个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_TO_SUM(num, value) \</span></span><br><span class="line">    sum#<span class="meta">#num += value;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">ADD_TO_SUM(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 给sum1变量增加3</span></span><br><span class="line">ADD_TO_SUM(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 给sum2变量增加4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于宏定义本质是文本替换，所以以下操作是错误的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    ADD_TO_SUM(i,<span class="number">1</span>); <span class="comment">// 给sumi变量增加1，sumi未定义，所以会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宏和函数"><a class="markdownIt-Anchor" href="#宏和函数"></a> 宏和函数</h1><ol><li>宏的执行速度快，没有函数栈帧开销，但如果定义比较长的宏，代码长度会增加</li><li>宏的参数与类型无关，所以不存在类型检查</li><li>宏的书写比较复杂，需要考虑操作符优先级问题和副作用的参数</li><li>不方便调试，不可递归</li></ol><h1 id="命令行定义"><a class="markdownIt-Anchor" href="#命令行定义"></a> 命令行定义</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,MAX); <span class="comment">// 直接编译会显示MAX未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样编译<code>gcc -DMAX=7 test.c</code>同一份代码，可以根据不同选项在不同环境下执行，同样-Uname将导致程序中符号name的初始定义被忽略</p><h1 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h1><p><strong>函数库文件包含</strong><br>#include &lt;filename&gt;编译器通过观察由编译器定义的一系列标准位置查找函数库头文件，如unix系统上的C编译器在/user/include目录查找函数库头文件<br><strong>本地文件包含</strong><br>#include &quot;filename&quot;标准允许编译器自行决定是否把本地形式的#include和函数库形式的#include区别对待，常见的策略就是在源文件所在的当前目录进行查找，如果未找到，编译器就像查找函数库头文件一样在标准位置查找本地文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C预处理器不是编译器的组成部分，它是编译过程中一个单独的步骤，本质上是一个文本替换工具，其在源代码编译之前对其进行一些文本性质的操作，它主要任务包括删除注释、头文件展开、定义和替换宏定义的符号以及条件编译的展开&lt;/p&gt;&lt;p&gt;所有预处理器命令都是#开头，预处理指令不是语句，所
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="预处理器" scheme="https://Ranjiahao.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>动态内存管理</title>
    <link href="https://ranjiahao.github.io/2019/06/18/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ranjiahao.github.io/2019/06/18/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-06-17T16:00:00.000Z</published>
    <updated>2019-06-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分配内存的函数"><a class="markdownIt-Anchor" href="#分配内存的函数"></a> 分配内存的函数</h1><h2 id="malloc"><a class="markdownIt-Anchor" href="#malloc"></a> malloc</h2><blockquote><p>void* malloc(size_t size);</p></blockquote><p>如果开辟成功，则返回一个指向开辟好空间的指针<br>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查<br>如果参数size为0，malloc的行为是标准是未定义的，取决于编译器</p><h2 id="free"><a class="markdownIt-Anchor" href="#free"></a> free</h2><blockquote><p>void free(void* ptr);</p></blockquote><p>如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的<br>如果参数ptr是NULL指针，则函数什么事都不做</p><h2 id="calloc"><a class="markdownIt-Anchor" href="#calloc"></a> calloc</h2><blockquote><p>void* calloc(size_t num, size_t size);</p></blockquote><p>函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0</p><h2 id="realloc"><a class="markdownIt-Anchor" href="#realloc"></a> realloc</h2><blockquote><p>void* realloc(void* ptr, size_t size);</p></blockquote><p>如果size比原来小，则前size个字节不变，后面的数据被截断，如果size比原来大，则原来的数据全部保留，这里存在两种情况：<br>情况1：原有空间之后有足够大的空间，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化<br>情况2：原有空间之后没有足够大的空间，在堆空间上另找一个合适大小的连续空间来使用，这样函数返回的是一个新的内存地址</p><p>如果参数ptr是空指针，则类似malloc，返回指向开辟好空间的指针<br>如果参数size为0，则类似free，返回空指针</p><h2 id="alloca"><a class="markdownIt-Anchor" href="#alloca"></a> alloca</h2><blockquote><p>void* alloca(size_t size);</p></blockquote><p>参数size是请求分配的字节数，返回所分配内存空间的首地址，如果size太大导致栈空间耗尽，结果是未定义的，alloca函数不是在堆上分配空间，而是在调用者函数的栈帧上分配空间，类似于C99的变长数组，当调用者函数返回时自动释放栈帧，所以不需要free。这个函数不属于C标准库，而是在POSIX标准中定义的</p><h1 id="定义一个不易发生错误的内存分配器"><a class="markdownIt-Anchor" href="#定义一个不易发生错误的内存分配器"></a> 定义一个不易发生错误的内存分配器</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc 不要直接调用malloc!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC(num, type) (type*)alloc(num * sizeof(type))</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"alloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> malloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* new_mem;</span><br><span class="line">    new_mem = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (!new_mem) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Out of memory!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"alloc.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* new_memory;</span><br><span class="line">    new_memory = MALLOC(<span class="number">25</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="柔性数组"><a class="markdownIt-Anchor" href="#柔性数组"></a> 柔性数组</h1><p>C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">0</span>]; <span class="comment">//柔性数组成员，有些编译器会报错无法编译可以改成：int a[];</span></span><br><span class="line">&#125; type_a;</span><br></pre></td></tr></table></figure><h2 id="柔性数组的特点"><a class="markdownIt-Anchor" href="#柔性数组的特点"></a> 柔性数组的特点</h2><p>结构中的柔性数组成员前面必须至少一个其他成员<br>sizeof返回的这种结构大小不包括柔性数组的内存<br>包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小</p><h2 id="柔性数组的优点"><a class="markdownIt-Anchor" href="#柔性数组的优点"></a> 柔性数组的优点</h2><ol><li>方便内存释放，把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉，不用担心结构体内的成员也需要free</li><li>利于访问速度，连续的内存有益于提高访问速度，也有益于减少内存碎片</li></ol><h1 id="newdelete操作符"><a class="markdownIt-Anchor" href="#newdelete操作符"></a> new/delete操作符</h1><p>操作：new data-type;<br>data-type可以是包括数组在内的任意内置类型数据，也可以是自定义的任何数据类型<br>如：<br><code>int* p = new int(3); delete p;</code>在堆上申请空间，创建对象int并初始化为3<br><code>int* p = new int[3]; delete[] p</code>在堆上申请3个int大小空间，创建3个对象<br><strong>new</strong><br>new底层调用先operator new函数申请空间，然后执行构造函数，完成对象的构造<br>operator new底层调用malloc，当malloc申请空间成功时直接返回；申请空间失败尝试执行应对措施，若无应对措施则抛异常</p><p><strong>delete</strong><br>先在空间上执行析构函数，完成对象中资源的清理工作，调用operator delete函数释放对象的空间</p><p><strong>new T[N]</strong><br>先调用operator new[]（在operator new[]中实际调用operator new函数完成N个对象空间的申请）然后在申请的空间上执行N次构造函数</p><p><strong>delete[]</strong><br>先在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理<br>然后调用operator delete[]释放空间（在operator delete[]中调用operator delete来释放空间）</p><h2 id="定位new表达式"><a class="markdownIt-Anchor" href="#定位new表达式"></a> 定位new表达式</h2><p>定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象<br><code>Type* ptr = (Type*)malloc(sizeof(Type)); new(ptr) Type;</code>如果构造函数有参数，需传参</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分配内存的函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分配内存的函数&quot;&gt;&lt;/a&gt; 分配内存的函数&lt;/h1&gt;&lt;h2 id=&quot;malloc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#malloc&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="动态内存" scheme="https://Ranjiahao.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>标准IO库函数</title>
    <link href="https://ranjiahao.github.io/2019/06/16/%E6%A0%87%E5%87%86IO%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>https://ranjiahao.github.io/2019/06/16/%E6%A0%87%E5%87%86IO%E5%BA%93%E5%87%BD%E6%95%B0/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fopenfclose"><a class="markdownIt-Anchor" href="#fopenfclose"></a> fopen/fclose</h1><p>打开文件就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识，以后用户程序就可以用这个标识对文件做各种操作，关闭文件则释放文件在操作系统中占用的资源，使文件的标识失效，用户程序就无法再操作这个文件了</p><blockquote><p>FILE* fopen(const char* filename, const char* mode);</p></blockquote><p>FILE是C标准库中定义的结构体类型，其中包含文件描述符、I/O缓冲区和当前读写位置等信息，调用者不必知道FILE结构体都有哪些成员，文件指针所指的FILE结构体的成员在库函数内部维护，调用者不应该直接访问这些成员，这样的指针称为不透明指针或者叫句柄<br><strong>filename</strong><br>可以是相对路径，也可以是绝对路径<br><strong>mode必选参数</strong><br>r：若文件存在，则以只读方式打开；若不存在，则出错<br>w：若文件存在，则清空原有内容，以只写方式打开；若不存在，则创建新文件，以只写打开<br>a：若文件存在，则以追加写的方式打开；若不存在，则创建新文件，以追加写打开<br><strong>mode可选可选</strong><br>b/t：t表示文本文件，b表示二进制文件，有些操作系统的文本文件和二进制文件格式不同，而在UNIX系统中，无论文本文件还是二进制文件都是由一串字节组成，t和b没有区分，用哪个都一样，也可以省略不写<br>+：以可读可写方式打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个文件时如果出错，fopen将返回NULL并设置errno，程序中应该做出错处理，通常这样写</span></span><br><span class="line"><span class="keyword">if</span> ((fp = fopen(<span class="string">"/tmp/file1"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error open file /tmp/file1!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>int fclose(FILE* stream );</p></blockquote><p>把文件指针传给fclose可以关闭它所标识的文件，关闭之后该文件指针就无效了，不能再使用了。如果fclose调用出错（比如传给它一个无效的文件指针）则返回EOF并设置errno，EOF在stdio.h中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* End of file character.</span></span><br><span class="line"><span class="comment">Some things throughout the library rely on this being -1. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EOF</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EOF (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果不调用fclose，在进程退出时系统会自动关闭文件，但是不能因此就忽略fclose调用</p><h1 id="stdinstdoutstderr"><a class="markdownIt-Anchor" href="#stdinstdoutstderr"></a> stdin/stdout/stderr</h1><p>我们经常用的printf打印到屏幕，scanf读键盘输入，也属于I/O操作，但不是对文件做I/O操作而是对终端设备做I/O操作。终端设备和文件一样也需要先打开后操作，终端设备也有对应的路径名，/dev/tty就表示和当前进程相关联的终端设备，它不表示磁盘上的一组数据，而是表示一个设备。用ls -l命令查看这个文件，显示文件类型、主设备号、次设备号等，主设备号标识内核中的一个设备驱动程序，次设备号标识该设备驱动程序管理的一个设备。内核通过设备号找到相应的驱动程序，完成对该设备的操作。设备文件没有文件尺寸这个属性的，因为设备文件在磁盘上不保存数据，对设备文件做读写操作并不是读写磁盘上的数据，而是在读写设备。UNIX的传统是Everything is a file，键盘、显示器、串口、磁盘等设备在/dev目录下都有一个特殊的设备文件与之对应，这些设备文件也可以像普通文件一样打开、读、写和关闭，使用的函数接口是相同的<br>程序启动时（main函数还没开始执行前）会自动把终端设备打开三次，分别赋给三个FILE*指针stdin、stdout和stderr，这三个文件指针是libc中定义的全局变量，在stdio.h中声明，这三个文件指针的打开方式都是可读可写的，但通常stdin只用于读操作，称为标准输入，stdout只用于写操作，称为标准输出，stderr也只用于写操作，称为标准错误输出，通常程序的运行结果打印到标准输出，而错误提示打印到标准错误输出，所以fopen的错误处理写成这样更符合惯例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fp = fopen(<span class="string">"/tmp/file1"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"Error open file /tmp/file1\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="errno与perror函数"><a class="markdownIt-Anchor" href="#errno与perror函数"></a> errno与perror函数</h1><p>很多系统函数在错误返回时将错误原因记录在libc定义的全局变量errno中，每种错误原因对应一个错误码，errno在头文件errno.h中声明，是一个整型变量，所有错误码都是正整数<br>如果在程序中打印错误信息时直接打印errno变量，打印出来的只是一个整数值，仍然看不出是什么错误，可以用perror或strerror函数将errno解释成字符串再打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">"abcde"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">"Open file abcde"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些函数的错误码并不保存在errno中，而是通过返回值返回，就不能调用perror打印错误原因了，这时就要使用strerror：</p><blockquote><p>fputs(strerror(n), stderr);</p></blockquote><h1 id="以字节为单位的io函数"><a class="markdownIt-Anchor" href="#以字节为单位的io函数"></a> 以字节为单位的I/O函数</h1><blockquote><p>int fgetc(FILE* stream);</p></blockquote><ul><li>文件的打开方式必须是可读</li><li>系统对于每个打开的文件都记录着当前读写位置在文件中的地址。当文件打开时，读写位置是0，每调用一次fgetc，读写位置向后移动一个字节，因此可以连续多次调用fgetc函数依次读取多个字节</li><li>fgetc成功时返回读到一个字节，本来应该是unsigned char型的，但由于函数原型中返回值是int型，所以这个字节要转换成int型再返回，因为出错或读到文件末尾时fgetc将返回EOF，即-1，保存在int型的返回值中是0xffffffff，如果读到字节0xff，由unsigned char型转换为int型是0x000000ff，只有规定返回值是int型才能把这两种情况区分开，如果规定返回值是unsigned char型，那么当返回值是0xff时无法区分到底是EOF还是字节0xff</li></ul><blockquote><p>int fputc(int character, FILE* stream);</p></blockquote><ul><li>文件的打开方式必须是可写的（包括追加）</li><li>每调用一次fputc，读写位置向后移动一个字节，因此可以连续多次调用fputc函数依次写入多个字节。但如果文件是以追加方式打开的，每次调用fputc时总是将读写位置移到文件末尾然后把要写入的字节追加到后面</li></ul><p>从终端设备输入时有两种方法表示文件结束，一种方法是在一行的开头输入Ctrl-D（如果不在一行的开头则需要连续输入两次Ctrl-D），另一种方法是利用Shell的Heredoc语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;a.out &lt;&lt;END</span><br><span class="line">&gt; hello</span><br><span class="line">&gt; hey</span><br><span class="line">&gt; END</span><br></pre></td></tr></table></figure><p>&lt;&lt;END表示从下一行开始是标准输入，直到某一行开头出现END时结束。&lt;&lt;后面的结束符可以任意指定，不一定得是END，只要和输入的内容能区分开就行</p><h1 id="操作读写位置的函数"><a class="markdownIt-Anchor" href="#操作读写位置的函数"></a> 操作读写位置的函数</h1><blockquote><p>int fseek(FILE* stream, long int offset, int origin);<br>long ftell(FILE* stream);<br>void rewind(FILE* stream);</p></blockquote><p>fseek可以任意移动读写位置，origin参数含义：<br>SEEK_SET从文件开头移动offset个字节<br>SEEK_CUR从当前位置移动offset个字节<br>SEEK_END从文件末尾移动offset个字节<br>offset可正可负，负值表示向前（向文件开头的方向）移动，正值表示向后（向文件末尾的方向）移动，如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸，从原来的文件末尾到fseek移动之后的读写位置之间的字节都是0，成功返回0，出错返回-1并设置errno<br>ftell可以返回当前的读写位置，成功返回当前读写位置，出错返回-1并设置errno<br>rewind函数把读写位置移到文件开</p><h1 id="以字符串为单位的io函数"><a class="markdownIt-Anchor" href="#以字符串为单位的io函数"></a> 以字符串为单位的I/O函数</h1><blockquote><p>char* fgets(char* str, int num, FILE* stream);</p></blockquote><p>fgets从指定的文件中读一行字符到调用者提供的缓冲区中<br>参数str是缓冲区的首地址，num是缓冲区的长度，该函数从stream所指的文件中读取以’\n’结尾的一行（包括’\n’在内）存到缓冲区str中，并且在该行末尾添加一个’\0’组成完整的字符串，成功时str指向哪返回的指针就指向哪，出错或者读到文件末尾时返回NULL<br>如果文件中的一行太长，fgets从文件中读了num-1个字符还没有读到’\n’，就把已经读到的num-1个字符和一个’\0’字符存入缓冲区，文件中剩下的半行可以在下次调用fgets时继续读<br>如果一次fgets调用在读入若干个字符后到达文件末尾，则将已读到的字符串加上’\0’存入缓冲区并返回，如果再次调用fgets则返回NULL，可以据此判断是否读到文件末尾<br>fgets只适合读文本文件而不适合读二进制文件，因为文本文件中的所有字符都应该是可见字符，没有’\0’，二进制文件可能有’\0’（0x00字节）调用fgets之后就无法判断缓冲区中的’\0’究竟是从文件读上来的字符还是由fgets自动添加的结束符</p><blockquote><p>int fputs(const char* str, FILE* stream);</p></blockquote><p>fputs向指定的文件写入一个字符串，缓冲区str中保存的是以’\0’结尾的字符串，fputs将该字符串写入文件stream，但并不写入结尾的’\0’，成功返回一个非负整数，出错返回EOF</p><h1 id="以记录为单位的io函数"><a class="markdownIt-Anchor" href="#以记录为单位的io函数"></a> 以记录为单位的I/O函数</h1><blockquote><p>size_t fread(void* ptr, size_t size, size_t count, FILE* stream);<br>size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream);</p></blockquote><p>fread和fwrite用于读写记录，这里的记录是指一串固定长度的字节，比如一个int、一个结构体或者一个定长数组。参数size指出一条记录的长度，而count指出要读或写多少条记录，这些记录在ptr所指的内存空间中连续存放，共占size*count个字节，fread从文件stream中读出size*count个字节保存到ptr中，而fwrite把ptr中的size*count个字节写到文件stream中</p><p>count是请求读或写的记录数，fread和fwrite返回的记录数有可能小于count指定的记录数。例如当前读写位置距文件末尾只有一条记录的长度，调用fread时指定count为2，则返回值为1。如果当前读写位置已经在文件末尾了，或者读文件时出错了，则fread返回0。如果写文件时出错了，则fwrite的返回值小于count指定的值</p><h1 id="格式化io函数"><a class="markdownIt-Anchor" href="#格式化io函数"></a> 格式化I/O函数</h1><blockquote><p>int fprintf(FILE* stream, const char* format, …);<br>int sprintf(char* str, const char* format, …);<br>int snprintf(char* s, size_t n, const char* format, …);<br>int vprintf(const char* format, va_list arg);<br>int vfprintf(FILE* stream, const char* format, va_list arg);<br>int vsprintf(char* s, const char* format, va_list arg);<br>int vsnprintf(char* s, size_t n, const char* format, va_list arg);</p></blockquote><p>fprintf打印到指定的文件stream中，sprintf并不打印到文件，而是打印到用户提供的缓冲区str中并在末尾加’\0’，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，用snprintf更好 截断到n-1字节，再加上一个’\0’写入缓冲区，也就是说snprintf保证字符串以’\0’结尾。snprintf的返回值是格式化后的字符串长度（不包括结尾的’\0’），如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断<br>后四个函数在前四个函数名的前面多了个v，表示可变参数不是以…的形式传进来，而是以va_list类型传进来</p><p><strong>实现格式化打印错误的err_sys函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_sys</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = errno;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    vsnprintf(buf, MAXLINE, fmt, ap);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf+<span class="built_in">strlen</span>(buf), MAXLINE-<span class="built_in">strlen</span>(buf), <span class="string">":%s"</span>, strerror(err));</span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Usage: ./a.out pathname\n"</span>,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">"Line %d - Open file %s"</span>, __LINE__, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Open %s OK\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printf并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数，所以如果实际参数和转换说明的类型不符，结果可能会有些意外。另外，如果s指向一个字符串，用printf(s)打印这个字符串可能得到错误的结果，因为字符串中可能包含%号而被printf当成转换说明，printf并不知道后面没有传其它参数，照样会从栈帧上取参数。所以比较保险的办法是printf(&quot;%s&quot;, s)</p><blockquote><p>int fscanf(FILE* stream, const char* format, …);<br>int sscanf(const char* s, const char* format, …);<br>int vscanf(const char* format, va_list arg);<br>int vsscanf(const char* s, const char* format, va_list arg);<br>int vfscanf(FILE* stream, const char* format, va_list arg);</p></blockquote><p>fscanf从指定的文件stream中读字符，而sscanf从指定的字符串s中读字符。后面三个以v开头的函数的可变参数不是以…的形式传进来，而是以va_list类型传进来</p><p>scanf用输入的字符去匹配格式化字符串中的字符和转换说明，如果成功匹配一个转换说明，就给一个参数赋值，如果读到文件或字符串末尾就停止，或者如果遇到和格式化字符串不匹配的地方（比如转换说明是%d却读到字符A）就停止。如果遇到不匹配的地方而停止，scanf的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续</p><h1 id="文件结束判定"><a class="markdownIt-Anchor" href="#文件结束判定"></a> 文件结束判定</h1><blockquote><p>int feof(FILE* stream);</p></blockquote><p>在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束，而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束</p><ol><li>文本文件读取是否结束，判断返回值是否为EOF （fgetc），或者NULL（fgets）</li><li>二进制文件的读取结束判断，判断返回值是否小于实际要读的个数</li></ol><p>因为feof()函数，并不是通过读取到文件的EOF来评判，这个文件是否为空<br>它的工作原理是，如果光标所在位置后面有字符，返回0；如果没有，返回非0。它并不会读取相关信息，只是查看光标后是否还有内容。</p><p>对于一个空文件来说，当程序打开它的时候，光标会停在文件的开头，但是由于文件里什么内容都没有存（EOF却是存在的）即整个文件就存贮了一个EOF。当程序打开文件，并直接调用feof()时，光标的位置后有EOF字符，然后就返回0了</p><blockquote><p>int ferror ( FILE* stream );</p></blockquote><p>如果出错则返回非零，否则返回0</p><h1 id="c标准库的io缓冲区"><a class="markdownIt-Anchor" href="#c标准库的io缓冲区"></a> C标准库的I/O缓冲区</h1><p><img src="img1.png" alt="img1"></p><ul><li>全缓冲：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的</li><li>行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的</li><li>无缓冲用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备</li></ul><p>除了写满缓冲区、写入换行符之外，行缓冲还有一种情况会自动做Flush操作。如果：</p><ol><li>用户程序调用库函数从无缓冲的文件中读取</li><li>或者从行缓冲的文件中读取，并且这次读操作会引发系统调用从内核读取数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a line: "</span>);</span><br><span class="line">    fgets(buf, <span class="number">20</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用printf并不会把字符串写到设备，但紧接着调用fgets读一个行缓冲的文件（标准输入），在读取之前会自动Flush所有行缓冲，包括标准输出<br><strong>手动刷新缓冲区</strong></p><blockquote><p>int fflush(FILE* stream);</p></blockquote><p>成功返回0，出错返回EOF并设置errno，fflush(NULL)可以对所有打开文件的I/O缓冲区做Flush操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fopenfclose&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fopenfclose&quot;&gt;&lt;/a&gt; fopen/fclose&lt;/h1&gt;&lt;p&gt;打开文件就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识，以后用户
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="标准IO库函数" scheme="https://Ranjiahao.github.io/tags/%E6%A0%87%E5%87%86IO%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>自定义类型总结</title>
    <link href="https://ranjiahao.github.io/2019/06/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://ranjiahao.github.io/2019/06/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</id>
    <published>2019-06-12T16:00:00.000Z</published>
    <updated>2019-06-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构的存储分配"><a class="markdownIt-Anchor" href="#结构的存储分配"></a> 结构的存储分配</h1><h2 id="内存对齐的意义"><a class="markdownIt-Anchor" href="#内存对齐的意义"></a> 内存对齐的意义</h2><ol><li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li><li>性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</li><li>结构体的内存对齐是拿空间来换取时间的做法</li></ol><h2 id="内存对齐规则"><a class="markdownIt-Anchor" href="#内存对齐规则"></a> 内存对齐规则</h2><ol><li>第一个成员在与结构体变量偏移量为0的地址处</li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员大小的较小值。VS中默认的值为8，Linux中的默认值为4</li><li>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍</li><li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</li></ol><h2 id="修改默认对齐数"><a class="markdownIt-Anchor" href="#修改默认对齐数"></a> 修改默认对齐数</h2><blockquote><p>#pragma pack(8) //设置默认对齐数为8<br>#pragma pack() //取消设置的默认对齐数，还原为默认对齐数</p></blockquote><h2 id="计算偏移量"><a class="markdownIt-Anchor" href="#计算偏移量"></a> 计算偏移量</h2><p>有两种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure><ol><li><code>printf(&quot;%d\n&quot;, ((char*)&amp;s.b - (char*)&amp;s));</code></li><li>利用宏定义实现<br><code>#define FIND(type, var) ((size_t)&amp;(((type*)0)-&gt;var))</code><br>这样不需要实例化对象也可以，C标准库也有自带的，offsetof宏(stddef.h)<br><code>offsetof(type, member) 返回值为指定成员开始存储的位置距离结构开始存储的位置偏移几个字节</code></li></ol><h1 id="位段"><a class="markdownIt-Anchor" href="#位段"></a> 位段</h1><ol><li>位段的成员可以是int，signed int，unsigned int或者是char（属于整形家族）类型</li><li>位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li></ol><h2 id="位段的跨平台问题"><a class="markdownIt-Anchor" href="#位段的跨平台问题"></a> 位段的跨平台问题</h2><ol><li>int位段被当成有符号数还是无符号数是不确定的</li><li>位段中最大位的数目不能确定（16位机器最大16，32位机器最大32）</li><li>位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的</li></ol><p>跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在</p><h1 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h1><p>枚举的优点：</p><ol><li>增加代码的可读性和可维护性</li><li>和#define定义的标识符比较枚举有类型检查，更加严谨</li><li>防止了命名污染（封装）</li><li>便于调试</li><li>使用方便，一次可以定义多个常量</li><li>#define宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> Color clr = GREEN; <span class="comment">// 只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。</span></span><br><span class="line">clr = <span class="number">1</span>; <span class="comment">// 在C语言中可以这样赋值，因为C语言中枚举和整型是一种类型，而C++中枚举是一个单独的类型所以会报错</span></span><br></pre></td></tr></table></figure><h1 id="联合"><a class="markdownIt-Anchor" href="#联合"></a> 联合</h1><p>在union中所有的数据成员共用一个空间，所有的数据成员具有相同的起始地址</p><p>在C++中，union成员默认属性页为public。union主要用来压缩空间。如果一些数据<br>不可能在同一时间同时被用到，则可以使用union</p><p>联合的大小至少是最大成员的大小。当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</p><h2 id="联合的初始化"><a class="markdownIt-Anchor" href="#联合的初始化"></a> 联合的初始化</h2><p>联合变量可以被初始化，但这个初始值必须是联合第1个成员的类型，而且它必须位于一对花括号里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line">&#125; x = &#123; <span class="number">5</span> &#125;; <span class="comment">// 不能把这个类量初始化为一个浮点值或字符值，如果给出的初始值是任何其他类型，它就会转换为一个整数并赋值给x.a</span></span><br></pre></td></tr></table></figure><h1 id="一个有趣的问题"><a class="markdownIt-Anchor" href="#一个有趣的问题"></a> 一个有趣的问题</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">str</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">7</span>];</span><br><span class="line">&#125; str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    str* f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;s) &#123; <span class="comment">// 这里会出错吗？</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(f-&gt;s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样完全没有问题，并且输出结果为7<br>用空指针访问成员变量为什么不会出错？<br>我们可以测试下这个代码<br><code>printf(&quot;%d\n&quot;, f-&gt;s); // 输出为4</code><br>其实，所谓变量，其实是内存地址的一个抽像名字罢了。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址<br>所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中<br><strong>不管结构体的实例是什么------访问其成员其实就是加成员的偏移量</strong><br>由于f为NULL，所以f-&gt;s就是给NULL加上偏移量4，并没有发生读取内存操作，但是如果这样：<br><code>printf(&quot;%d\n&quot;, f-&gt;s[1]); // 读取非法内存，会崩掉</code><br><code>printf(&quot;%d&quot;, f-&gt;len); // 读取非法内存，会崩掉</code><br><code>printf(&quot;%d&quot;, &amp;(f-&gt;len)); // 没有读取内存，不会崩掉</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构的存储分配&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#结构的存储分配&quot;&gt;&lt;/a&gt; 结构的存储分配&lt;/h1&gt;&lt;h2 id=&quot;内存对齐的意义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存对齐的意义&quot;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="自定义类型" scheme="https://Ranjiahao.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
