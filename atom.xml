<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ranjiahao.github.io/"/>
  <updated>2020-10-06T16:00:00.000Z</updated>
  <id>https://ranjiahao.github.io/</id>
  
  <author>
    <name>Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SGI-STL空间配置器模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/10/07/SGI-STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/10/07/SGI-STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-10-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>STL为了各个容器高效的管理空间，设计一块高效的内存管理机制，避免了频繁向系统申请小块内存块造成内存碎片、影响程序运行效率，和直接使用malloc和new申请额外空间浪费、申请空间失败的问题，还考虑了线程安全问题。虽然内核中已经有了一个类似的slab分配器来管理小块内存但是内核是针对操作系统中所有程序的，他申请和释放内存的消耗会非常大，STL需要的全部都是小块内存，并且需求比较集中，如果自己设计一个效率更高，还能顺带解决内存碎片的问题</p><p>SGI-STL的空间配置器分为分为两级结构，一级空间配置器处理大块内存（大于128字节），二级空间配置器处理小块内存</p><p>一级空间配置器对malloc和free进行了封装，同时加上了对内存不足的处理方法每当通过malloc或者realloc申请空间时，如果出现了内存不足的情况，就会循环调用oom来进行处理，然后继续判断是否申请成功，失败则继续尝试。若用户不自己设定oom则内存不足时抛出bad_alloc异常</p><p>二级空间配置器专门负责处理小于128字节的小块内存。采用了内存池的技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式来提高用户获取空间的速度与高效管理，避免外碎片问题（但还是存在内碎片问题）<br>首先申请一大块内存，并且用类似哈希桶的结构来维护这个内存池，每一个桶中装载一个free-list单链表。总共维护16个free-lists，各自管理大小以8字节为倍数，依次是8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128字节，SGI-STL将用户申请的内存块向上对齐到了8的整数倍<br>当用户申请的空间小于128字节则在桶中寻找可利用的内存</p><ol><li>如果有则取出分给用户</li><li>如果没有则需要调用refill向内存池申请空间，refill中调用chunk_alloc一次申请对应字节的20块内存<br>2.1 若内存池内存足够，则将一个分配给用户，其余内存挂到哈希桶中<br>2.2 若内存池中内存小于20块大于1块，则同样将一个分配给用户，其余内存挂到哈希桶中<br>2.3 若内存不足1块，则把内存池中剩余的空间挂到对应哈希桶中，然后调用malloc向系统申请<br>2.3.1 若申请成功则放入内存池，重复调用chunk_alloc<br>2.3.2 若申请失败则从哈希桶中找更大的内存块<br>2.3.2.1 如果有则从哈希桶中取出给用户<br>2.3.2.2 如果没有则调用一级空间配置器，成功则放入内存重复调用chunk_alloc，失败抛异常</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MALLOC</span></span><br><span class="line"><span class="comment">// 使用一级空间配置器</span></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc_template malloc_alloc;</span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 使用二级空间配置器，默认使用二级空间配置器</span></span><br><span class="line"><span class="keyword">typedef</span> default_alloc_tmplate alloc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// USE_MALLOC</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//               一级空间配置器               //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span><span class="params">(*malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对malloc的封装</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 申请空间成功，直接返回，失败交由oom_malloc处理</span></span><br><span class="line">        <span class="keyword">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            result = oom_malloc(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对free的封装</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可直接使用new-handler机制，因为它并非使用::operator new来配置内存</span></span><br><span class="line">    <span class="comment">// new-handler机制是一旦::operator new无法完成任务，再丢出std::bad_alloc之前会调用用户指定的函数</span></span><br><span class="line">    <span class="comment">// 模拟set_new_handle()</span></span><br><span class="line">    <span class="comment">// 该函数的参数为函数指针，返回值类型也为函数指针</span></span><br><span class="line">    <span class="comment">//                  函数名            参数</span></span><br><span class="line">    <span class="comment">// void (*    set_malloc_handler( void (*f)() )    )()</span></span><br><span class="line">    <span class="comment">// 返回值类型void(*)()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span><span class="params">(*set_malloc_handler(<span class="keyword">void</span>(*f)()))</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>(*old)() = malloc_alloc_oom_handler;</span><br><span class="line">        malloc_alloc_oom_handler = f;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认用户处理函数为nullptr</span></span><br><span class="line"><span class="keyword">void</span>(*malloc_alloc_template::malloc_alloc_oom_handler)() = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc申请空间失败时代用该函数</span></span><br><span class="line"><span class="keyword">void</span>* malloc_alloc_template::oom_malloc(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">void</span>(*my_malloc_handler)() = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        my_malloc_handler = malloc_alloc_oom_handler;</span><br><span class="line">        <span class="comment">// 检测用户是否设置空间不足应对措施，如果没有设置，则抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (my_malloc_handler == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果设置，执行用户提供的空间不足应对措施</span></span><br><span class="line">        (*my_malloc_handler)();</span><br><span class="line">        <span class="comment">// 继续申请空间，可能就会申请成功，若失败则继续尝试</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//               二级空间配置器               //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123; ALIGN = <span class="number">8</span> &#125;;                      <span class="comment">// 小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123; MAX_BYTES = <span class="number">128</span> &#125;;                <span class="comment">// 小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123; NFREELISTS = MAX_BYTES / ALIGN &#125;; <span class="comment">// 哈希桶freelist个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时不考虑多线程情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">default_alloc_tmplate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果用户所需内存块不是8的整数倍，则向上对齐到8的整数倍</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes + ALIGN - <span class="number">1</span>) &amp; ~(ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用联合体的方式管理内存碎片，分配与回收小内存区块</span></span><br><span class="line">    <span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* free_list_link; <span class="comment">// 指向下一个区块</span></span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];       <span class="comment">// 储存本块内存的首地址</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 16个freelist</span></span><br><span class="line">    <span class="keyword">static</span> obj* free_list[NFREELISTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数，根据用户提供字节数找到对应的桶号</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes + ALIGN - <span class="number">1</span>) / ALIGN - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向内存池申请，往哈希桶中补充空间，返回首个小块内存的首地址</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置nobjs个大小为size的区块，nobjs可能减少</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* start_free; <span class="comment">// 内存池起始位置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* end_free;   <span class="comment">// 内存池结束位置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size; <span class="comment">// 记录该空间配置器已经向系统索要了多少的内存块</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* default_alloc_tmplate::start_free = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span>* default_alloc_tmplate::end_free = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">size_t</span> default_alloc_tmplate::heap_size = <span class="number">0</span>;</span><br><span class="line">default_alloc_tmplate::obj* default_alloc_tmplate::free_list[NFREELISTS] = &#123;</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设n已经调至8的倍数</span></span><br><span class="line"><span class="keyword">void</span>* default_alloc_tmplate::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 一次性向内存池索要20个n字节的小块内存</span></span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    <span class="comment">// 如果只要了一块，直接返回给用户使用</span></span><br><span class="line">    <span class="keyword">if</span> (nobjs == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将第一块返回给用户，其他块连接在对应的桶中</span></span><br><span class="line">    obj* result = (obj*)chunk;</span><br><span class="line">    <span class="comment">// 找到对应的桶号</span></span><br><span class="line">    obj** my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">// 从1开始，因为第0个将返回给用户</span></span><br><span class="line">    obj* next_obj = *my_free_list = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nobjs ; i++) &#123;</span><br><span class="line">        obj* current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (i == nobjs - <span class="number">1</span>) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设size已经调至8的倍数</span></span><br><span class="line"><span class="keyword">char</span>* default_alloc_tmplate::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="comment">// 计算nobjs个size字节内存块的总大小以及内存池中剩余空间总大小</span></span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free; <span class="comment">// 内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="comment">// 内存池剩余空间完全满足需求量</span></span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 内存池不能完全满足需求量，但是可以供应一个区块</span></span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内存池剩余空间连一个区块的大小都无法提供，向系统堆求助，往内存池中补充空间</span></span><br><span class="line">        <span class="comment">// 向内存池中补充空间大小：本次空间总大小两倍+向系统申请总大小/16</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 如果内存池有剩余空间，该空间一定是8的整数倍，将该空间挂到对应哈希桶中</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找对用哈希桶，将剩余空间挂在其上</span></span><br><span class="line">            obj** my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过系统堆向内存池补充空间，如果补充成功，递归继续分配</span></span><br><span class="line">        start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (start_free == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过系统堆补充空间失败，在哈希桶中找是否有没有使用的较大的内存块</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt;= MAX_BYTES; i += ALIGN) &#123;</span><br><span class="line">                obj** my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                obj* p = *my_free_list;</span><br><span class="line">                <span class="comment">// 如果有，将该内存块补充进内存池，递归继续分配</span></span><br><span class="line">                <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                    *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*)p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end_free = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 调用一级空间配置器</span></span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc_template::allocate(bytes_to_get);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过系统堆向内存池补充空间成功，更新信息并继续分配</span></span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(size, nobjs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* default_alloc_tmplate::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 大于128字节则调用一级空间配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>)MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_alloc_template::allocate(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户所需字节找到对应的桶号</span></span><br><span class="line">    obj** my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    obj* result = *my_free_list;</span><br><span class="line">    <span class="comment">// 如果该桶中没有内存块时，向该桶中补充空间</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将n向上对齐到8的整数被，保证向桶中补充内存块时，内存块一定是8的整数倍</span></span><br><span class="line">        <span class="keyword">void</span>* r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护桶中剩余内存块的链式关系</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> default_alloc_tmplate::deallocate(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 大于128字节则调用一级空间配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>)MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc_template::deallocate(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到对应的哈希桶，将内存挂在哈希桶中</span></span><br><span class="line">    obj** my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    obj* q = (obj*)p;</span><br><span class="line">    q-&gt;free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对空间配置器进行封装</span></span><br><span class="line"><span class="comment">// 只负责申请与归还对象的空间，不负责空间中对象的构造与析构</span></span><br><span class="line"><span class="comment">// T: 元素类型    Alloc: 空间配置器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 申请n个T类型对象大小的空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n ? (T*)Alloc::allocate(n * <span class="keyword">sizeof</span>(T)) : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个T类型对象大小的空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)Alloc::allocate(<span class="keyword">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放n个T类型对象大小的空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n) &#123;</span><br><span class="line">            Alloc::deallocate(p, n * <span class="keyword">sizeof</span>(T));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一个T类型对象大小的空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">        Alloc::deallocate(p, <span class="keyword">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归还空间时，先先调用该函数将对象中资源清理掉</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">pointer</span>) &#123;</span></span><br><span class="line">    pointer-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间申请好后调用该函数：利用placement-new完成对象的构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">construct</span>(<span class="title">T1</span>* <span class="title">p</span>, <span class="title">const</span> <span class="title">T2</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">new</span>(p) T1(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 与容器结合</span></span><br><span class="line"><span class="comment">//template &lt;class T, class Alloc = alloc&gt;</span></span><br><span class="line"><span class="comment">//class list &#123;</span></span><br><span class="line"><span class="comment">//    // 实例化空间配置器</span></span><br><span class="line"><span class="comment">//    typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span></span><br><span class="line"><span class="comment">//protected:</span></span><br><span class="line"><span class="comment">//    link_type get_node() &#123;</span></span><br><span class="line"><span class="comment">//        // 调用空间配置器接口先申请节点的空间</span></span><br><span class="line"><span class="comment">//        return list_node_allocator::allocate();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // 将节点归还给空间配置器</span></span><br><span class="line"><span class="comment">//    void put_node(link_type p) &#123;</span></span><br><span class="line"><span class="comment">//        list_node_allocator::deallocate(p);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // 创建节点：1. 申请空间 2. 完成节点构造</span></span><br><span class="line"><span class="comment">//    link_type create_node(const T&amp; x) &#123;</span></span><br><span class="line"><span class="comment">//        link_type p = get_node();</span></span><br><span class="line"><span class="comment">//        construct(&amp;p-&gt;data, x);</span></span><br><span class="line"><span class="comment">//        return p;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // 销毁节点：1. 调用析构函数清理节点中资源 2. 将节点空间归还给空间配置器</span></span><br><span class="line"><span class="comment">//    void destroy_node(link_type p) &#123;</span></span><br><span class="line"><span class="comment">//        destroy(&amp;p-&gt;data);</span></span><br><span class="line"><span class="comment">//        put_node(p);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;STL为了各个容器高效的管理空间，设计一块高效的内存管理机制，避免了频繁向系统申请小块内存块造成内存碎片、影响程序运行效率，和直接使用malloc和new申请额外空间浪费、申请空间失败的问题，还考虑了线程安全问题。虽然内核中已经有了一个类似的slab分配器来管理小块内存但是
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="STL" scheme="https://Ranjiahao.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务的实现</title>
    <link href="https://ranjiahao.github.io/2020/08/30/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/08/30/mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-08-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>事务就是是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，若做了一部分但是只要有一步失败，就要回滚所有操作，InnoDB支持事务，MyISAM不支持事务<br>当有多个客户端同时操作数据库的某张表，或客户端开启各自事务操作数据库中的数据时，MySQL提供了一种机制，可以让不同的事务在操作数据时，具有隔离性。从而保证数据的一致性<br>如果没有隔离性就会产生脏读、不可重复读、幻读的问题<br>脏读：当一个事务正在访问数据，并对数据进行修改还没有提交，这时另外一个事务也访问这个数据，然后使用了这个数据<br>不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另一个事务也访问同一数据并修改提交，那么第一个事务两次读到的的数据可能是不一样的。<br>幻读：一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样<br>（不可重复读的重点是修改：同样的条件，读取过的数据，再次读取出来发现值不一样了；幻读的重点在于新增或者删除：同样的条件，第1次和第2次读出来的记录数不一样<br>丢失更新：一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致<br>为了解决这些数据不一致的问题：mysql实现了四种隔离级别<br><img src="img1.png" alt="img1"><br>可重复读是InnoDB默认的隔离级别，在SQL标准中，是无法避免幻读问题的，但是InnoDB避免了幻读问题</p><h1 id="事务的acid特征"><a class="markdownIt-Anchor" href="#事务的acid特征"></a> 事务的ACID特征</h1><p>原子性(Atomicity)：事务是应用中最小的执行单位，事务是应用中不可再分的最小逻辑执行体<br>一致性(Consistency)：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不一致的状态。因此一致性是通过原子性来保证的<br>隔离性(Isolation)：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发事务都是隔离的。并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能互相影响<br>持久性(Durability)：持久性是指一个事务一旦被提交，它对数据库所做的改变都要记录到永久存储</p><h1 id="事务的实现原理"><a class="markdownIt-Anchor" href="#事务的实现原理"></a> 事务的实现原理</h1><h2 id="实现原子性-undo-log"><a class="markdownIt-Anchor" href="#实现原子性-undo-log"></a> 实现原子性 undo log</h2><p>innoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子<br>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去</p><h2 id="实现持久性-redo-log"><a class="markdownIt-Anchor" href="#实现持久性-redo-log"></a> 实现持久性 redo log</h2><p>数据库中的数据是存放在磁盘中的，如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了cache，cache中包含了磁盘中部分数据页的映射，当从数据库读取数据时，会首先从cache中读取，如果缓存未命中，则从磁盘读取后放入cache；当向数据库写入数据时，会首先写入cache，cache中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）<br>虽然这样效率高，但是也产生了行的问题，如果MySQL宕机，而此时cache中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证<br>inoDB使用redo log来解决这个问题：当数据修改时，除了修改cache中的数据，还会在redo log记录这次操作（redo log文件的文件描述符用fctrl设置为O_DIRECT 表示不经过缓存直接写入磁盘中）当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（预写式日志）所有修改先写入日志，再更新到cache，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求<br>redo log也需要在事务提交时将日志写入磁盘，它比直接将cache中修改的数据写入磁盘(即刷脏)要快，主要有以下两方面的原因：<br>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO<br>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</p><h2 id="实现隔离性"><a class="markdownIt-Anchor" href="#实现隔离性"></a> 实现隔离性</h2><h3 id="锁机制"><a class="markdownIt-Anchor" href="#锁机制"></a> 锁机制</h3><p>一个事务写操作对另一个事务写操作的影响：锁机制保证隔离性<br>事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁</p><h3 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h3><p>一个事务写操作对另一个事务读操作的影响：MVCC保证隔离性<br>repeatable read解决脏读、不可重复读、幻读等问题，使用的是多版本的并发控制协议MVCC，<br>MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好<br>InnoDB实现MVCC原理：<br>InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id（申请顺序严格递增）、指向undo log的指针等，而每条undo log也会指向更早版本的undo log，从而形成一条版本链，通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；如果我们读取的行正在执行DELETE或者UPDATE操作，这时就不会去等待锁释放后再读取，而是直接去读取行的一个快照数据ReadView，它由所有未提交事务id数组，和已创建的最大事务id组成，查询的数据结果需要跟ReadView做比对从而得到快照结果，版本链比对规则：</p><ul><li>如果数据行中事务id&lt;数组里面最小的id，则表示这条数据的版本是已提交的事务生成的，这个数据是可见的</li><li>如果数据行中事务id&gt;已创建的最大事务id，则表示这个版本是由将来启动的事务生成的，这个数据是不可见的</li><li>数组里面最小的id&lt;=如果数据行中事务id&lt;=已经创建的最大事务id，则分两种情况，若数据行中的事务id在数组中，则表示这个版本是由还没有提交的事务生成的，不可见（如果是自己当前的事务id则可见）；若不在数组中，则表示这个版本是已经提交了的事务生成的，可见</li></ul><p>MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。由于READ UNCOMMITTED总会读取在最新的数据，而SERIALIZABLE会对所有读取的行加锁，所以这两种都不兼容MVCC</p><h2 id="实现一致性"><a class="markdownIt-Anchor" href="#实现一致性"></a> 实现一致性</h2><p>一致性是事务追求的最终目标，保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证，数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等，应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</p><h1 id="数据库锁"><a class="markdownIt-Anchor" href="#数据库锁"></a> 数据库锁</h1><p>数据库锁一般可以分为两类，一个是悲观锁，一个是乐观锁</p><p>乐观锁一般是指用户自己实现的一种锁机制，假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。乐观锁的实现方式一般使用版本号和时间戳</p><p>悲观锁一般就是我们通常说的数据库锁机制，悲观锁主要分表锁、行锁、页锁。在MyISAM中只用到表锁，不会有死锁的问题，锁的开销也很小，但是相应的并发能力很差。innodb实现了行级锁和表锁，锁的粒度变小了，并发能力变强，但是相应的锁的开销变大，很有可能出现死锁。</p><p>表锁和行锁都分为共享锁和排他锁，而更新锁是为了解决行锁升级（共享锁升级为独占锁）的死锁问题<br>共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁<br>排他锁：又叫写锁，一旦加了写锁之后，其他事务就不能加锁了<br>innodb中表锁和行锁一起用，所以为了提高效率才会有意向锁（意向共享锁和意向排他锁）</p><h2 id="锁算法"><a class="markdownIt-Anchor" href="#锁算法"></a> 锁算法</h2><h3 id="记录锁"><a class="markdownIt-Anchor" href="#记录锁"></a> 记录锁</h3><p>记录锁是锁住记录的，锁住的是索引记录，而不是我们真正的数据记录：<br>如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住<br>如果表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁<br>如果要锁的没有索引，则会进行全表记录加锁</p><h3 id="间隙锁"><a class="markdownIt-Anchor" href="#间隙锁"></a> 间隙锁</h3><p>间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫gap锁，其不会阻塞其他的gap锁，但是会阻塞插入间隙锁，这也是用来防止幻读的关键</p><h3 id="next-key-锁"><a class="markdownIt-Anchor" href="#next-key-锁"></a> next-key 锁</h3><p>这个锁本质是记录锁加上gap锁。在可重复读隔离级别下，InnoDB对于行的扫描锁定都是使用此算法，但是如果查询扫描中有唯一索引会退化成只使用记录锁<br>因为唯一索引能确定行数，而其他索引不能确定行数，需要使用间隙锁防止其他事务中再次添加这个索引的数据造成幻读。可重复读隔离级别下，InnoDB使用Next-Key Lock算法避免了幻读</p><h3 id="插入意向锁"><a class="markdownIt-Anchor" href="#插入意向锁"></a> 插入意向锁</h3><p>插入意向锁是在插入的时候产生的，在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待<br>假设有一个记录索引包含键值 4 和 7，不同的事务分别插入 5 和 6，每个事务都会产生一个加在 4-7 之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突<br>这里要说明的是如果有间隙锁了，插入意向锁会被阻塞</p><h2 id="死锁检测"><a class="markdownIt-Anchor" href="#死锁检测"></a> 死锁检测</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。说明有等待才会有死锁，解决死锁可以通过去掉等待，比如回滚事务<br>解决死锁的两个办法：<br>等待超时：当某一个事务等待超时之后回滚该事务，另外一个事务就可以执行了<br>但是这样做效率较低，会出现等待时间，还有个问题是如果这个事务所占的权重较大，已经更新了很多数据了，但是被回滚了，就会导致资源浪费</p><p>等待图：等待图用来描述事务之间的等待关系，当这个图如果出现回路，事务就出现回滚，通常来说InnoDB会选择回滚权重较小的事务，也就是undo较小的事务，在现版本的InnoDB中，通常采用深度优先搜索(老版本使用递归)来检测死锁的存在</p><p><strong>如何防止死锁：</strong><br>以固定的顺序访问表和行，交叉访问更容易造成事务等待回路<br>尽量避免大事务占有的资源锁越多，越容易出现死锁。建议拆成小事务<br>降低隔离级别，如果业务允许(上面也分析了，某些业务并不能允许)，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁<br>为表添加合理的索引，防止没有索引出现表锁，出现死锁的概率会突增</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;&lt;p&gt;事务就是是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，若做了一部分但是只要有一步失败，就要回滚所有操作，InnoDB支持事务，M
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="mysql" scheme="https://Ranjiahao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>B树模拟实现与mysql索引应用</title>
    <link href="https://ranjiahao.github.io/2020/08/16/B%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%8Emysql%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8/"/>
    <id>https://ranjiahao.github.io/2020/08/16/B%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%8Emysql%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h1><p>当我们有大量数据在磁盘中存储时需要查询某一数据时，我们不可能将其一次性加载到内存中，此时，我们可以在内存中只保存数据项需要查询的部分信息，以及数据在磁盘中的位置，根据这些信息构建数据结构来方便查找，自然我们想到了红黑树、AVL树这些数据结构，但是对于大量数据，比如10亿的数据我们平均需要进行30次左右的IO操作，这样就导致查询缓慢，IO次数成为性能瓶颈，如果我们需要提高效率，我们必须采用另一种数据结构来减少IO操作（压低树的高度），提高CPU利用率（将一个节点的数据个数增加）</p><p>B树就是这样符合我们要求的一种数据结构，一棵M阶(M&gt;2)的B树，是一棵平衡的M路搜索树，可以是空树或者满足一下性质：</p><ul><li>每一个节点最多有 m 个子节点</li><li>每一个非叶子节点（除根节点）最少有 m/2 个子节点</li><li>如果根节点不是叶子节点，那么它至少有两个子节点</li><li>有 k 个子节点的非叶子节点拥有 k − 1 个键</li><li>所有的叶子节点都在同一层</li></ul><p>这是一个m=5的B树：它的（1256）节点有5个子节点（这5个节点都为NULL），非叶子节点最少有2个键（图中未体现出），每个节点的子节点比键多1，节点中的键升序排列</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png" alt="img"></p><p>搜索：<br>B树的子树大小排序规则，查找数据时，从根节点开始，依次和关键字进行比较，若比关键字大则和这一节点中下一关键字比较；若比关键字小则递归在这一关键字左下角的子节点中寻找，若比所有关键字都大则递归寻找这一节点的最后一个子节点，若遍历完最后一个叶子节点还没有找到则返回false</p><p>插入：<br>插入需要确保插入的键不在B树中，首先我们搜索得到插入的位置，这个位置只能在叶子节点上，然后按照插入排序的规则将节点插入叶子节点上，这里有可能叶子节点数量已经到达了m-1这是再次插入就会导致数组越界的情况，这时我们可以多开一个空间，就可以先插入再调整了。<br>所以插入流程就变为，先插入，再判断此节点是否小于m，若小于m则插入完成。<br>若等于m则说明节点已满，破环了规则，需要分裂，将它平均地分裂成两个节点，从该节点的原有元素和新的元素中选择出中位数小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值，分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）<br>下图中体现了依次插入1~7调整之后的结构</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/33/B_tree_insertion_example.png" alt="img"></p><p>性能分析：<br>最多：第一层m-1，第二层m*(m-1)，第h层m^(h-1)*(m-1)<br>最少：第一层1，第二层2*(m/2)*(m/2)，第h层2*m/2^(h-1)<br>估算：m^h=n，在620亿个元素中，如果这棵树的度为1024，则需要小于4次即可定位到该节点，然后利用二分<br>查找可以快速定位到该元素，大大减少了读取磁盘的次数</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">int</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">BTreeNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 为了方便插入以后再分裂，实际这里多给了一个空间，节点中还是只能存M-1个关键字</span></span><br><span class="line">    K _keys[M];</span><br><span class="line">    BTreeNode&lt;K, M&gt;* _subs[M + <span class="number">1</span>];</span><br><span class="line">    BTreeNode&lt;K, M&gt;* _parent;</span><br><span class="line">    <span class="keyword">size_t</span> _keysize; <span class="comment">// 记录关键字的数量</span></span><br><span class="line">    BTreeNode()</span><br><span class="line">        : _parent(<span class="literal">nullptr</span>)</span><br><span class="line">        , _keysize(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; M + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            _subs[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">int</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> BTreeNode&lt;K, M&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回找到的节点和该元素在该节点中的位置</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;Node*, <span class="keyword">int</span>&gt; Find(<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="comment">// 从根节点的位置开始查找</span></span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; cur-&gt;_keysize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; cur-&gt;_keys[i]) &#123;</span><br><span class="line">                    <span class="comment">// 当前关键字小，就到它的左孩子去找 </span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; cur-&gt;_keys[i]) &#123;</span><br><span class="line">                    <span class="comment">// 当前关键字大，继续跟下一个关键比较</span></span><br><span class="line">                    ++i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(cur, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_subs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到返回最后一个叶子节点和-1，为后续插入做准备</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(parent, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1. 如果树为空，直接插入新节点中，该节点为树的根节点</span></span><br><span class="line"><span class="comment">// 2. 树非空，找待插入元素在树中的插入位置(注意：找到的插入节点位置一定在叶子节点中)</span></span><br><span class="line"><span class="comment">// 3. 检测是否找到插入位置(假设树中的key唯一，即该元素已经存在时则不插入)</span></span><br><span class="line"><span class="comment">// 4. 按照插入排序的思想将该元素插入到找到的节点中</span></span><br><span class="line"><span class="comment">// 5. 检测该节点是否满足B树的性质：即该节点中的元素个数是否等于M，如果小于则满足</span></span><br><span class="line"><span class="comment">// 6. 如果插入后节点不满足B树的性质，需要对该节点进行分裂：</span></span><br><span class="line"><span class="comment">//        申请新节点</span></span><br><span class="line"><span class="comment">//        找到该节点的中间位置</span></span><br><span class="line"><span class="comment">//        将该节点中间位置右侧的元素以及其孩子搬移到新节点中</span></span><br><span class="line"><span class="comment">//        将中间位置元素以及新节点往该节点的双亲节点中插入，即继续4</span></span><br><span class="line"><span class="comment">// 7. 如果向上已经分裂到根节点的位置，插入结束</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node;</span><br><span class="line">            _root-&gt;_keys[<span class="number">0</span>] = key;</span><br><span class="line">            _root-&gt;_keysize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::pair&lt;Node*, <span class="keyword">int</span>&gt; ret = Find(key);</span><br><span class="line">        <span class="comment">// 若元素已存在，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (ret.second != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* node = ret.first;</span><br><span class="line">        K k = key;</span><br><span class="line">        Node* child = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 下面循环迭代逻辑是往node中插入k和child</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            _InsertKey(node, k, child);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;_keysize &lt; M) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果node-&gt;_keysize == M则说明节点满了，需要分裂处理</span></span><br><span class="line">                <span class="keyword">int</span> mid = M / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 将右半区间分裂拷贝新节点中，注意除了拷贝关键字还要拷贝孩子、改变孩子的父亲</span></span><br><span class="line">                Node* newnode = <span class="keyword">new</span> Node;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; M) &#123;</span><br><span class="line">                    newnode-&gt;_keys[j] = node-&gt;_keys[i];</span><br><span class="line">                    newnode-&gt;_subs[j++] = node-&gt;_subs[i];</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;_subs[i]) &#123;</span><br><span class="line">                        node-&gt;_subs[i]-&gt;_parent = newnode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node-&gt;_keys[i] = K();</span><br><span class="line">                    node-&gt;_subs[i++] = <span class="literal">nullptr</span>;</span><br><span class="line">                    newnode-&gt;_keysize++;</span><br><span class="line">                &#125;</span><br><span class="line">                newnode-&gt;_subs[j] = node-&gt;_subs[i];</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;_subs[i]) &#123;</span><br><span class="line">                    node-&gt;_subs[i]-&gt;_parent = newnode;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;_subs[i] = <span class="literal">nullptr</span>;</span><br><span class="line">                node-&gt;_keysize -= (newnode-&gt;_keysize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// node节点的parent如果是空，则产生新的根</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;_parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    _root = <span class="keyword">new</span> Node;</span><br><span class="line">                    _root-&gt;_keys[<span class="number">0</span>] = node-&gt;_keys[mid];</span><br><span class="line">                    _root-&gt;_subs[<span class="number">0</span>] = node;</span><br><span class="line">                    _root-&gt;_subs[<span class="number">1</span>] = newnode;</span><br><span class="line">                    node-&gt;_parent = newnode-&gt;_parent = _root;</span><br><span class="line">                    _root-&gt;_keysize = <span class="number">1</span>;</span><br><span class="line">                    node-&gt;_keys[mid] = K();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 迭代转换成往的node节点parent中去插入一个node-&gt;key[mid]和newnode</span></span><br><span class="line">                    k = node-&gt;_keys[mid];</span><br><span class="line">                    child = newnode;</span><br><span class="line">                    node-&gt;_keys[mid] = K();</span><br><span class="line">                    node = node-&gt;_parent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往node节点中插入key，以及上一次插入key时分裂出来的节点child</span></span><br><span class="line">    <span class="keyword">void</span> _InsertKey(Node* node, <span class="keyword">const</span> K&amp; key, Node* child) &#123;</span><br><span class="line">        <span class="comment">// 按照插入排序思想插入key</span></span><br><span class="line">        <span class="keyword">int</span> end = node-&gt;_keysize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; node-&gt;_keys[end] &gt; key) &#123;</span><br><span class="line">            <span class="comment">// 将该位置元素以及其右侧孩子往右搬移一个位置</span></span><br><span class="line">            node-&gt;_keys[end + <span class="number">1</span>] = node-&gt;_keys[end];</span><br><span class="line">            node-&gt;_subs[end + <span class="number">2</span>] = node-&gt;_subs[end + <span class="number">1</span>];</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入key以及新分裂出的节点</span></span><br><span class="line">        node-&gt;_keys[end + <span class="number">1</span>] = key;</span><br><span class="line">        node-&gt;_subs[end + <span class="number">2</span>] = child;</span><br><span class="line">        <span class="comment">// 更新节点的双亲</span></span><br><span class="line">        <span class="keyword">if</span> (child) &#123;</span><br><span class="line">            child-&gt;_parent = node;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;_keysize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _InOrder(Node* cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; cur-&gt;_keysize) &#123;</span><br><span class="line">            _InOrder(cur-&gt;_subs[i]);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cur-&gt;_keys[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        _InOrder(cur-&gt;_subs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _InOrder(_root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> B+树</h1><p>B树和B+树十分相似，是B树升级版，B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。B+树查找的效率要比B树更高、更稳定、更适合文件系统；两者的区别：</p><ul><li><p>非叶子节点的子树指针与关键字个数相同，非叶子节点中只存储关键字作为查找索引即可（稀疏索引），不保存关键字对应的数据指针，所以这样使得每个节点所能保存的关键字大大增加，树的层级更少所以查询数据更快</p></li><li><p>所有关键字记录的指针都要存在叶子节点的链表中（稠密索引，缓存的命中率也会比B树高）且链表中的节点都是有序的，B+树只有达到叶子节点才能命中，所以每次数据查询的次数都一样</p></li><li><p>为所有叶子节点增加一个链指针，方便遍历，可以用于非主键搜索（全表扫描）</p><p><img src="img1.png" alt="img1"></p></li></ul><p>搜索：和B树类似，不过，在查找时，若非叶子节点上的关键字等于给定值，并不终止，而是继续向下直到叶子节点<br>插入：和B树类似，不过，父节点存储的是索引，分裂时需要向上更新索引</p><h1 id="b树-3"><a class="markdownIt-Anchor" href="#b树-3"></a> B*树</h1><p>B*树是再B+树上的改进，在B+树的非根和非叶子结点再增加指向兄弟的指针</p><p><img src="img2.png" alt="img2"></p><p>除此之外， B*树的非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2），这是因为B*树分裂时当一个结点满了，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B*树分配新结点的概率比B+树要低，空间使用率更高</p><h1 id="mysql的索引"><a class="markdownIt-Anchor" href="#mysql的索引"></a> mysql的索引</h1><p>索引是为了方便用户快速找到所寻的数据的一种数据结构，常见的索引分为：主键索引、唯一索引、普通索引、全文索引<br>索引是以空间换时间，当添加一条记录，除了添加到表中，还要维护二叉树，速度有影响，但不大</p><p><strong>MyISAM</strong><br>MyISAM引擎是MySQL5.5.8版本之前默认的存储引擎，不支持事务，支持全文检索，使用B+Tree<br>作为索引结构，叶节点的data域存放的是数据记录的地址，主索引和辅助索引在结构上没有任何区别（非聚集索引 ）</p><p><img src="img3.png" alt="img3"></p><p><strong>InnoDB</strong><br>InnoDB存储引擎支持事务，MySQL5.5.8版本开始，InnoDB是默认的存储引擎。InnoDB支持B+树索引、全文索引、哈希索引。但InnoDB使用B+Tree作为索引结构时，具体实现方式与MyISAM不同<br>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而InnoDB索引，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引<br>所以InnoDB要求表必须有主键（MyISAM可以没有）如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</p><p><img src="img4.png" alt="img4"></p><p>InnoDB的辅助索引data域存储相应记录主键的值而不是地址，所有辅助索引都引用主键作为data域，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</p><p><img src="img5.png" alt="img5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;b树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#b树&quot;&gt;&lt;/a&gt; B树&lt;/h1&gt;&lt;p&gt;当我们有大量数据在磁盘中存储时需要查询某一数据时，我们不可能将其一次性加载到内存中，此时，我们可以在内存中只保存数据项需要查询的部分信息，以及数据
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="mysql" scheme="https://Ranjiahao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>死锁及银行家算法</title>
    <link href="https://ranjiahao.github.io/2020/08/13/%E6%AD%BB%E9%94%81%E5%8F%8A%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://ranjiahao.github.io/2020/08/13/%E6%AD%BB%E9%94%81%E5%8F%8A%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-12T16:00:00.000Z</published>
    <updated>2020-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哲学家就餐问题中的死锁"><a class="markdownIt-Anchor" href="#哲学家就餐问题中的死锁"></a> 哲学家就餐问题中的死锁</h1><p>描述：在一张圆桌上，有n个哲学家，n支筷子，他们的生活方式只是交替地进行思考和进餐，饥饿时便试图取其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐，进餐完毕，放下筷子又继续思考<br>若n位哲学家都各自获取了一只筷子，此时所有哲学家都想获取第二只筷子去吃饭，但是共享资源n只筷子已经都被n位哲学家握在手里了，彼此想要的筷子都在其他哲学家手中，又没有机制能让任何哲学家放弃握在手中的筷子，从而照成了所有哲学家都在等待其他人手中资源的死锁问题</p><h1 id="计算机中死锁的产生"><a class="markdownIt-Anchor" href="#计算机中死锁的产生"></a> 计算机中死锁的产生</h1><p>计算机中的资源通常分为两类：一类叫可重用资源，一类叫可消耗资源<br><strong>可重用资源</strong><br>一次只能供给一个进程安全的使用，并不会因为使用而耗尽。当一个进程使用完后，该资源就被归还。然后可以再供给其他进程或线程使用。例如内存，外设，处理器等资源<br><strong>可消耗资源</strong><br>指可以被创建和销毁的资源。例如在生产者消费者模型中，生产者生产产品创建了资源，消费者取走产品从而销毁了资源。常见的有：信号，消息等资源</p><p><strong>竞争可重用资源产生死锁</strong><br>例如现在内存大小共有4G。进程1总共需要3G，进程2总共需要3.5G。进程1首先申请了2G内存，进程2首先申请了1.5G内存，此时内存总量还剩余0.5G<br>当进程1想要在申请剩余的1G时，内存资源不够了。进程2想要在申请2G时，内存当然也不够了。此时，进程1希望进程2释放它所拥有的1.5G内存。进程2希望进程1释放它所拥有的2G内存。双方都占着自己所拥有的资源等待着对方释放资源，此时二者便陷入了死锁状态</p><p><strong>竞争可消耗资源产生死锁</strong><br>进程1和进程2之间通过消息进行通信。<br>1 进程1发送消息m1给进程2<br>2 进程2发送消息m2给进程1<br>3 进程1接收消息m2<br>4 进程2接收消息m1<br>如果按上述的1234顺序执行，二者之间便可以进行正常通信。但是如果执行顺序为：3412，此时二者都会发生阻塞而造成死锁</p><p>当一组进程中中的各进程都在等待某个事件发生（通常是等待资源的释放）但能够触发该事件的进程正处于阻塞中。此时，这组进程就发生了死锁</p><p><strong>死锁产生的四个必要条件</strong><br>当以下四个条件均满足时，才会产生死锁。只要有一个不满足。就不会产生：<br><strong>互斥条件</strong>：各进程对某一资源必须是互斥的访问，当一个进程在访问时，请他进程只能等待<br><strong>请求和保持条件</strong>：指进程已经拥有了一个资源，还要在申请另一个资源<br><strong>不可抢占条件</strong>：资源在只能被申请它的进程使用完后自动释放，请他进程不能抢占<br><strong>循环等待条件</strong>：如进程1等待进程2所拥有的资源，进程2等待进程3所拥有的资源，进程3等待进程1所拥有的资源</p><h1 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h1><p>破坏死锁的四个必要条件、加锁顺序一致、避免锁未释放的场景、资源一次性分配</p><h2 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h2><p>设requesti是进程Pi的请求量，如果requesti[j]=k,表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查</p><ol><li>如果requesti[j]&gt;need[I,j]则出错，因为进程所需要的资源数已经超过它需要的最大值</li><li>如果requesi[j]&gt;available[j]表示尚无足够的资源，Pi须等待</li><li>系统试探着把资源分配给进程Pi，并修改available、allocation、need的数值</li><li>系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，已完成本次资源的分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待</li></ol><p><strong>检测当前状态是否安全：</strong><br>设置变量work：表示系统可提供给进程继续运行的剩余资源数。初始时，work=Available<br>设置变量finash：表示系统是否有足够的资源分配给某进程。如果有finash为true，如果没有为false，初始时，假设finash[i]为false</p><ol><li>如果从进程集合中找到一个进程满足：finash[i]=false且Need[i,j]&lt;work[j]，则继续往下执行，若无则，跳转3</li><li>当进程i获取资源后，顺利执行，并释放资源：work[j]=work[j]+Allocation[i,j]；finash[i] = true；继续回到1执行</li><li>当该进程组中所有进程的finash均变为true后，说明该系统处于安全状态。否则，为不安全状态</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Banker(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; available</span><br><span class="line">           , <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; max</span><br><span class="line">           , <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; allocation)</span><br><span class="line">        : _processNum(max.size())</span><br><span class="line">        , _resouceNum(max[<span class="number">0</span>].size())</span><br><span class="line">        , _available(available)</span><br><span class="line">        , _max(max)</span><br><span class="line">        , _allocation(allocation)</span><br><span class="line">        , _need(_processNum, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(_resouceNum, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 计算出需要的资源数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _processNum; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _resouceNum; ++j) &#123;</span><br><span class="line">                _need[i][j] = _max[i][j] - _allocation[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出安全序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintSecurity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"安全序列为："</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : _security) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断请求算法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckRequest</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查资源请求是否合理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _resouceNum; ++i) &#123;</span><br><span class="line">            <span class="comment">// 请求资源数超过进程需求最大值</span></span><br><span class="line">            <span class="keyword">if</span> (request[i] &gt; _need[id][i]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"请求资源数超过进程需求最大值"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尚无足够资源</span></span><br><span class="line">            <span class="keyword">if</span> (request[i] &gt; _available[i]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"尚无足够资源，进程等待"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试分配资源给进程，检测此次分配后系统是否处于安全状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _resouceNum; ++i) &#123;</span><br><span class="line">            _available[i] -= request[i];</span><br><span class="line">            _allocation[id][i] += request[i];</span><br><span class="line">            _need[id][i] -= request[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查分配后系统是否安全</span></span><br><span class="line">        <span class="keyword">if</span> (_checkSafe()) &#123;</span><br><span class="line">            <span class="comment">// 分配后系统安全，正式分配</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"进程："</span> &lt;&lt; id &lt;&lt; <span class="string">"分配资源成功"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 分配后不安全，分配失效，资源恢复</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"本次资源分配后系统不安全，分配失败"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _resouceNum; i++) &#123;</span><br><span class="line">                _available[i] += request[i];</span><br><span class="line">                _allocation[id][i] -= request[i];</span><br><span class="line">                _need[id][i] += request[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 检测安全性</span></span><br><span class="line">    <span class="keyword">bool</span> _checkSafe() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; work(_available);            <span class="comment">// 系统可提供进程所需的资源数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; finish(_processNum, <span class="literal">false</span>); <span class="comment">// 系统是否有足够资源给某进程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _processNum; ++i) &#123;</span><br><span class="line">                <span class="comment">// 如果这个进程已经执行过，则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (finish[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标志当前进程分配资源后是否安全</span></span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _resouceNum; j++) &#123;</span><br><span class="line">                    <span class="comment">// 如果某一项资源不够分配，则说明当前进程不能执行，继续判断后面的</span></span><br><span class="line">                    <span class="keyword">if</span> (_need[i][j] &gt; work[j]) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 加入安全序列中</span></span><br><span class="line">                    _security.push_back(i);</span><br><span class="line">                    <span class="comment">// 调用进程运行，并且释放进程所占资源</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _resouceNum; j++) &#123;</span><br><span class="line">                        work[j] += _allocation[i][j];</span><br><span class="line">                        finish[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// break进入下一轮查找安全进程，从头开始判断</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == _processNum) &#123;</span><br><span class="line">                <span class="comment">// 有两种可能，若finish全为true则系统处于安全状态，否则系统处于不安全状态</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _processNum; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (finish[j] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"系统处于不安全状态"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 系统处于安全状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _security; <span class="comment">// 安全序列</span></span><br><span class="line">    <span class="keyword">int</span> _processNum;        <span class="comment">// 进程数</span></span><br><span class="line">    <span class="keyword">int</span> _resouceNum;        <span class="comment">// 资源数</span></span><br><span class="line">    <span class="comment">// 可利用资源向量，_available[j]=K，表示j类资源剩余K个</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _available;</span><br><span class="line">    <span class="comment">// 最大需求矩阵，_max[i,j]=K，表示进程i最大需求j类资源K个</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _max;</span><br><span class="line">    <span class="comment">// 已分配矩阵，_allocation[i,j]=K，表示进程i已经被分配了j类资源K个</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _allocation;</span><br><span class="line">    <span class="comment">// 需求矩阵，_need[i,j]=K，表示进程i还需要j类资源K个</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _need;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哲学家就餐问题中的死锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#哲学家就餐问题中的死锁&quot;&gt;&lt;/a&gt; 哲学家就餐问题中的死锁&lt;/h1&gt;&lt;p&gt;描述：在一张圆桌上，有n个哲学家，n支筷子，他们的生活方式只是交替地进行思考和进餐，饥饿时便
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="锁" scheme="https://Ranjiahao.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://ranjiahao.github.io/2020/08/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ranjiahao.github.io/2020/08/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-07T16:00:00.000Z</published>
    <updated>2020-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理</p><p>饿汉模式：不管将来用不用，程序启动时就创建一个唯一的实例对象<br>实现简单，如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，使用饿汉模式来避免资源竞争，提高响应速度。但是可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定，而且由于单例对象是在main函数之前创建的，所以单例类中不可创建线程、使用动态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">// 在程序入口之前就完成单例对象的初始化</span></span><br></pre></td></tr></table></figure><p>懒汉模式：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制<br>如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊，初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 需要设置volatile关键字，否则可能被编译器优化</span></span><br><span class="line">    <span class="function"><span class="keyword">volatile</span> <span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (_pInstance == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果_pInstance已经为空就不需要加锁</span></span><br><span class="line">            <span class="comment">// _mtx.lock();</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(_mtx);</span><br><span class="line">                <span class="keyword">if</span> (_pInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    _pInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// _mtx.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(_mtx);</span><br><span class="line">        <span class="keyword">delete</span> _pInstance;</span><br><span class="line">        _pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现一个内嵌垃圾回收类，程序结束时候正常释放单例对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbo() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_pInstance) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _pInstance;</span><br><span class="line">                _pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防拷贝</span></span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有</span></span><br><span class="line">    Singleton() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton* _pInstance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex _mtx;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">volatile</span> Singleton* Singleton::_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">Singleton::CGarbo Garbo;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::_mtx;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="设计模式" scheme="https://Ranjiahao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS</title>
    <link href="https://ranjiahao.github.io/2020/07/30/HTTP%E4%B8%8EHTTPS/"/>
    <id>https://ranjiahao.github.io/2020/07/30/HTTP%E4%B8%8EHTTPS/</id>
    <published>2020-07-29T16:00:00.000Z</published>
    <updated>2020-07-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议用于用于客户端和服务器通信，请求访问资源的一端称为客户端，而提供资源响应的一端称为服务端，HTTP协议使用URI定位互联网上的资源，当客户端请求访问资源而发送请求时，URL需要将作为请求报文中的请求URL包含在内</p><h1 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h1><p>统一资源定位符<br><code>http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</code><br>http: 协议名<br>user:pass: 登录信息<br><a href="http://www.example.jp" target="_blank" rel="noopener">www.example.jp</a>: 服务器地址<br>80: 端口号<br>dir/index.htm: 带层次的路径名<br>uid=1: 查询字符，一个个key=val形式的键值对，并且键值对之间用&amp;符号进行间隔<br>ch1: 片段标识符</p><p>eg:<br><code>https://www.bing.com/search?q=C%2B%2B&amp;qs=n&amp;form=QBLH&amp;sp=-1&amp;pq=&amp;sc=0-0&amp;sk=&amp;cvid=553C64EAE262401D94DD4794F3A33CFF</code><br>我们可以看到，上面的url格式中，有一些字符，比如/?:等这些字符在url中有着特殊的含义，我们不可以随便的使用，某个参数中需要带有这些特殊字符，就必须先对特殊字符进行转义，转码的字符转为16进制，编码成%XY格式，&quot;+&quot; 被转义成了 “%2B”</p><h1 id="http请求格式"><a class="markdownIt-Anchor" href="#http请求格式"></a> HTTP请求格式</h1><p><img src="img1.png" alt="img1"></p><p>首行: [方法] + [url] + [版本]<br>Header: 请求的属性，冒号分割的键值对，每组属性之间使用\r\n分隔，遇到空行(连续两次\r\n)表示Header部分<br>结束<br>常见属性：<br>Host: 表示访问主机名，也就是ip地址的别，即域名<br>Connection: 长连接开关<br>Content-Length: Body长度<br>Cache-Control: 缓存时间<br>Upgrade-Insecure-Requests: 请求升级<br>Content-Type: 正文数据类型<br>User-Agent: 操作系统和浏览器信息<br>Accept: 用户代理可处理的类型<br>Referer: 跳转信息<br>Accept-Encoding: 内容编码，内容编码后的实体由客户端接收并负责解码<br>Accept-Language: 客户端语言<br>Cookie: 用来保存一个从服务器返回回来的字符串，并且保存到本地，下一次访问同一个网站，会将这个信息带回去<br>Body: 空行后面的内容都是Body，允许为空字符串，如果Body存在，则在Header中会有一个Content-Length属性来标识Body的长度</p><h2 id="请求方法"><a class="markdownIt-Anchor" href="#请求方法"></a> 请求方法</h2><p>GET: 获取资源，请求访问已被URI识别的资源，经服务器端解析后返回<br>POST: 传输实体主体<br>PUT: 传输文件，自身不带验证机制，任何人都可以上传，存在安全问题，需要配合Web应用程序的验证机制，或架构设计采用REST标准的同类Web网站<br>HEAD: 获得报文首部<br>DELETE: 删除文件<br>OPTIONS: 询问支持的方法<br>TRACE: 通过属性Max-Forwards追踪路径<br>CONNECT: 要求用隧道协议连接代理</p><h1 id="http响应格式"><a class="markdownIt-Anchor" href="#http响应格式"></a> HTTP响应格式</h1><p><img src="img2.png" alt="img2"></p><p>首行: [版本号] + [状态码] + [状态码解释]<br>Header: 响应属性<br>常见属性：<br>Sever: HTTP服务器安装信息<br>Content-Type: text/html表示body的格式是一个xml的文本格式，charset说明字符集为utf-8<br>Content-Length: Body部分的字节数<br>Location: 令客户端重定向到指定的URL<br>Transfer-Encoding: 传输内容编码，如分块传输每一块都会用十六进制来标记块的大小， 而实体主体的最后一块会使用0\r\n<br>Set-Cookie: 和请求中的Cookie对应，服务器利用Set-Cookie向客户端返回用来表示身份信息的的字符串，下次访问时就会重新带入，避免再次登录<br>Body: 如果服务器返回了一个html页面，那么html页面内容就是在body中</p><h2 id="状态码"><a class="markdownIt-Anchor" href="#状态码"></a> 状态码</h2><p><img src="img3.png" alt="img3"></p><p>200 OK 表示从客户端发来的请求在服务器端被正常处理<br>204 No Content 服务器接收的请求已成功处理， 但在返回的响应报文中不含实体的主体部分<br>206 Partial Content 客户端进行了范围请求，服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容<br>301 Moved Permanently 永久性重定向表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存<br>302 Found 临时性重定向<br>304 Not Modified 服务器端允许请求访问资源，但未满足条件的情况<br>400 Bad Request 请求报文中存在语法错误<br>401 Unauthorized 表示发送的请求需要有通过HTTP认证的认证信息<br>403 Forbidden 对请求资源的访问被服务器拒绝<br>404 Not Found 无法找到请求的资源<br>500 Internal Server Error 服务器端在执行请求时发生了错误<br>503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护<br>504 Gateway Timeout 网关超时</p><h1 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h1><p>HTTP是一种不保存状态，即无状态的协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，这是为了更快地处理大量事务，确保协议的可伸缩性，可减少服务器的CPU及内存资源的消耗而特意把HTTP协议设计成如此简单的，但是针对一些场景，需要继续保持登录状态，于是引入了Cookie技术，有了Cookie再用HTTP协议通信，就可以管理状态了<br>如果，客户端发送的报文中无Cookie，则服务器生成一个Cookie，通过Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去，服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息</p><h1 id="持久连接"><a class="markdownIt-Anchor" href="#持久连接"></a> 持久连接</h1><p>HTTP协议的初始版本中，由于当年都是些容量很小的文本传输，每进行一次HTTP请求响应就要断开一次TCP连接，随着HTTP的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的HTML页面时，发送请求访问HTML页面资源的同时，也会请求该 HTML页面里包含的其他资源，每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销所以1.0版本时候，部分厂商提出了持久连接，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>HTTP/1.1 中，所有的连接默认都是持久连接，持久连接使得多数请求以管线化方式发送，从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求，做到同时并行发送多个请求，不需要一个接一个地等待响应</p><h1 id="http存在的问题和解决方法"><a class="markdownIt-Anchor" href="#http存在的问题和解决方法"></a> HTTP存在的问题和解决方法</h1><p>由于通信使用明文，所以内容可能会被窃听，而且不验证通信方的身份， 有可能遭遇伪装，还无法证明报文的完整性， 有可能已遭篡改。</p><p>解决方法：</p><ol><li>通信加密<br>HTTP协议中没有加密机制，但可以通过和SSL或TLS的组合使用，加密HTTP的通信内容，用SSL建立安全通信线路之后， 就可以在这条线路上进行HTTP通信了</li><li>内容加密<br>客户端需要对HTTP报文进行加密处理后再发送请求<img src="img4.png" alt="img4"></li></ol><p>但是单纯的加密的不够的，还需要身份验证，如果不论谁发送过来的请求都会返回响应，会存在很多隐患，有可能响应给伪装的Web服务器或者客户端，无法确定正在通信的对方是否具备访问权限，无意义的请求也会照单全收（无法阻止DOS攻击）<br>所以SSL还使用了一种被称为证书的手段，可以确认对方，证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图，另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节</p><p>但这还存在一些问题，HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，没有任何办法确认， 发出的请求/响应和接收到的请求/响应是前后相同的<img src="img5.png" alt="img5"><br>所以我们可以用MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法，但这些方法也依然无法百分百保证确认结果正确，PGP和MD5本身被改写的话，用户是没有办法意识到的，因此仅靠HTTP确保完整性是非常困难的</p><h1 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h1><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong></p><p>HTTPS是身披SSL外壳的HTTP，HTTP先和SSL通信，再由SSL和TCP通信<br><img src="img6.png" alt="img6"></p><p><strong>加密</strong><br>对称密钥加密：加密和解密同用一个密钥，这种方式必须将密钥也发给对方，但是密钥若能安全发送，那数据也能到达</p><p>对非对称密钥加密：使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后， 再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥， 也不必担心密钥被攻击者窃听而盗走，但是处理速度慢</p><p>混合加密机制：HTTPS采用对称加密和非对称加密并用的混合加密机制，在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</p><p><strong>认证</strong><br>为了解决身份验证问题，HTTPS中使用数字证书认证机构和其相关机关颁发的公开密钥证书。<br>服务器的运营人员向证书认证机构提出公开密钥的申请。证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入证书后绑定在一起，服务器会将这份由认证机构颁发的证书发送给客户端，以进行公开密钥加密方式通信，当客户端接收到服务器发送的公钥证书的时候，就会向证书认证机构来验证数字签名是否正确，来判断该公钥是否遭到替换，确保了公钥的真实性</p><p><strong>HTTPS通信步骤</strong></p><p><img src="img7.png" alt="img7"></p><ol><li>客户端通过发送Client Hello报文开始SSL通信。 报文中包含客户端支持的SSL的指定版本、 加密组件列表（所使用的加密算法及密钥长度等）</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的</li><li>服务器发送Certificate报文。报文中包含公开密钥证书</li><li>最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束</li><li>SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密</li><li>接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密</li><li>客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准</li><li>服务器同样发送Change Cipher Spec报文</li><li>服务器同样发送Finished报文</li><li>服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求</li><li>应用层协议通信，即发送HTTP响应</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信</li></ol><p>在上面的流程中，应用层发送数据的时候会附加MAC报文摘要，MAC能够查知报文是否遭受到篡改，从而让保护报文的完整性</p><p><img src="img8.png" alt="img8"></p><p>HTTPS也存在一些问题，那就是当使用SSL时，通信速度慢，大量消耗CPU及内存等资源，导致处理速度变慢（解决方法SSL专用服务器）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP协议用于用于客户端和服务器通信，请求访问资源的一端称为客户端，而提供资源响应的一端称为服务端，HTTP协议使用URI定位互联网上的资源，当客户端请求访问资源而发送请求时，URL需要将作为请求报文中的请求URL包含在内&lt;/p&gt;&lt;h1 id=&quot;url&quot;&gt;&lt;a class
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="HTTP" scheme="https://Ranjiahao.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>位图与布隆过滤器</title>
    <link href="https://ranjiahao.github.io/2020/07/26/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://ranjiahao.github.io/2020/07/26/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h1><p>在哈希表中，如果要在表中存放一个整数，此时就要申请一个整型的内存来存放它，一个整型数据在32位或64位平台下都占4个字节。如果现在需要存储的数据非常多，比如说40亿个不重复的数据，就需要160亿个字节来存储，1GB的内存表示的是10亿个字节，此时就需要16GB的内存来存放这些数据，而我们普通的电脑内存一般都是4G的内存，这显然是存放不下的。我们知道，内存中的最小单位是比特位。如果能用一个比特位来存放一个整型，只需要0.5GB的内存。一个比特位可以表示一个0或1。如果要表示40亿个数据，可以申请0.5GB的内存。如果要存放的数据为10，就将第10个比特位设置为1。如果要查找的数据为100，就查看第100个比特位处的状态，如果为1说明，100存在于这堆数据中，如果为0说明不存在</p><p>位图的应用：</p><ol><li>快速查找某个数据是否在一个集合中</li><li>排序</li><li>求两个集合的交集、并集等</li><li>操作系统中磁盘块标记、内核O(1)调度算法</li></ol><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitset.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BitSet(<span class="keyword">size_t</span> range) &#123;</span><br><span class="line">        <span class="comment">// +1是为了防止数据小于32和向上取整</span></span><br><span class="line">        _bs.resize((range &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 存储</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        _bs[index] |= (<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> (_bs[index] &gt;&gt; bitIdx) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        _bs[index] &amp;= (~(<span class="number">1</span> &lt;&lt; bitIdx));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _bs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应用：</p><ol><li>给定100亿个整数，设计算法找到只出现一次的整数？<br>100亿个整数，一个整数占4个字节，总共需要400亿字节。1GB = 10亿字节，所以需要40GB的内存。因此不能直接将数据加载到内存中<br>对于任意的整数，可以分三个状态进行讨论：没有出现，出现一次，出现多次。因此三个状态可以两个比特位来存放。其中：00表示没有出现的整数，01表示出现1次的整数，10表示出现两次的整数，11舍弃不用。所以可以用位图来对这些数据进行处理，此时内存占用就可以减少为1GB<br>实现思路如下： 首先在内存中创建一个1GB的位图，初始化时全部设置为0。然后遍历100亿个整数，遇到一个整数，将该整数的2倍处的连续两个比特位先设置为01，当遇到两次或两次以上的情形时，将这两个比特位设置为01即可。遍历完所有整数后，对位图的设置就结束了<br>然后，从头开始遍历位图，一次提取两个比特位，如果这两个比特位对应的数字为01，说明这两个比特位对应的数字只出现了一次。遍历完整个位图之后，就找到了所有只出现一次的数字</li><li>给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？<br>方案1：将其中一个文件的整数位置映射到一个位图，读取第二个文件判断是否在位图中。500M内存<br>方案2：将文件1的整数映射到位图1中，将文件2的整数映射到位图2中，然后两个位图按位与得到交集。1G内存</li></ol><h1 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器"></a> 布隆过滤器</h1><p>新闻客户端推荐系统如何实现推送去重的？ 用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。如何快速查找呢？<br>用哈希表存储用户记录，缺点：浪费空间<br>用位图存储用户记录，缺点：不能处理哈希冲突<br>将哈希与位图结合，即布隆过滤器</p><p>可以用位图加上多个字符串哈希函数的方法来实现布隆过滤器。字符串哈希函数越多，一个字符串对应的下标值也就越多，冲突的概率就会越小<br>可以用来告诉你 “某样东西一定不存在或者可能存在”</p><p><img src="img1.png" alt="img1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitset.hpp"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun1</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">131</span> + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun2</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">65599</span> + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun3</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * magic + ch;</span><br><span class="line">            magic *= <span class="number">378551</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">HFun1</span>, <span class="title">class</span> <span class="title">HFun2</span>, <span class="title">class</span> <span class="title">HFun3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BloomFilter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// m： bitSet大小</span></span><br><span class="line">    <span class="comment">// n: 元素个数</span></span><br><span class="line">    <span class="comment">// k: 哈希函数的数量</span></span><br><span class="line">    <span class="comment">// k = (m/n)* ln2</span></span><br><span class="line">    <span class="comment">// m = k * n / ln2 = 1.4 * k * n</span></span><br><span class="line">    BloomFilter(<span class="keyword">size_t</span> number)</span><br><span class="line">        : _bs(<span class="number">5</span> * number)</span><br><span class="line">        , _bitCount(<span class="number">5</span> * number) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">int</span> index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">int</span> index3 = HFun3()(data) % _bitCount;</span><br><span class="line"></span><br><span class="line">        _bs.Set(index1);</span><br><span class="line">        _bs.Set(index2);</span><br><span class="line">        _bs.Set(index3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        <span class="comment">// 只要有一个位置为0说明不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index3 = HFun3()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index3)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 可能误判</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供删除</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitSet _bs;</span><br><span class="line">    <span class="keyword">size_t</span> _bitCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：在对布隆过滤器的基本操作中，没有删除某一字符串的操作。因为一个字符串对应多个下标处的状态，一个下标处的状态也可能被多个字符串使用。所以，一旦将一个字符串删除，就会将该字符串对应的多个下标处的1均置为0，此时就会影响其他的字符串。因此不能对布隆过滤器进行删除操作。改进支持删除的方法：将布隆过滤器中的每个比特位扩展成一个小的计数器，插入元素时给k个计数器(k个哈希函数计算出的哈希地址)加一，删除元素时，给k个计数器减一，通过多占用几倍存储空间的代价来增加删除操作</p><p>缺点：</p><ol><li>有误判率不能准确判断元素是否在集合中(补救方法：再建立一个白 名单，存储可能会误判的数据)</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素，如果采用计数方式删除，可能会存在计数回绕问题</li></ol><p>优点：</p><ol><li>时间复杂度为O(K) (K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>不能获取元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ol><p>应用：</p><ol><li>给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法<br>近似算法：将文件1的query映射到一个布隆过滤器中，读取文件2中的query，判断在不在布隆过滤器中，在就是交集。缺陷：判断出来的交集中的数不准确，但是不会遗漏数据<br>精准算法：哈希切分，将文件A和文件B都分为1000个小文件，i=hashstr(query)%1000得到的i是多少就将query放入对应的A(i)或B(i)中，然后将A(i)数据放入set中，查找B(i)看是否在交集中</li><li>给一个超过100G大小的log file, log中存着IP地址, 设计算法找到top K的IP？如何直接用Linux系统命令实现？<br>先创建1000个小文件A0~A999，读取IP计算i=hashstr(ip)%1000，i是多少IP就进入对应编号Ai小文件，这样相同IP一定进入同一小文件，利用map&lt;string, int&gt;统计ip出现的次数，用一个大小为k的小顶堆即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#位图&quot;&gt;&lt;/a&gt; 位图&lt;/h1&gt;&lt;p&gt;在哈希表中，如果要在表中存放一个整数，此时就要申请一个整型的内存来存放它，一个整型数据在32位或64位平台下都占4个字节。如果现在需要存储的数据非
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="位图" scheme="https://Ranjiahao.github.io/tags/%E4%BD%8D%E5%9B%BE/"/>
    
      <category term="布隆过滤器" scheme="https://Ranjiahao.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突、unorde_map/set模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/24/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%81unorde_map,set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/24/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%81unorde_map,set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-07-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>哈希是一种O(1)查找的数据结构，可以不经过任何比较，一次直接从表中得到要搜索的元素。通过hashFunc使元素的存储位置与它的关键码之间能够建立一一映射的关系<br>在插入元素时，由待插入元素的值根据一个特殊函数（哈希函数）计算出该元素的存储位置，并将该元素放置在此处。在搜索元素时，还是由搜索的元素值根据这个特殊函数计算存储位置，直接在该位置将元素取出即可<br>常见的哈希函数有：<br>直接定址法 Hash（Key）= A * Key + B 直接取关键字本身或者他的线性函数来作为散列地址<br>除留余数法 Hash(key) = key % capacity 最常用的哈希函数，用一个数来对key取模，一般来说这个数都是容量<br>由于直接定址、除留余数法这些函数要求key必须为整形，而对于字符串类型就要别的方式，比如BKD对字符串每一个字符的ascii值或者字符串的大小进行计算，来推导出一个不容易产生冲突的key值，但是尽管如此，对与不同的数据根据哈希函数计算出来的值也是可能相同的，这就产生了哈希冲突，我们可以设计精妙的哈希函数来使产生哈希冲突的可能性尽可能的低，但不可能避免哈希冲突解决哈希冲突常见的办法有两种：闭散列和开散列</p><h1 id="闭散列"><a class="markdownIt-Anchor" href="#闭散列"></a> 闭散列</h1><p>当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的下一个空位置中去，我们可以用线性探测或者二次探测的方法来寻找下一个空位置<br><strong>线性探测：</strong> 从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止<br>插入：通过哈希函数获取待插入元素在哈希表中的位置，如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素<br>删除：采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索，因此线性探测采用标记的伪删除法来删除一个元素<br>线性探测缺点：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据堆积，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低<br><strong>二次探测：</strong> 找下一个空位置的方法为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">H_i = (H_0 + i^2) \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">m</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo>−</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">H_i = (H_0 - i^2) \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">m</span></span></span></span>其中：i = 1,2,3…，是通过散列函数Hash(x)对元素的关键码key进行计算得到的位置，m是表的大小<br>研究表明当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次，因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容<br>二次探测缺点：空间利用率低<br><strong>提高性能：</strong> (1)由于表中元素越多，产生冲突的概率越大，所以我们引入了负载因子，当容量到达百分之八十的时候就进行扩容操作。(2)除留余数法，最好模一个素数</p><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> STATE &#123;</span><br><span class="line">    EMPTY, EXIST, DELETE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hashNode</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;K, V&gt; _data;</span><br><span class="line">    STATE _state = EMPTY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了实现简单，将比较直接与元素绑定在一起</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashNode&lt;K, V&gt; Node;</span><br><span class="line"></span><br><span class="line">    HashTable(<span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>)</span><br><span class="line">        : _ht(n)</span><br><span class="line">        , _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">int</span> index = data.first % _ht.size();</span><br><span class="line">        <span class="comment">// 判断当前位置是否有元素，若没有，则直接插入</span></span><br><span class="line">        <span class="comment">// 新的元素可以放在：EMPTY,DELETE</span></span><br><span class="line">        <span class="keyword">while</span> (_ht[index]._state == EXIST) &#123;</span><br><span class="line">            <span class="comment">// 如果有：判读当前位置的元素的key是否和插入的数据相同</span></span><br><span class="line">            <span class="keyword">if</span> (_ht[index]._data.first == data.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有， 且key不同，继续向后遍历，找一个空的位置，进行插入（线性探测）</span></span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> (index == _ht.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素插入</span></span><br><span class="line">        _ht[index]._data = data;</span><br><span class="line">        _ht[index]._state = EXIST;</span><br><span class="line">        ++_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_ht.size() == <span class="number">0</span> || _size * <span class="number">10</span> / _ht.size() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">// 负载因子大于阈值，进行增容</span></span><br><span class="line">            <span class="comment">// int newC = _ht.size() == 0 ? 10 : 2 * _ht.size();</span></span><br><span class="line">            <span class="keyword">size_t</span> newC = getNextPrime(_ht.size());</span><br><span class="line">            HashTable&lt;K, V&gt; newHt(newC);</span><br><span class="line">            <span class="comment">// 旧表元素重新插入到新表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ht[i]._state == EXIST) &#123;</span><br><span class="line">                    newHt.Insert(_ht[i]._data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 旧表新表交换</span></span><br><span class="line">            <span class="built_in">std</span>::swap(_ht, newHt._ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = key % _ht.size();</span><br><span class="line">        <span class="comment">// 直到遇到空结束</span></span><br><span class="line">        <span class="keyword">while</span> (_ht[index]._state != EMPTY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ht[index]._state == EXIST) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ht[index]._data.first == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &amp;_ht[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> (index == _ht.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        Node* pos = Find(key);</span><br><span class="line">        <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">            pos-&gt;_state = DELETE;</span><br><span class="line">            --_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> getNextPrime(<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> PRIMECOUNT = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> primeList[PRIMECOUNT] = &#123;</span><br><span class="line">            <span class="number">53u</span>l, <span class="number">97u</span>l, <span class="number">193u</span>l, <span class="number">389u</span>l, <span class="number">769u</span>l,</span><br><span class="line">            <span class="number">1543u</span>l, <span class="number">3079u</span>l, <span class="number">6151u</span>l, <span class="number">12289u</span>l, <span class="number">24593u</span>l,</span><br><span class="line">            <span class="number">49157u</span>l, <span class="number">98317u</span>l, <span class="number">196613u</span>l, <span class="number">393241u</span>l, <span class="number">786433u</span>l,</span><br><span class="line">            <span class="number">1572869u</span>l, <span class="number">3145739u</span>l, <span class="number">6291469u</span>l, <span class="number">12582917u</span>l, <span class="number">25165843u</span>l,</span><br><span class="line">            <span class="number">50331653u</span>l, <span class="number">100663319u</span>l, <span class="number">201326611u</span>l, <span class="number">402653189u</span>l, <span class="number">805306457u</span>l,</span><br><span class="line">            <span class="number">1610612741u</span>l, <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRIMECOUNT; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (primeList[i] &gt; sz) &#123;</span><br><span class="line">                <span class="keyword">return</span> primeList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primeList[PRIMECOUNT - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; _ht;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="开散列"><a class="markdownIt-Anchor" href="#开散列"></a> 开散列</h1><p>对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来（数据过多时可能会转为建立红黑树），各链表的头结点存储在哈希表中，开散列最好的情况是每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容</p><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash.hpp</span></span><br><span class="line"><span class="comment">// 开散列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">HashNode</span> &#123;</span></span><br><span class="line">    HashNode(<span class="keyword">const</span> V&amp; data = V())</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    V _data;</span><br><span class="line">    HashNode&lt;V&gt;* _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">HashIterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _HashIterator&lt;K, V, KeyOfValue, HFun&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板友元类声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">struct</span> _<span class="title">HashIterator</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到非空链表的头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">            <span class="comment">// this: 当前调用函数的对象hastTbale</span></span><br><span class="line">            <span class="keyword">if</span> (_ht[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> iterator(_ht[i], <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashTable(<span class="keyword">size_t</span> N = <span class="number">10</span>) &#123;</span><br><span class="line">        _ht.resize(N);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> hashIndex(<span class="keyword">const</span> K&amp; key, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        HFun hf;</span><br><span class="line">        <span class="comment">// 哈希函数把key转成整数</span></span><br><span class="line">        <span class="keyword">return</span> hf(key) % sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> V&amp; data) &#123;</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        <span class="comment">// 计算位置</span></span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">int</span> index = hashIndex(kov(data), _ht.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历单链表</span></span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == kov(data)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入：头插</span></span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        cur-&gt;_next = _ht[index];</span><br><span class="line">        _ht[index] = cur;</span><br><span class="line">        ++_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> getNextPrime(<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> PRIMECOUNT = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> primeList[PRIMECOUNT] = &#123;</span><br><span class="line">            <span class="number">53u</span>l, <span class="number">97u</span>l, <span class="number">193u</span>l, <span class="number">389u</span>l, <span class="number">769u</span>l,</span><br><span class="line">            <span class="number">1543u</span>l, <span class="number">3079u</span>l, <span class="number">6151u</span>l, <span class="number">12289u</span>l, <span class="number">24593u</span>l,</span><br><span class="line">            <span class="number">49157u</span>l, <span class="number">98317u</span>l, <span class="number">196613u</span>l, <span class="number">393241u</span>l, <span class="number">786433u</span>l,</span><br><span class="line">            <span class="number">1572869u</span>l, <span class="number">3145739u</span>l, <span class="number">6291469u</span>l, <span class="number">12582917u</span>l, <span class="number">25165843u</span>l,</span><br><span class="line">            <span class="number">50331653u</span>l, <span class="number">100663319u</span>l, <span class="number">201326611u</span>l, <span class="number">402653189u</span>l, <span class="number">805306457u</span>l,</span><br><span class="line">            <span class="number">1610612741u</span>l, <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRIMECOUNT; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (primeList[i] &gt; sz) &#123;</span><br><span class="line">                <span class="keyword">return</span> primeList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primeList[PRIMECOUNT - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_size == _ht.size()) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> newC = getNextPrime(_ht.size());</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pNode&gt; newHt;</span><br><span class="line">            newHt.resize(newC);</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            <span class="comment">// 移动旧表的元素到新表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 单链表头节点</span></span><br><span class="line">                pNode cur = _ht[i];</span><br><span class="line">                <span class="comment">// 遍历单链表</span></span><br><span class="line">                <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                    pNode next = cur-&gt;_next;</span><br><span class="line">                    <span class="comment">// 重新计算在新表中的位置</span></span><br><span class="line">                    <span class="keyword">int</span> index = hashIndex(kov(cur-&gt;_data), newHt.size());</span><br><span class="line">                    <span class="comment">// 头插</span></span><br><span class="line">                    cur-&gt;_next = newHt[index];</span><br><span class="line">                    newHt[index] = cur;</span><br><span class="line">                    cur = next;</span><br><span class="line">                &#125;</span><br><span class="line">                _ht[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::swap(_ht, newHt); <span class="comment">// start, finish, endOfStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = key % _ht.size();</span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashIndex(key, _ht.size());</span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == key) &#123;</span><br><span class="line">                <span class="comment">// 判断是否为头</span></span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    _ht[index] = cur-&gt;_next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent-&gt;_next = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">                --_size;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指针数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pNode&gt; _ht;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">HashIterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _HashIterator&lt;K, V, KeyOfValue, HFun&gt; Self;</span><br><span class="line">    <span class="keyword">typedef</span> HashTable&lt;K, V, KeyOfValue, HFun&gt; HTable;</span><br><span class="line"></span><br><span class="line">    _HashIterator(pNode node, HTable* pht)</span><br><span class="line">        : _node(node)</span><br><span class="line">        , _pht(pht) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_next) &#123;</span><br><span class="line">            _node = _node-&gt;_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            <span class="comment">// 下一个非空链表的头节点</span></span><br><span class="line">            <span class="keyword">size_t</span> index = _pht-&gt;hashIndex(kov(_node-&gt;_data), _pht-&gt;_ht.size());</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; _pht-&gt;_ht.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_pht-&gt;_ht[index]) &#123;</span><br><span class="line">                    _node = _pht-&gt;_ht[index];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == _pht-&gt;_ht.size()) &#123;</span><br><span class="line">                _node = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _node;</span><br><span class="line">    HTable* _pht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="unordered_map-set模拟实现"><a class="markdownIt-Anchor" href="#unordered_map-set模拟实现"></a> unordered_map、set模拟实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hash.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hashFun</span> &#123;</span></span><br><span class="line">    <span class="function">K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashFun</span>&lt;std::string&gt; &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="comment">// BKD</span></span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">131</span> + e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template &lt;&gt;</span></span><br><span class="line"><span class="comment">//struct hashfun&lt;自定义类型&gt; &#123;</span></span><br><span class="line"><span class="comment">//size_t operator()(const 自定义类型&amp; key) &#123;</span></span><br><span class="line"><span class="comment">//        // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">HFun</span> = <span class="title">hashFun</span>&lt;K&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UMap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MapKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue, HFun&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="comment">// pair&lt;iterator, bool&gt;</span></span><br><span class="line">        <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; ret = _ht.insert(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">        <span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HashTable&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue, HFun&gt; _ht;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">USet</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SetKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, K, SetKeyOfValue, HFun&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> K&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HashTable&lt;K, K, SetKeyOfValue, HFun&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;&lt;p&gt;哈希是一种O(1)查找的数据结构，可以不经过任何比较，一次直接从表中得到要搜索的元素。通过hashFunc使元素的存储位置与它的关键码之间能够建立
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="哈希" scheme="https://Ranjiahao.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="unordered_map/set" scheme="https://Ranjiahao.github.io/tags/unordered-map-set/"/>
    
  </entry>
  
  <entry>
    <title>红黑树与map、set模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8Emap%E3%80%81set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8Emap%E3%80%81set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-07-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于AVL树不适用一些经常修改的结构，这是因为AVL树追求绝对的平衡，所以就有了一种近似平衡的二叉搜索树红黑树，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p><p>红黑树在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black，它有这些特点：</p><ol><li>每个结点不是红色就是黑色</li><li>根节点是黑色的</li><li>如果一个节点是红色的，则它的两个孩子结点是黑色的</li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li><li>每个叶子结点都是黑色的(此处的叶子结点指的是空结点)</li></ol><p>由于红黑树的这些特点，所以红黑树能保证其最长路径中节点个数不会超过最短路径节点个数的两倍</p><p>红黑树的插入：<br>首先按照二叉搜索树的规则插入新节点，如果新节点设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换和树旋转来调整<br>插入红色节点后，分情况讨论当前红黑树的状态</p><ol><li>其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整</li><li>其双亲节点的颜色是红色，约定n为当前节点，p为父节点，g为祖父节点，u为叔叔节点<br>(2.1) n为红，p为红，g为黑，u存在且为红，则需要将p、u改为黑，g改为红，然后把g当成n，继续向上调整<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png" alt="2.1"><br>(2.2) n为红，p为红，g为黑，u不存在/u为黑<br>(2.2.1) p为g的左孩子，n为p的左孩子，进行右单旋转，同理p为g的右孩子，n为p的右孩子，进行左单旋转<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png" alt="2.2.1"><br>(2.2.2) p为g的左孩子，n为p的右孩子，进行左旋转后变为情况2.2.1，再进行右旋<br>同理p为g的右孩子，n为p的左孩子，进行右旋转后变为情况2.2.1，再进行左旋<br><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png" alt="2.2.2"></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RBTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> COLOR &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">RBTNode</span> &#123;</span></span><br><span class="line">    RBTNode(<span class="keyword">const</span> V&amp; data = V())</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _parent(<span class="literal">nullptr</span>)</span><br><span class="line">        , _color(RED) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V _data;</span><br><span class="line">    RBTNode&lt;V&gt;* _left;</span><br><span class="line">    RBTNode&lt;V&gt;* _right;</span><br><span class="line">    RBTNode&lt;V&gt;* _parent;</span><br><span class="line">    COLOR _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">RBTreeIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RBTNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;V&gt; Self;</span><br><span class="line"></span><br><span class="line">    _RBTreeIterator(pNode node)</span><br><span class="line">        : _node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node == it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_right) &#123;</span><br><span class="line">            <span class="comment">// 找到右子树的最左节点</span></span><br><span class="line">            _node = _node-&gt;_right;</span><br><span class="line">            <span class="keyword">while</span> (_node-&gt;_left) &#123;</span><br><span class="line">                _node = _node-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上回溯</span></span><br><span class="line">            pNode parent = _node-&gt;_parent;</span><br><span class="line">            <span class="keyword">while</span> (parent-&gt;_right == _node) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特殊情况：迭代器在根节点位置，并且根节点无右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (_node-&gt;_right != parent) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="comment">// 迭代器在head位置</span></span><br><span class="line">        <span class="comment">// _node-&gt;color == RED 排除根节点</span></span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_parent-&gt;_parent == _node &amp;&amp; _node-&gt;_color == RED) &#123;</span><br><span class="line">            _node = _node-&gt;_right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_node-&gt;_left) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">            _node = _node-&gt;_left;</span><br><span class="line">            <span class="keyword">while</span> (_node-&gt;_right) &#123;</span><br><span class="line">                _node = _node-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上回溯</span></span><br><span class="line">            pNode parent = _node-&gt;_parent;</span><br><span class="line">            <span class="keyword">while</span> (parent-&gt;_left == _node) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            _node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树结构：为了后续实现关联式容器简单，红黑树的实现中增加一个头结点</span></span><br><span class="line"><span class="comment">// 因为跟节点必须为黑色，为了与根节点进行区分，将头结点给成黑色</span></span><br><span class="line"><span class="comment">// 并且让头结点的Parent指向红黑树的根节点，Left指向红黑树中最小的节点，Right指向红黑树中最大的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RBTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RBTNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;V&gt; iterator;</span><br><span class="line"></span><br><span class="line">    RBTree(<span class="keyword">const</span> V&amp; data = V()) &#123;</span><br><span class="line">        _header = <span class="keyword">new</span> Node(data);</span><br><span class="line">        _header-&gt;_left = _header;</span><br><span class="line">        _header-&gt;_right = _header;</span><br><span class="line">        _header-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_header-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> V&amp; data)</span> </span>&#123;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">if</span> (_header == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kov(cur-&gt;_data) &lt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> iterator(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> V&amp; data) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是空树</span></span><br><span class="line">        <span class="keyword">if</span> (_header-&gt;_parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pNode root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="comment">// 根节点的颜色必须为黑的</span></span><br><span class="line">            root-&gt;_color = BLACK;</span><br><span class="line">            root-&gt;_parent = _header;</span><br><span class="line"></span><br><span class="line">            _header-&gt;_left = root;</span><br><span class="line">            _header-&gt;_right = root;</span><br><span class="line">            _header-&gt;_parent = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(root), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根节点开始搜索合适的叶子</span></span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kov(cur-&gt;_data) &lt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        pNode newNode = cur;</span><br><span class="line">        <span class="keyword">if</span> (kov(parent-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整：修改颜色，旋转</span></span><br><span class="line">        <span class="comment">// cur和parent的颜色都为红色, 需要调整</span></span><br><span class="line">        <span class="keyword">while</span> (cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED) &#123;</span><br><span class="line">            pNode parent = cur-&gt;_parent;</span><br><span class="line">            pNode gParent = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                pNode uncle = gParent-&gt;_right;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_color == RED) &#123;</span><br><span class="line">                    <span class="comment">// 更新颜色</span></span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="comment">// 向上继续更新</span></span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// u不存在/u存在且为黑</span></span><br><span class="line">                    <span class="comment">// 判断是否存在双旋的场景</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_right == cur) &#123;</span><br><span class="line">                        RotateLeft(parent);</span><br><span class="line">                        <span class="built_in">std</span>::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 右旋</span></span><br><span class="line">                    RotateRight(gParent);</span><br><span class="line">                    <span class="comment">// 修改颜色</span></span><br><span class="line">                    parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="comment">// 结束调整</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNode uncle = gParent-&gt;_left;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_color == RED) &#123;</span><br><span class="line">                    uncle-&gt;_color = parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// u不存在/u存在且为黑</span></span><br><span class="line">                    <span class="comment">// 判断是否存在双旋的场景</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                        RotateRight(parent);</span><br><span class="line">                        <span class="built_in">std</span>::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    RotateLeft(gParent);</span><br><span class="line">                    parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点的颜色必须为黑色</span></span><br><span class="line">        _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整之后，根可能发生变化</span></span><br><span class="line">        _header-&gt;_left = leftMost();</span><br><span class="line">        _header-&gt;_right = rightMost();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(newNode), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">leftMost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;_left) &#123;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">rightMost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;_right) &#123;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateRight</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subL = parent-&gt;_left;</span><br><span class="line">        pNode subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subL-&gt;_right = parent;</span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        pNode gParent = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        <span class="keyword">if</span> (subLR) &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _header-&gt;_parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                gParent-&gt;_left = subL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gParent-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = gParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _header-&gt;_parent = subL;</span><br><span class="line">            subL-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateLeft</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subR = parent-&gt;_right;</span><br><span class="line">        pNode subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        <span class="keyword">if</span> (subRL) &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _header-&gt;_parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_parent-&gt;_left == parent) &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_left = subR;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = parent-&gt;_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _header-&gt;_parent = subR;</span><br><span class="line">            subR-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_header-&gt;_parent);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 红黑树的检测分为两步：</span></span><br><span class="line">        <span class="comment">// 1. 检测其是否满足二叉搜索树(中序遍历是否为有序序列)</span></span><br><span class="line">        <span class="comment">// 2. 检测其是否满足红黑树的性质</span></span><br><span class="line">        pNode root = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_color == RED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计一条路径黑色的数量</span></span><br><span class="line">        <span class="keyword">int</span> blackCount = <span class="number">0</span>;</span><br><span class="line">        pNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_color == BLACK) &#123;</span><br><span class="line">                ++blackCount;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">return</span> _isRBTree(root, blackCount, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _isRBTree(pNode root, <span class="keyword">int</span> blackCount, <span class="keyword">int</span> curBlackCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curBlackCount != blackCount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加黑节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_color == BLACK) &#123;</span><br><span class="line">            ++curBlackCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有红色连续</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_parent-&gt;_color == RED &amp;&amp; root-&gt;_color == RED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _isRBTree(root-&gt;_left, blackCount, curBlackCount)</span><br><span class="line">            &amp;&amp; _isRBTree(root-&gt;_right, blackCount, curBlackCount);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RBTree.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MapKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    <span class="comment">// typedef _RBTreeIterator&lt;pair&lt;K, V&gt;&gt; iterator;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Find(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; ret = _rbt.Insert(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">        <span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTree&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SetKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedef typename RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span></span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;K&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Find(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> K&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于AVL树不适用一些经常修改的结构，这是因为AVL树追求绝对的平衡，所以就有了一种近似平衡的二叉搜索树红黑树，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。&lt;/p&gt;&lt;p&gt;红黑树在每个结点上
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="红黑树" scheme="https://Ranjiahao.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="map/set" scheme="https://Ranjiahao.github.io/tags/map-set/"/>
    
  </entry>
  
  <entry>
    <title>AVL树模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/18/AVL%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/18/AVL%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>AVL树是一种高度平衡的二叉树，它改进了普通二叉搜索树在极端情况下会退化成单支效率低下的问题，AVL树中在每个节点中加入了平衡因子，使得左右子树的高度差不超过1，这样可以使得高度保持在log n，从而避免的极端情况下的查找效率低下问题，但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修改，就不太适合</p><p>插入：<br>首先根据二叉搜索树的规则插入新的节点，然后调整平衡因子即可<br>如果新节点插入到Parent的左侧，则Parent的平衡因子-1<br>如果新节点插入到Parent的右侧，则Parent的平衡因子+1<br>这时Parent的平衡因子有三种情况-1、0、1<br>若为0，则说明之前的平衡因子为-1/1，插入后调整为0，则插入成功返回即可<br>若为-1/1，则说明之前的平衡因子为0，插入后变为-1/1，则AVL树高度增加需要向上寻找，看看有没有别的平衡被破坏的节点<br>若为2，则说明违反了AVL树的性质，需要旋转处理</p><p>旋转：根据节点插入位置的不同，AVL树的旋转分为四种</p><ol><li>Parent的平衡因子为2，说明Parent的右子树高，设Parent的右子树的根为SubR<br>当SubR的平衡因子为1时，执行左单旋<br>当SubR的平衡因子为-1时，执行右左双旋</li><li>Parent的平衡因子为-2，说明Parent的左子树高，设Parent的左子树的根为SubL<br>当SubL的平衡因子为-1是，执行右单旋<br>当SubL的平衡因子为1时，执行左右双旋</li></ol><p>旋转完成后，原Parent为根的子树个高度降低，已经平衡，不需要再向上更新</p><p>单旋：</p><p><img src="img1.png" alt="img1"></p><p>双旋：</p><p><img src="img2.png" alt="img2"></p><p><img src="img3.png" alt="img3"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVLTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    AVLNode(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _parent(<span class="literal">nullptr</span>)</span><br><span class="line">        , _bf(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;K, V&gt; _data;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _left;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _right;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _parent;</span><br><span class="line">    <span class="keyword">int</span> _bf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> AVLNode&lt;K, V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data.first == data.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data.first &gt; data.first) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_data.first &gt; data.first) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">            <span class="comment">// 更新平衡因子</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_right == cur) &#123;</span><br><span class="line">                ++parent-&gt;_bf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --parent-&gt;_bf;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 向上继续更新</span></span><br><span class="line">                cur = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 左边的左边高</span></span><br><span class="line">                    RotateRight(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右边的右边高</span></span><br><span class="line">                    RotateLeft(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右边的左边高</span></span><br><span class="line">                    <span class="keyword">int</span> bf = cur-&gt;_left-&gt;_bf;</span><br><span class="line">                    RotateRight(cur);</span><br><span class="line">                    RotateLeft(parent);</span><br><span class="line">                    <span class="keyword">if</span> (bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                        cur-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>) &#123;</span><br><span class="line">                        parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// cur-&gt;_left 没有子树</span></span><br><span class="line">                        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 左边的右边高</span></span><br><span class="line">                    <span class="keyword">int</span> bf = cur-&gt;_right-&gt;_bf;</span><br><span class="line">                    RotateLeft(cur);</span><br><span class="line">                    RotateRight(parent);</span><br><span class="line">                    <span class="keyword">if</span> (bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                        parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>) &#123;</span><br><span class="line">                        cur-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// cur-&gt;_right 没有子树</span></span><br><span class="line">                        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateRight</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subL = parent-&gt;_left;</span><br><span class="line">        pNode subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subL-&gt;_right = parent;</span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        pNode gParent = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        <span class="keyword">if</span> (subLR) &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                gParent-&gt;_left = subL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gParent-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = gParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _root = subL;</span><br><span class="line">            subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新平衡因子</span></span><br><span class="line">        subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateLeft</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subR = parent-&gt;_right;</span><br><span class="line">        pNode subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        <span class="keyword">if</span> (subRL) &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_parent-&gt;_left == parent) &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_left = subR;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = parent-&gt;_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _root = subR;</span><br><span class="line">            subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新平衡因子</span></span><br><span class="line">        subR-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftH = Height(root-&gt;_left);</span><br><span class="line">        <span class="keyword">int</span> rightH = Height(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> leftH &gt; rightH ? leftH + <span class="number">1</span> : rightH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalance(_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _isBalance(pNode root) &#123;</span><br><span class="line">    <span class="comment">// 1. 验证其为二叉搜索树</span></span><br><span class="line">    <span class="comment">//     如果中序遍历可得到一个有序的序列，就说明为二叉搜索树</span></span><br><span class="line">    <span class="comment">// 2. 验证其为平衡树</span></span><br><span class="line">    <span class="comment">//     每个节点子树高度差的绝对值不超过1(注意节点中如果没有平衡因子)</span></span><br><span class="line">    <span class="comment">//     节点的平衡因子是否计算正确</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightH = Height(root-&gt;_right);</span><br><span class="line">        <span class="keyword">int</span> leftH = Height(root-&gt;_left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_bf != rightH - leftH) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">"不平衡"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"平衡因子:"</span> &lt;&lt; root-&gt;_bf &lt;&lt; <span class="string">"高度差："</span> &lt;&lt; rightH - leftH &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(root-&gt;_bf) &lt; <span class="number">2</span></span><br><span class="line">            &amp;&amp; _isBalance(root-&gt;_left)</span><br><span class="line">            &amp;&amp; _isBalance(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNode _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AVL树是一种高度平衡的二叉树，它改进了普通二叉搜索树在极端情况下会退化成单支效率低下的问题，AVL树中在每个节点中加入了平衡因子，使得左右子树的高度差不超过1，这样可以使得高度保持在log n，从而避免的极端情况下的查找效率低下问题，但是如果要对AVL树做一些结构修改的操
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="AVL树" scheme="https://Ranjiahao.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-16T16:00:00.000Z</published>
    <updated>2020-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树是一种特殊的二叉树，查找、插入时间复杂度较低O(log n)，它有这几个性质：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值</li><li>任意节点的左、右子树也分别为二叉搜索树</li><li>空树也是二叉搜索树</li></ul><p>查找：<br>由于它的这些性质，所以在查找的时候从根节点开始查找<br>在二叉搜索树b中查找x的过程为：<br>若b是空树，则搜索失败<br>若x等于b节点数据域的值，则查找成功<br>若x小于b节点数据域的值，则搜索左子树<br>若x大于b节点数据域的值，则搜索右子树<br>由于搜索的长度为树的高度，所以在一个平衡的情况下搜索效率为O(log n)</p><p>插入：<br>向一个二叉搜索树b中插入一个节点s的算法，过程为：<br>若树是空树，则将s所指节点作为根节点插入<br>若s-&gt;data等于b的根节点的数据域之值，则返回<br>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中<br>若s-&gt;data大于b的根节点的数据域之值，则把s所指节点插入到右子树中<br>同样插入效率为O(log n)</p><p>删除：</p><ol><li>若要删除的结点无孩子结点，直接删除即可</li><li>若要删除的结点只有左孩子结点，使被删除节点的双亲结点指向被删除节点的左孩子结点</li><li>若要删除的结点只有右孩子结点，使被删除节点的双亲结点指向被删除结点的右孩子结点</li><li>若要删除的结点有左、右孩子结点，在它的右子树中寻找关键码最小或在左子树寻找关键码最大的节点，用它的值填补到被删除节点中，效率O(log n)</li></ol><p>但这这样存在一些问题，当二叉搜索树退化为左右单支时，它的平均比较次数为n/2，这样二叉搜索树性能就失去了，所以我们可以通过别的办法来改进，如AVL树、红黑树…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BSTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    BSTNode(<span class="keyword">const</span> T&amp; data = T())</span><br><span class="line">        : _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _data(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    BSTNode&lt;T&gt;* _left;</span><br><span class="line">    BSTNode&lt;T&gt;* _right;</span><br><span class="line">    T _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> BSTNode&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    BSTree()</span><br><span class="line">        : _root(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    BSTree(<span class="keyword">const</span> BSTree&lt;T&gt;&amp; bst) &#123;</span><br><span class="line">        _root = Copy(bst._root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTree&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BSTree&lt;T&gt;&amp; bst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;bst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_root) &#123;</span><br><span class="line">                destroy(_root);</span><br><span class="line">            &#125;</span><br><span class="line">            _root = Copy(bst._root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~BSTree() &#123;</span><br><span class="line">        destroy(_root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入新的节点</span></span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="comment">// 判断插入的位置</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_data &gt; data) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="comment">// 找到了要删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点右为空</span></span><br><span class="line">                    <span class="keyword">if</span> (cur != _root) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                            parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _root = cur-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                    cur = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点左为空</span></span><br><span class="line">                    <span class="keyword">if</span> (cur != _root) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                            parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _root = cur-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                    cur = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点左右都不为空</span></span><br><span class="line">                    <span class="comment">// 寻找左子树最大节点，或右子树最小节点替换</span></span><br><span class="line">                    pNode leftMax = cur-&gt;_left;</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    <span class="comment">// 寻找最右节点</span></span><br><span class="line">                    <span class="keyword">while</span> (leftMax-&gt;_right) &#123;</span><br><span class="line">                        parent = leftMax;</span><br><span class="line">                        leftMax = leftMax-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 交换值 cur&lt;--&gt;左子树最右节点</span></span><br><span class="line">                    cur-&gt;_data = leftMax-&gt;_data;</span><br><span class="line">                    <span class="comment">// 删除最右节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_left == leftMax) &#123;</span><br><span class="line">                        <span class="comment">// 左子树的最右节点为左子树的根</span></span><br><span class="line">                        parent-&gt;_left = leftMax-&gt;_left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左子树的最右节点不为左子树的根</span></span><br><span class="line">                        parent-&gt;_right = leftMax-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> leftMax;</span><br><span class="line">                    leftMax = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">pNode <span class="title">Copy</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode newRoot = <span class="keyword">new</span> Node(root-&gt;_data);</span><br><span class="line">        newRoot-&gt;_left = Copy(root-&gt;_left);</span><br><span class="line">        newRoot-&gt;_right = Copy(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            destroy(root-&gt;_left);</span><br><span class="line">            destroy(root-&gt;_right);</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNode _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉搜索树是一种特殊的二叉树，查找、插入时间复杂度较低O(log n)，它有这几个性质：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值&lt;/li&gt;&lt;li&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值&lt;/l
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="二叉搜索树" scheme="https://Ranjiahao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型与及多路复用详解</title>
    <link href="https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2020-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五种io模型"><a class="markdownIt-Anchor" href="#五种io模型"></a> 五种IO模型</h1><ul><li><p>阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都是阻塞方式，流程简单，但是任务处理效率低，无法充分利用资源</p></li><li><p>非阻塞IO：若内核还未将数据准备好，系统调用返回EWOULDBLOCK错误码，往往需要循环的方式反复尝试读写文件描述符，对资源的利用充分，但IO不够实时，且对CPU来说是较大的浪费<br>可以通过<code>int fcntl(int fd, int cmd, ... /* arg */ );</code>函数设置<code>int fl = fcntl(fd, F_GETFL);fcntl(fd, F_SETFL, fl | O_NONBLOCK)</code></p></li><li><p>信号驱动IO：建立SIGIO的信号处理程序，内核将数据准备好的时候，使用SIGIO信号通知应用程序进行IO操作，资源利用充分，比非阻塞IO实时</p></li><li><p>多路转接IO：发起多路转接IO，将需要等待的文件描述符添加监控，然后由内核轮询遍历，进程一直等待任意一个文件描述符就绪，然后进行IO操作</p></li><li><p>异步IO：发起异步IO系统调用，直接返回，然后由内核等待，并由内核自动拷贝数据，拷贝完成后通知应用程序，对资源的利用最为充分，且效率最高</p></li><li><p>这五种IO模型处理的效率逐渐增加，对资源(cpu)的利用也更加充分，但是流程也越来越复杂</p></li></ul><h1 id="多路转接"><a class="markdownIt-Anchor" href="#多路转接"></a> 多路转接</h1><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>系统调用<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>nfds：需要监视的最大的文件描述符值+1<br>readfds,writefds,exceptfds：分别对应需要检测的可读、可写、异常文件描述符集合<br>timeout：用来设置select()的等待时间。NULL表示select将一直被阻塞，直到某个文件描述符上发生了事件，0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生，特定的时间值：如果在指定的时间段里没有事件发生，select将超时返回<br>执行成功则返回文件描述词状态已改变的个数，如果返回0代表在描述词状态改变前已超过timeout时间，没有返回，当有错误发生时则返回-1，错误原因存于errno，此时参数readfds，writefds, exceptfds和timeout的值变成不可预测</p><p><strong>fd_set结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE        1024</span></span><br><span class="line"><span class="comment">// select.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> __fd_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NFDBITS   (8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>这个结构就是一个整数数组构成的位图，位图中对应的位来表示要监视的文件描述符，提供了一组操作fd_set的接口来方便的操作位图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来清除描述词组set中相关fd 的位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 用来测试描述词组set中相关fd 的位是否为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来设置描述词组set中相关fd的位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;         <span class="comment">// 用来清除描述词组set的全部位</span></span><br></pre></td></tr></table></figure><p><strong>timeval结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>    </span></span><br><span class="line"><span class="class">  &#123;</span>    </span><br><span class="line">    <span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds.  */</span>    </span><br><span class="line">    <span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds.  */</span>                     </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>定义指定监控事件的描述符集合（即位图），初始化集合后，将需要监控指定事件的描述符添加到指定事件（可读、可写、异常）的描述符集合中<br>select将描述符集合拷贝到内核当中，对集合中所有描述符进行轮询判断，当描述符就绪或者等待超时后就调用返回，返回后的集合中只剩下已就绪的描述符（未就绪会在位图中置为0）<br>用户通过遍历描述符，判断哪些描述符还在集合中，就可以知道哪些描述符已经就绪了，开始处理对应的IO事件</p><p>读就绪：socket内核中接收缓冲区中的字节数大于等于低水位标记SO_RCVLOWAT（默认1字节），此时可以无阻塞的读该文件描述符，并且返回值大于0；socket TCP通信中，对端关闭连接，此时对该socket读，则返回0；监听的socket上有新的连接请求；socket上有未处理的错误<br>写就绪：socket内核中发送缓冲区中的字节数（发送缓冲区的空闲位置大小）大于等于低水位标记SO_SNDLOWAT，此时可以无阻塞的写，并且返回值大于0；socket的写操作被关闭（close或者shutdown）对一个写操作被关闭的socket进行写操作，会触发SIGPIPE信号；socket使用非阻塞connect连接成功或失败之后；socket上有未读取的错误;<br>异常就绪：socket上收到带外数据</p><p><strong>缺点</strong></p><ol><li>select能监控的最大描述符有限，由宏__FD_SETSIZE决定，默认是1024个</li><li>select会将集合拷贝到内核中轮询遍历判断描述符是否就绪，效率会随着描述符的增多而越来越低</li><li>select监控完毕后返回的集合中只有已就绪的描述符，移除了未就绪的描述符，所以每次监控都必须要重新将描述符加入集合中，重新拷贝到内核</li><li>select返回的集合是一个位图而不是真正的描述符数组，所以需要用户遍历判断哪个描述符在集合中才能确认其是否就绪</li></ol><p><strong>优点</strong></p><ol><li>select遵循posix标准，可以跨平台移植</li><li>select的超时等待时间较为精确，可以精细到微秒</li></ol><p>tcp_select服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc</a></p><h2 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h2><p>系统调用接口<code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><br>fds：poll函数监听的结构列表，包含了三部分内容，文件描述符、监听的事件集合、返回的事件集合<br>nfds：表示fds数组的长度<br>timeout：表示poll函数的超时时间，单位是毫秒(ms)<br>返回值小于0，表示出错；返回值等于0，表示poll函数等待超时；返回值大于0，表示poll由于监听的文件描述符就绪而返回</p><p><strong>pollfd结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events和revents取值：POLLIN可读、POLLOUT可写</p><p><strong>原理</strong></p><ul><li><p>定义pollfd结构体数组，将需要监控的描述符以及监控的事件信息添加进去</p></li><li><p>发起监控调用poll，将数组中的数据拷贝到内核当中进行轮询遍历监控，当有描述符就绪或者等待超时后返回，返回时将已就绪的事件添加进pollfd结构体中的revents中（如果没就绪，则为0）</p></li><li><p>监控调用返回后，遍历pollfd数组中的每一个节点的revents，根据对应的就绪时间进行相应操作</p></li></ul><p><strong>缺点</strong></p><ol><li><p>每次调用poll都需要把大量的pollfd结构从用户态拷贝到内核中，在内核中轮询判断描述符是否就绪，效率会随着描述符的增加而下降</p></li><li><p>每次调用返回后需要用户自行判断revents才能知道是哪个描述符就绪了哪个事件</p></li><li><p>无法跨平台移植</p></li><li><p>超时等待时间只精确到毫秒</p></li></ol><p><strong>优点</strong></p><ol><li>poll通过描述符事件结构体的方式将select的描述符集合的操作流程合并在一起，简化了操作</li><li>poll并没有最大数量限制（但是数量过大后性能也是会下降）</li><li>poll每次监控不需要重新定义事件结构</li></ol><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><p>系统调用<br><code>int epoll_create(int size);</code>创建一个epoll的句柄<br>自从linux2.6.8之后，size参数是被忽略的，用完之后，必须调用close()关闭</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>注册要监听的事件类型<br>epfd：epoll_create返回的句柄<br>op：EPOLL_CTL_ADD，注册新的fd到epfd中；EPOLL_CTL_MOD，修改已经注册的fd的监听事件；EPOLL_CTL_DEL，从epfd中删除一个fd；<br>fd：需要监听的fd<br>event：告诉内核需要监听什么事</p><p><strong>epoll_event结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;    <span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure><p>events取值：EPOLLIN表示对应的文件描述符可以读 (包括对端SOCKET正常关闭)；EPOLLOUT表示对应的文件描述符可以写；EPOLLET将EPOLL设为边缘触发，一般将data.fd设置为需要监听的fd</p><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code>收集在epoll监控的事件中已经发送的事件（异步阻塞）<br>events：分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）<br>maxevents：告诉内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size参数<br>timeout：超时时间（毫秒，0会立即返回，-1是永久阻塞)<br>如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时，返回小于0表示函数失败</p><p><strong>原理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件，这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是log(n)，其中n为树的高度)而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当响应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback，它会将发生的事件添加到rdlist双链表中，在epoll中，对于每一个事件，都会建立一个epitem结构体，当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可，如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户，这个操作的时间复杂度是O(1)</p><p><strong>优点</strong></p><ol><li>文件描述符数目无上限</li><li>数据拷贝轻量，只在调用EPOLL_CTL_ADD将文件描述符结构拷贝到内核中</li><li>事件回调机制，避免使用遍历，而是使用回调函数的方式，将就绪的文件描述符结构加入到就绪队列中，epoll_wait返回直接访问就绪队列就知道哪些文件描述符就绪，这个操作时间复杂度O(1)即使文件描述<br>符数目很多, 效率也不会受到影响</li></ol><p><strong>缺点</strong></p><ol><li>无法跨平台移植</li><li>超时等待时间只精确到毫秒</li><li>在活动连接较多的时候，由于会大量触发回调函数，所以此时epoll的效率未必会select和poll高，所以epoll适用于连接数量多，但是活动连接少的情况</li></ol><p>应用场景：对于多连接，且多连接中只有一部分连接比较活跃时，比较适合使用epoll</p><h3 id="lt模式与et模式"><a class="markdownIt-Anchor" href="#lt模式与et模式"></a> LT模式与ET模式</h3><p>epoll默认状态下就是LT工作模式，只要接收缓冲区中数据大于低水位标记（可读），或者发送缓冲区中剩余空间大于低水位标记（可写）就会一直触发事件，支持阻塞读写和非阻塞读写，LT模式简单稳定<br>tcp_epoll_lt服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc</a></p><p>ET模式，只有新数据到来是触发可读时间，或者剩余空间大小从无到有的时候才会触发事件，只支持非阻塞的读写<br>tcp_epoll_et服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc</a><br>使用ET能够减少epoll触发的次数，但是代价就是必须一次把所有的数据都处理完，代码复杂，还有一种场景适合ET模式使用，如果我们需要接受一条数据，但是这条数据因为某种问题导致其发送不完整，需要分批发送。所以此时的缓冲区中数据只有部分，如果此时将其取出，则会增加维护数据的开销，正确的做法应该是等待后续数据到达后将其补全，再一次性取出。但是如果此时使用的是LT模式，就会因为缓冲区不为空而一直触发事件，所以这种情况下使用ET会比较好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;五种io模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#五种io模型&quot;&gt;&lt;/a&gt; 五种IO模型&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="多路转接" scheme="https://Ranjiahao.github.io/tags/%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://ranjiahao.github.io/2020/07/07/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ranjiahao.github.io/2020/07/07/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2020-07-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>有连接：只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费，应用程序可以不用顾虑提供尽职服务的IP网络上可能发生的各种问题，依然可以转发数据</li><li>可靠：检验和、序列号、确认应答、超时重传、连接管理</li><li>避免大量丢包：滑动窗口机制、流量控制、拥塞控制</li><li>提高性能：延时确认应答、捎带应答、快速重传</li><li>面向字节流：创建一个TCP的socket，同时在内核中创建一个发送缓冲区和一个接收缓冲区。发送数据时，tcp根据头部将除头部外的数据写入发送缓冲区，如果发送的字节数太长，会被拆分成多个TCP的数据包发出，如果发送的字节数太短，就会先在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的时机发送出去。接收数据时，数据也是从网卡驱动程序到达内核的接收缓冲区，然后应用程序可以调用read从接收缓冲区拿数据。缺陷：应用层数据粘包，可以采用特殊字符间隔(如http，数据中如果有这个特殊字符就要进行转义)、数据定长(保证每次都按固定大小读取即可，可能需要补位)、在应用层协议头中定义数据长度方式来解决(如http、udp)</li></ul><p>协议格式<br><img src="img1.png" alt="img1"><br>32位序列号：每发送一次数据，序列号就会累加一次该数据的字节数大小，序列号是由随机数作为初始值，通过SYN包传递给主机（SYN和FIN包并不携带数据，但会作为一个字节增加对应的序号）<br>32位确认应答号：下一次应该收到数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都被正常接收<br>4位数据偏移：可也看作TCP首部长度，该字段长4位，单位为4字节，不包括选项的话，数据偏移量最小设置5，说明TCP首部是5*4=20位，最大15*4=60位<br>4位保留位：一般全0，为了以后扩展使用<br>8位置控制位：<br><img src="img2.png" alt="img2"><br>CWR：用于IP首部ECN字段，ECE标志为1时，则通知对方已将拥塞窗口缩小<br>ECE：用于IP首部ECN字段，收到IP首部ECN为1时，则置为1，通知通信对方，发送网络拥塞<br>URG：紧急指针是否有效<br>ACK：确认号是否有效<br>PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走，为0时则先进行缓存<br>RST：出现异常，重新建立连接，复位报文段<br>SYN：请求建立连接，同步报文段<br>FIN：通知对方，本端关闭，结束报文段<br>16位窗口大小：通知从相同TCP首部的确认应答号所指位置开始能接收的数据大小，如果窗口为0，则表示可以发送窗口探测，以了解最新窗口大小，这个数据必须是1个字节，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位<br>16位校验和：和UDP一样还需要校验伪首部，区别在于TCP校验和无法关闭<br><img src="img3.png" alt="img3"><br>16位紧急指针：在URG为1时才有效，指向紧急数据末尾，也就是说从数据首位到紧急指针所指向的位置为紧急数据。一般在暂时中断通信或中断通信的情况下使用，此外紧急指针也用作表示数据流分段的标志<br>选项：含有最大段长度情况、窗口扩大因子、时间戳字段（区分新老序列号）等</p><h1 id="确认应答机制"><a class="markdownIt-Anchor" href="#确认应答机制"></a> 确认应答机制</h1><p>TCP将每个字节的数据都进行了编号（初始值是在建立连接以后由随机数生成，计算则是每一字节加一）即为序列号，每一个ACK都带有对应的确认序列号，如果确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大，在一定时间没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。也可能对方已经收到数据只是返回的确认应答在途中丢失，这种情况下也会进行重发，接收端在发现有相同数据到达时会丢弃数据<br><img src="img4.png" alt="img4"><br>数据长度并未写入TCP首部，通过IP首部中数据包长度-IP首部长度-TCP首部长度</p><h1 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h1><p>在重发数据之前，等待确认应答到来的那个特定时间间隔，如过超过了这个时间仍未收到确认应答，发送端将进行数据重发。TCP在每次发包时都会计算往返时间及其偏差，将这个往返时间和偏差相加，超时重传的时间就是比这个总和要稍大一点的值<br>在BSD的Unix以及Windows系统中，超时都以0.5s为单位进行控制，因此超时重传时间都是0.5s的整数倍，偏差最小值也是0.5s，所以最小重发时间至少为1s，不过，由于最初的数据包还不知道往返时间，所以重发时间一般设置为6s左右，若数据被重发以后还是收不到确认应答，则再次重发，等待确认应答的时间将会以2倍、4倍的指数函数延长，当达到一定重发次数后，就会判断为网络或对端主机异常，强制关闭连接</p><h1 id="连接管理机制"><a class="markdownIt-Anchor" href="#连接管理机制"></a> 连接管理机制</h1><p>TCP利用首部控制字段来管理TCP连接<br><img src="img5.png" alt="img5"><br>在建立TCP连接的同时，也可以确定发送数据包的单位（MSS最大消息长度）两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后会在两者之间选择一个较小的值使用<br>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位</p><h2 id="保活机制"><a class="markdownIt-Anchor" href="#保活机制"></a> 保活机制</h2><blockquote><p>sysctl -a | grep keepalive<br>默认：通信双方7200s没有数据往来，则每隔75s发送一个保活探测数据报，要求对方进行响应<br>若连续9次没有得到响应，则认为连接断开，并将socket状态置为CLOSE_WAIT</p></blockquote><h2 id="三次握手四次挥手"><a class="markdownIt-Anchor" href="#三次握手四次挥手"></a> 三次握手/四次挥手</h2><p>三次握手：客户端通过向服务器端发送一个SYN来创建一个主动打开，并进入状态SYN_SENT，客户端把这段连接的序号设定为随机数A，服务器端应当为一个合法的SYN回送一个SYN/ACK，并进入状态SYN_RCVD。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。最后，客户端再发送一个ACK，并进入状态ESTABLISHED，此时包的序号被设定为A+1，而ACK的确认码则为B+1。当服务端收到这个ACK的时候，就完成了三次握手，并进入状态ESTABLISHED<br>如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端会重发SYN-ACK(超时重传)，一定次数后还是没有收到ACK就会从未完成连接队列中删除套接字<br>三次握手原因：如果是两次握手，那么假设客户端第一次握手的SYN在网络中延迟了，超时后客户端未收到服务器的确认报文，就会重传一份SYN，然后服务端返回确认报文，TCP连接建立，接着若客户端最早发送的SYN到达服务端，服务端也回复ACK，然后又建立一个TCP连接，而且这个服务端一直在等待客户端数据造成大量资源开销。还有种情况是，若客户端收到SYN后，回复ACK丢包，也会造成多余的资源开销。同时三次握手可以满足两个条件：A确定B能收发信息，B确定A能收发信息<br>四次挥手：<br><img src="img6.png" alt="img6"><br>客户端主动调用close或shutdown(fd, WR)时，向服务器发送FIN，同时进入FIN_WAIT_1，表示客户端不再发送数据。服务器收到FIN包后立马回复ACK，同时进入CLOSE_WAIT状态。客户端收到ACK后进入FIN_WAIT_2。由于客户端只是关闭了写端，还能读取数据，服务端可以继续发送数据，在完成数据传送后，将发送一个FIN，同时进入LAST_ACK，表示服务端不再发送数据。客户端收到FIN后，回复ACK，同时进入TIME_WAIT，2MSL后进入CLOSED状态。服务端收到ACK后进入CLOSED状态<br>2MSL：cat /proc/sys/net/ipv4/tcp_fin_timeout 查看msl的值，Centos7上默认配置的值是60s，保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的）<br>同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN，这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK）</p><h3 id="time_waitclose_wait"><a class="markdownIt-Anchor" href="#time_waitclose_wait"></a> TIME_WAIT/CLOSE_WAIT</h3><p>TIME_WAIT是主动关闭方出现的状态，如果一台主机出现大量的TIME_WAIT，证明这台主机大量的主动关闭了连接，常见于爬虫服务器，可以调整TIME_WAIT时间，或者地址重用允许套接字绑定使用的中地址端口，使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示端口释放后立即就可以被再次使用<code>int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</code></p><p>CLOSE_WAIT是被动关闭方的状态，<br>一般来说服务器上出现大量的CLOSE_WAIT状态，原因就是服务器没有正确的关闭socket，导致四次挥手没有正确完成，只需要加上对应的close即可解决问题</p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，包的往返时间越长通信性能就越低，为解决这个问题，TCP引入了窗口这个概念，我们可以一次发送多条数据，并行压缩等待时间，也就是说，在发送了一个段以后不必一直等待确认应答，而是继续发送<br><img src="img7.png" alt="img7"><br>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，窗口内的数据即使没有收到确认应答也可以发送出去，发送端在收到窗口左沿第一段数据的确认应答后，窗口左沿才向右移动<br><img src="img8.png" alt="img8"></p><p><strong>丢包情况</strong><br>情况一：数据包抵达，ACK丢失<br><img src="img9.png" alt="img9"><br>这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认，如果第一条ack(下一个是1001)丢失，主机A收到第二条ack(下一个是2001)，则主机A就可以推断数据2001之前的数据都顺利到达不需要重发<br>情况二：数据包丢失<br><img src="img10.png" alt="img10"><br>如果1001~2000数据包丢失，则发送端会一直收到序号为1001的确认应答，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回，而发送端如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发，这个时候接收端收到了1001之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端其实之前就已经收到了（这里是选择重传协议，类似还有停止等待协议、回退n步协议），被放到了接收端操作系统内核的接收缓冲区中，这种机制叫快速重传</p><h1 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h1><p>接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送就会造成丢包，继而引起丢包重传等等一系列连锁反应，因此TCP支持根据接收端的处理能力来决定发送端的发送速度。接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，TCP首部中，又一个专门的字段用来通知窗口大小，接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端，这个字段的值越大，说明网络的吞吐量越高<br><img src="img11.png" alt="img11"></p><h1 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h1><p>虽然TCP有了滑动窗口机制，能够高效可靠的发送大量的数据，但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题，为了解决此问题，TCP引入慢启动机制，先发少量的数据，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据<br><img src="img12.png" alt="img12"><br>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念，将这个拥塞窗口的大小设置为1个数据段(1MSS)发送的数据，之后每一次确认应答，拥塞窗口就增加，在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后选择其中较小的值，发送比其还要小的数据量。不过，随着每次往返，阻塞窗口也会以1、2、4等指数函数的增长，可能会导致网络拥塞的发生，为了不增长的那么快，因此不能使拥塞窗口单纯加倍，所以引入了慢启动阈值的概念，只要拥塞窗口的值超出了这个阈值，每收到一次确认应答时，只允许以<br>（1个数据段字节数/拥塞窗口字节数）*1个数据段字节数的比例放大拥塞窗口<br><img src="img13.png" alt="img13"><br>TCP的通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口（实际已发送但未收到确认应答的数据量）一半的大小，由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为当时窗口大小的一半，然后将窗口大小设置为该启动阈值+3个数据段的大小（这种网络拥堵相较于超时重发要轻一些）</p><h1 id="nagle算法"><a class="markdownIt-Anchor" href="#nagle算法"></a> Nagle算法</h1><p>TCP中为了提高网络利用率，经常使用一个叫Nagle的算法。发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制，仅在满足下列任意一种条件下才能发送数据</p><ul><li>已发送的数据都已经收到确认应答时</li><li>可以发送最大段长度(MSS)的数据时</li></ul><h1 id="延时确认应答"><a class="markdownIt-Anchor" href="#延时确认应答"></a> 延时确认应答</h1><p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口，因为刚接收完数据，还没来得及从缓冲区取出。为此，可以在接收数据后不立即返回确认应答，而是延迟一段时间的机制。</p><ul><li>在没有收到2*最大段长度的数据（和操作系统有关）为止不做确认应答</li><li>其他情况下，最大延迟0.5s（有些操作系统为0.2s，时间越小、CPU的负荷会越高，性能也下降；反之时间越长可能导致超时重发，窗口在只有1个数据段时，性能也会下降）<br><img src="img14.png" alt="img14"></li></ul><h1 id="捎带应答"><a class="markdownIt-Anchor" href="#捎带应答"></a> 捎带应答</h1><p>在一些通信中TCP的确认应答和回执数据可以通过一个包发送，通过这种机制，可以使收发的数据量减少。接收数据以后如果立刻返回确认应答，就无法实现捎带应答，而是将所接收的数据传给应用处理生成返回数据以后再进行发送请求为止，延时确认应答时实现捎带应答的基础<br><img src="img15.png" alt="img15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;有连接：只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费，应用程序可以不用顾虑提供尽职服务的IP网络上可能发生的各种问题，依然可以转发数据&lt;/li&gt;&lt;li&gt;可靠：检验和、序列号、确认应答、超时重传、连接管理&lt;/li&gt;&lt;li&gt;避免大量丢包：滑动窗口机
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="TCP" scheme="https://Ranjiahao.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="https://ranjiahao.github.io/2020/07/06/UDP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ranjiahao.github.io/2020/07/06/UDP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>无连接：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，知道了对端的IP和端口就可以随时发送数据</li><li>不可靠：应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上，即使出现网络拥堵，UDP也无法进行流量控制等避免网络堵塞行为，此外，传输途中即使出现丢包，UDP也不负责重发，也不保证包序，需要应用层来保证这些，报头短，不需要可靠传输，所以传输速度快</li><li>面向数据报：应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并（如果发送端调用一次sendto，发送100个字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节；而不能循环调用10次recvfrom，每次接收10个字节）不能够灵活的控制读写数据的次数和数量</li><li>UDP没有真正意义上的发送缓冲区，sendto会直接将整个报文交给内核，由内核将数据传给网络层协议后进行后续的传输动作。UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃</li><li>全双工通信：UDP的socket既能读，也能写，udp在协议栈层面实现了广播功能：通过给一个ip地址发送数据，实现将数据发送到局域网所有主机</li><li>通常被用在包总量较少的通信（DNS、SNMP等）、即时通信、限定于LAN等特定网络中的应用通信、广播通信（广播，多播）RIP、DHCP等</li></ul><p>协议格式：<br><img src="img1.png" alt="img1"><br>16位包长度：限制了UPD报文总长度，包含包头在内不能超过64K，如果需要传输的数据超过64K，就要在应用层手动分包，多次发送，并在接收端手动拼装<br>16位校验和：数据传输过程中会产生误码，0可能变为1，1可能变为0，所以需要校验，以16比特为单位对报文进行取反求和，若进位则将进位加到校验和字段中。接收端接收到校验和后，执行相同的操作，得到检验和结果为全1，则数据未出错<br>由于UDP首部只有五元组中的源端口和目标端口，余下三项都在IP首部里，若其他三项信息被破坏则就可能导致该收包的应用收不到包，不该收到包的应用却收到了包，为了解决这个问题，就引入了伪首部的概念，此外IPv6的IP首部无校验和字段，TCP或UDP通过伪首部，得以对5元组进行校验，实现即使在IP首部并不可靠的情况下仍然能提供可靠的通信传输<br>伪首部：<br><img src="img2.png" alt="img2"><br>伪首部的明智之处在于，用它来计算校验和，我们能提供这些保护，而不必真的发送为报头本身的那些域。从而消除了用在伪真报头中的TCP的IP域的重复使用；避免了冗余和带宽的浪费。其缺点在于这种计算校验和的方法需要更多的时间和精力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;无连接：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，知道了对端的IP和端口就可以随时发送数据&lt;/li&gt;&lt;li&gt;不可靠：应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上，即使出现网络拥堵，UDP也无法进行流量控制等避免网络堵塞行为，此外，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="UDP" scheme="https://Ranjiahao.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>SocketAPI</title>
    <link href="https://ranjiahao.github.io/2020/07/03/SocketAPI/"/>
    <id>https://ranjiahao.github.io/2020/07/03/SocketAPI/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>套接字就是网络进程的进程ID，和普通进程ID不同，网络进程的ID是由运行这个进程的计算机IP地址和这个进程使用的端口所组成</p><h1 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h1><p><strong>通信流程</strong><br>服务端：</p><ol><li>创建套接字，在内核中创建socket结构体，通过这个结构体使进程和网卡建立联系</li><li>为套接字绑定地址信息，在内核创建的socket结构体中描述地址和协议信息，客户端需要知道服务端的地址，所以服务端地址必须固定</li><li>接收数据，从socket的接收缓冲区中接收数据</li><li>发送数据，将数据放在socket的发送缓存区中，操作系统选择合适的时机封装发送数据</li><li>关闭套接字，释放资源</li></ol><p>客户端：</p><ol><li>创建套接字</li><li>为套接字绑定地址信息，客户端不推荐主动绑定地址信息，让操作系统选择合适的地址和端口绑定，降低端口冲突概率</li><li>发送数据</li><li>接收数据</li><li>关闭套接字</li></ol><blockquote><p>创建/关闭socket<br><code>int socket(int domain, int type, int protocol);</code><br><code>int close(int fd);</code><br>domain: 地址域，确定本次通信协议版本的地址结构，AF_INET(IPV4网络协议)、AF_INET6(IPV6网络协议)、AF_UNIX(本地通信协议)<br>type: 套接字类型，SOCK_STREAM(数据流式套接字)SOCK_DGRAM(数据报式套接字)<br>protocol: 协议类型，0套接字类型默认协议，IPPROTO_TCP(6) IPPROTO_UDP(17)这些宏netinet/in.h中<br>成功返回文件描述符，失败返回-1，并设置错误码</p></blockquote><blockquote><p>绑定端口号(TCP/UDP服务器端)<br><code>int bind(int socket, const struct sockaddr *address, socklen_t address_len);</code><br>socket: socket函数返回的文件描述符<br>成功返回0，失败返回-1，并设置错误码<br>address&amp;address_len: 由于各种网络协议的地址格式并不相同，如sockaddr_in(IPV4)、sockaddr_in6(IPV6)、sockaddr_un(UNIX Domain Socket)等，这些结构体大小不一定相同，所以需要传入地址大小。但是前16位都是地址类型，socket API使用的时候需要强制转化成struct sockaddr类型传入函数，函数内部通过前16位确定协议类型，用不同处理方式处理信息内容<br>以ipv4为例：<br><img src="img1.png" alt="img1"></p></blockquote><p><strong>地址转换函数</strong><br>我们通常用点分十进制的字符串表示IP地址，以下函数可以在字符串表示和in_addr表示之间转换<br>点分十进制字符串转uint32_t：<br><code>in_addr_t inet_addr(const char *cp);</code><br><code>int inet_aton(const char *cp, struct in_addr *inp);</code><br><code>int inet_pton(int af, const char *src, void *dst);</code> 兼容IPV6<br>uinit32_t转点分十进制字符串：<br><code>char *inet_ntoa(struct in_addr in);</code><br><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 兼容IPV6<br>inet_ntoa函数，是把这个返回结果放到了静态存储区，不需要我们手动进行释放<br>但是连续调用两次会覆盖上一次的结果，不是线程安全的函数<br>多线程环境下，推荐使用inet_ntop</p><blockquote><p>接收/发送数据<br><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code><br>sockfd: socket操作句柄<br>buf: 用于接收从接收缓冲区取出的数据<br>len: 要接收的数据长度<br>flags: 默认为0，表示阻塞<br>src_addr: 用于接收发送方的地址信息<br>addrlen: 输入输出型参数，输入要获取的地址长度，输出实际获取的地址长度<br>成功返回实际接收到的数据字节长度，失败返回-1，并设置错误码<br><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code><br>sockfd: socket操作句柄<br>buf: 要往发送缓冲区发送的数据首地址<br>len: 要发送的数据长度<br>flags: 默认为0，表示阻塞<br>dest_addr: 接收方地址信息<br>addrlen: 地址信息长度<br>成功返回实际发送的数据字节长度，失败返回-1，并设置错误码</p></blockquote><h1 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h1><p><strong>通信流程</strong><br>服务端：</p><ol><li>创建套接字，在内核中创建socket结构体，通过这个结构体使进程和网卡建立联</li><li>为套接字绑定地址信息，在内核创建的socket结构体中描述地址和协议信息，客户端需要知道服务端的地址，所以服务端地址必须固定</li><li>进入listen状态，等待客户端连接，内核中维护了两个队列：未完成连接队列和已完成连接队列，队列的最大容量就为backlog，队列满了则新连接请求将会被丢弃。当客户端创建套接字对服务器端的监听套接字发起连接请求，此时内核创建新套接字，用五元组唯一标识，放入半连接接队列，当三次握手完成后，则将这个新的套接字放入全连接队列中</li><li>accept，从监听套接字的已完成连接队列中获取一个新套接字，通信由新的套接字完成</li><li>接收数据/发送数据，TCP协议提供全双工通信</li><li>关闭套接字，释放资源</li></ol><p>客户端：</p><ol><li>创建套接字</li><li>为套接字绑定地址信息，客户端不推荐主动绑定地址信息，让操作系统选择合适的地址和端口绑定，降低端口冲突概率</li><li>connect向服务器发起连接请求</li><li>发送数据/接收数据</li><li>关闭套接字</li></ol><blockquote><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>sockfd: socket操作句柄<br>addr: 对端地址<br>addrlen: 对端地址长度<br><code>int listen(int sockfd, int backlog);</code><br>sockfd: 监听套接字句柄<br>backlog: 最大并发连接数<br>成功返回0，失败返回-1，并设置错误码<br><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>sockfd: 监听套接字句柄<br>addr: 输出型参数获取客户端地址<br>addrlen: 输入输出型参数，输入调用者提供的缓冲区addr的长度以避免缓冲区溢出，输出客户端地址结构体的实际长度</p></blockquote><blockquote><p>接收/发送数据<br><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code><br><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code><br>由于tcp通信套接字中已经标识了五元组，因此不需要对方信息<br>recv没有数据阻塞，连接断开则返回0<br>send缓冲区满了则阻塞，连接断开触发SIGPIPE异常</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;套接字就是网络进程的进程ID，和普通进程ID不同，网络进程的ID是由运行这个进程的计算机IP地址和这个进程使用的端口所组成&lt;/p&gt;&lt;h1 id=&quot;udp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#udp&quot;&gt;&lt;/a&gt; UDP&lt;/h1&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="Socket" scheme="https://Ranjiahao.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="https://ranjiahao.github.io/2020/07/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://ranjiahao.github.io/2020/07/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议分层"><a class="markdownIt-Anchor" href="#协议分层"></a> 协议分层</h1><p>IOS提出OSI参考模型，帮助不同类型的主机实现数据传输，这一模型将通信协议中必要的功能分成了7层，这一模型中，每个分层都接收由它下一层所提供的特定服务，并为上一层提供服务，上下层之间交互所遵守的约定叫”接口“，同一层之间交互所遵守的约定叫”协议“，分层可以将每一个独立使用，即使系统中某些分层变化，也不影响整个系统，OSI参考模型通过每一层协议定义了每一层的作用，这7层自上向下分别是<br>应用层：针对特定应用的协议，文件传输、电子邮件、远程登录等协议<br>表示层：设备固有数据格式和网络标准数据格式的转换<br>会话层：通信管理，负责建立和断开通信连接，以及数据的分割等数据传输相关的管理<br>传输层：管理两个节点之间的数据传输（端与端之间的数据交流）<br>网络层：地址管理与路由选择，路由器工作在网路层<br>数据链路层：负责物理层面互连节点之间的通信和识别数据帧，交换机工作在数据链路层<br>物理层：负责0、1比特流与电压高低、关的闪灭之间的互换、界定连接器和网线规格，集线器工作在物理层<br>对于一台主机，它的操作系统内核实现了从传输层到物理层的内容<br>对于一台路由器，它实现了从网络层到物理层<br>对于一台交换机，它实现了从数据链路层到物理层<br>对于集线器，它只实现了物理层<br>但是并不绝对，很多交换机也实现了网络层的转发，很多路由器也实现了部分传输层的内容（比如端口转发）<br>由于OSI7层模型复杂又不实用，所以我们通常用TCP/IP四层模型，将应用层、表示层、会话层统称应用层，由于物理层考虑比较少，所以TCP/IP四层模型包括：应用层、传输层、网络层、链路层</p><h1 id="电路交换与分组交换"><a class="markdownIt-Anchor" href="#电路交换与分组交换"></a> 电路交换与分组交换</h1><p>电路交换中，交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接，因此计算机之间发送数据时，需要通过交换机与目标主机建立通信电路。由于一台计算机在收发信息时会独占整个电路，如果并发用户数超过交换机之间的通信线路数，就意味着通信无法实现。<br>为此，新的方法出现，让连接到通信电路的计算机将所要发送的数据分成多个数据包，在分组的首部写入发送端和接收端的地址，按照一定顺序排列后分别发送给路由器，路由器收到这个数据后缓存到自己的缓冲区队列中，然后转发给目标计算机，计算机与路由器，路由器与路由器之间通常只有一条共享线路，所以分组交换中通信速度和网络拥堵的情况有关，路由器的缓存饱和或溢出时，也可能发生分组数据丢失的情况</p><h1 id="mac地址"><a class="markdownIt-Anchor" href="#mac地址"></a> MAC地址</h1><p>MAC地址用来识别数据链路层中相连的节点，长度为48位，即6个字节，一般用16进制数字加上冒号的形式来表示，在网卡出厂时就确定了，不能修改，mac地址通常是唯一的，人们可以通过制造商识别号、制造商内部产品编号以及产品通用编号确保MAC地址的唯一性。（虚拟机中的mac地址不是真实的mac地址，可能会冲突，也有些网卡支持用户配置mac地址）虽然MAC地址中的制造商识别、产品编号、通用编号等信息在某种程度上有一定层次性，但是对于寻找地址并没有起到任何作用，所以不能算有层次的地址，虽然MAC地址是真正负责最终通信的地址，但是在实际寻址过程中，IP地址却必不可少</p><h1 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h1><p>MAC地址描述的是路途上的每一个区间的起点和终点。IP地址描述的是路途总体的起点和终点。<br>IP地址是IP协议中，用来标识网络中的唯一一台主机的地址。IP协议有两个版本IPv4，IPv6。IPv4中，IP地址是一个4字节的32位的整数(uint32_t)。IPv6中，IP地址是一个16字节的128位的整数(uint8_t ip[16])<br>两台主机通过网络来互相通信来发送数据时，就需要知道对方的IP地址，找到对方的主机，才能将数据发给它。所以在发送数据时，该数据包中还应包含两个IP地址，一个是目的IP，用于指明数据是发给谁的。一个是源IP，用于告诉对方该数据是哪台主机发送的，以便向其回发消息<br>当我们通过网络将数据发送给目的IP指定的主机时，目的主机要调用哪个进程对该数据进行处理，所以，此时还需要知道主机中处理数据的进程号。因此，需要引入端口号</p><h1 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h1><p>端口号是一个2字节16位的整数，用来标识一个主机中唯一的一个进程，IP地址 + 端口号能够标识网络上的某一台主机的某一个进程，当源主机通过网络将数据发送给目的主机后，调用该端口号指定的进程来对数据进行处理，在网络通信中，每条数据都包含一个五元组（源ip地址，源端口，目的ip地址，目的端口，协议类型）可以通过netstat -n查看<br>一个端口号只能绑定一个进程<br>一个进程可以绑定多个端口号，因为一个进程可以创建多个socket<br>0 - 1023: 知名端口号，HTTP，FTP，SSH等这些广为使用的应用层协议，他们的端口号都是固定的，命令cat /etc/services可查看<br>1024 - 65535: 操作系统动态分配的端口号，客户端程序的端口号，就是由操作系统从这个范围分配的</p><h1 id="网络字节序"><a class="markdownIt-Anchor" href="#网络字节序"></a> 网络字节序</h1><p>网络通信中源主机要通过内存将数据先发给源主机的网卡，然后发送到网络中，目的主机将网络中的数据项接收到目的主机的网卡上，再传入到目的主机的内存中，然后通过CPU对数据进行处理<br>发送主机将发送缓冲区的数据按低地址到高地址的顺序发出，接收主机从网络中也是按低地址到高地址的顺序将数据接收到接受缓冲区中<br>而数据在内存中的存储有大小端之分。如果在源主机的内存为小端，而目的主机以大端的形式来接受数据时，此时，就会导致数据错误<br>TCP/IP协议规定，网络数据流均采用大端，当发送消息时，先将数据放到发送缓冲区中，再将数据转换为大端字节序后发送，同理接收数据时，先将数据接收到接收缓冲区中，然后再将数据转换为主机字节序后读取</p><p>主机的存储模式和cpu的架构有关，我们常用的X86架构是小端模式<br>可以通过下面两种方法判断主机字节序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEnd1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (*(<span class="keyword">char</span>*)&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEnd2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">&#125;un;</span><br><span class="line">un.i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> un.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络字节序列与主机字节序列转换可以通过以下接口来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure><p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回<br>如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回</p><h1 id="传输流程"><a class="markdownIt-Anchor" href="#传输流程"></a> 传输流程</h1><p><img src="img1.png" alt="img1"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段，在网络层叫做数据报，在链路层叫做帧，应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部，称为封装，首部信息中包含了一些类似于首部有多长，载荷有多长，上层协议是什么等信息，数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的上层协议字段将数据交给对应的上层协议处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协议分层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#协议分层&quot;&gt;&lt;/a&gt; 协议分层&lt;/h1&gt;&lt;p&gt;IOS提出OSI参考模型，帮助不同类型的主机实现数据传输，这一模型将通信协议中必要的功能分成了7层，这一模型中，每个分层都接收由它下一
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="网络基础" scheme="https://Ranjiahao.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>线程的同步与互斥</title>
    <link href="https://ranjiahao.github.io/2020/06/30/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <id>https://ranjiahao.github.io/2020/06/30/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-06-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的互斥"><a class="markdownIt-Anchor" href="#线程的互斥"></a> 线程的互斥</h1><p>由于一个进程中的多个线程共享同一个虚拟地址空间。除了一些私有数据，其余大部分资源都是共享的，为了保证线程安全一次只允许一个线程对其访问，这些数据就称为临界资源，包含临界资源的代码段称为临界区。我们可以通过一把锁实现：当线程进入临界区执行时，不允许其他线程进入该临界区。如果多个线程同时要求执行临界区的代码，并且临界区没有线程在执行，那么只能允许一个线程进入该临界区，Linux上提供的这把锁叫互斥量</p><h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2><h3 id="初始化销毁互斥量"><a class="markdownIt-Anchor" href="#初始化销毁互斥量"></a> 初始化/销毁互斥量</h3><blockquote><p>静态初始化<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code><br>动态初始化<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code><br>mutex: 输出型参数，要初始化的互斥量<br>attr: 互斥锁属性一般设置NULL<br>成功返回0，失败返回错误码<br>销毁<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code><br>静态初始化的互斥量不需要销毁；不要销毁一个已经加锁的互斥量；已经销毁的互斥量，要确保后面不会有线程再尝试加锁</p></blockquote><h3 id="互斥量加锁和解锁"><a class="markdownIt-Anchor" href="#互斥量加锁和解锁"></a> 互斥量加锁和解锁</h3><blockquote><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>trylock非阻塞加锁<br><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code><br>成功返回0，失败返回错误码</p></blockquote><h3 id="互斥锁原理"><a class="markdownIt-Anchor" href="#互斥锁原理"></a> 互斥锁原理</h3><p>互斥锁本质是一个计数器，由于i<ins>或者</ins>i都不是原子操作，要保证互斥锁的操作为原子操作，大多数体系结构都提供了swap或exchange指令，该指令的作用是把寄存器和内存单元的数据相交换，只有一条指令，首先将0放入寄存器中，然后执行执行swap和内存单元的数据交换，然后判断这个数据是否为1，若为1，则此操作就是加锁操作。加锁后访问临界资源，此时寄存器中的数据为1，访问完成后，再次将数据交换回来，此时内存单元的数据就变为1，这一步叫解锁操作，加锁和解锁都是一步完成的，保证了原子性</p><h1 id="线程的同步"><a class="markdownIt-Anchor" href="#线程的同步"></a> 线程的同步</h1><p>使用互斥锁可以解决线程安全的问题，保证多线程下临界资源数据的安全性，但是仅仅互斥还是会存在一些问题，某个线程获取锁之后，发现数据没有就绪，又立刻释放锁，如果这个线程的优先级很高，那么就可能在释放了锁之后又立刻尝试获取锁，再立刻释放，依次类推，这样虽然并没有发生死锁，但是这个线程空转又占用了锁资源，导致其他线程很难获取到这个锁<br>linux可以通过条件变量和信号量两种方法来实现线程的同步</p><h2 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h2><p>当一个线程互斥的访问某个变量时，若不满足某一条件，则挂起等待，知道条件满足被唤醒</p><h3 id="初始化销毁条件变量"><a class="markdownIt-Anchor" href="#初始化销毁条件变量"></a> 初始化/销毁条件变量</h3><blockquote><p>静态初始化<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER</code><br>动态初始化<code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code><br>cond: 输出型参数，要初始化的条件变量<br>attr: 条件变量属性一般设置NULL<br>销毁<code>int pthread_cond_destroy(pthread_cond_t *cond)</code><br>成功返回0，失败返回错误码</p></blockquote><h3 id="等待唤醒条件变量"><a class="markdownIt-Anchor" href="#等待唤醒条件变量"></a> 等待/唤醒条件变量</h3><blockquote><p>等待<code>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</code>timedwait限时的阻塞等待<br>唤醒所有等待进程<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br>唤醒至少一个线程<code>int pthread_cond_signal(pthread_cond_t *cond);</code><br>成功返回0，失败返回错误码</p></blockquote><p>条件变量是为了解决某些情况下互斥锁低效的问题，因此对条件变量的操作，必然要和互斥锁密切相关，pthread_cond_wait的实现分为三个操作：</p><ol><li>pthread_mutex_unlock(&amp;mutex);</li><li>pthread_cond_wait(&amp;cond);</li><li>pthread_mutex_lock(&amp;mutex);<br>若前两个操作中间可以被打断，那么就有可能出现，A线程加锁后断判资源不足，执行完第一步解锁，然后还没来得及执行第二步等待，另一个线程B就抢到锁后加锁补充资源，解锁发送信号，进入等待状态。此时由于A还没执行第二部进入等待状态所以无法收到信号，所以A执行第二步等待的时候B也在等待，这样就造成了死锁。<br>所以pthread_cond_wait设置了两个参数来保证前两步的原子操作</li></ol><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示</h3><p>使用COUNT个执行流打开开关，另外再使用COUNT个执行流关闭开关，开关不能连续打开或者关闭两次。为了防止唤醒同一个等待队列中的角色，所以多个角色要使用多个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 不同角色在不同条件变量队列上等待，防止误唤醒阻塞</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> switch_on;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> switch_off;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_on</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 循环判断防止当前不符合条件被唤醒后直接操作临界资源</span></span><br><span class="line">        <span class="keyword">while</span> (status == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;switch_on, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Turn on the switch\n"</span>);</span><br><span class="line">        <span class="comment">// 先解锁可以减少锁冲突的概率，提高性能</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;switch_off);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_off</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;switch_off, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Turn off the switch\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;switch_on);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid_on[COUNT], tid_off[COUNT];</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;switch_on, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;switch_off, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid_on[i], <span class="literal">NULL</span>, thread_on, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread_on error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid_off[i], <span class="literal">NULL</span>, thread_off, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread_off error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        pthread_join(tid_on[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(tid_off[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;switch_on);</span><br><span class="line">    pthread_cond_destroy(&amp;switch_off);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="posix信号量"><a class="markdownIt-Anchor" href="#posix信号量"></a> POSIX信号量</h1><p>POSIX信号量和SystemV信号量作用相同，SystemV为内核中的计数器主要用于进程间，POSIX进程/线程间都可以，信号量本质就是一个计数器和一个pcb等待队列，可通过自身的计数器对资源计数并判断资源是否符合访问条件，符合则可以访问，不符合则阻塞等待，其他进程/线程促使条件满足后，可以唤醒pcb等待队列上的pcb，从而实现同步；也可通过使资源计数器不大于1，保证同一时间只有一个进程/线程可以访问临界资源实现互斥</p><h2 id="初始化销毁信号量"><a class="markdownIt-Anchor" href="#初始化销毁信号量"></a> 初始化/销毁信号量</h2><blockquote><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><br><code>int sem_destroy(sem_t *sem);</code><br>sem: 信号量变量<br>pshared: 0表示线程间共享，非零表示进程间共享，如果用于线程间这个计数器是一个全局变量，如果用于进程间则在申请的共享内存中实现pcb等待队列和计数器<br>value: 信号量初始值<br>成功返回0，失败返回-1，并设置错误码</p></blockquote><h2 id="等待发布信号量"><a class="markdownIt-Anchor" href="#等待发布信号量"></a> 等待/发布信号量</h2><blockquote><p><code>int sem_wait(sem_t *sem);</code> 等待信号量，会将信号量的值减1 trywait非阻塞等待 timedwait限时阻塞<br><code>int sem_post(sem_t *sem);</code> 发布信号量，将信号量的值加1，并唤醒等待进程/线程<br>成功返回0，失败返回-1，并设置错误码</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的互斥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程的互斥&quot;&gt;&lt;/a&gt; 线程的互斥&lt;/h1&gt;&lt;p&gt;由于一个进程中的多个线程共享同一个虚拟地址空间。除了一些私有数据，其余大部分资源都是共享的，为了保证线程安全一次只允许一个线程对
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的创建、终止、等待、分离</title>
    <link href="https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/"/>
    <id>https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-06-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线程都是轻量级进程，内核并不知道用户级线程的存在，该用户级线程的实现是通过用户级线程库POSIX来完成的，链接这些线程函数库时要加上&quot;-lpthread&quot;选项，指定要链接的库名</p><h1 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h1><blockquote><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code><br>thread: 输出型参数返回线程ID（用户态线程ID）<br>attr: 设置线程的属性，attr为NULL表示使用默认属性<br>start_routine: 是个函数地址，线程启动后要执行的函数<br>arg: 传给线程启动函数的参数<br>成功返回0；失败返回错误码<br>传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。pthreads函数出错时不会设置全局变量errno（大部分其他POSIX函数会这样做）而是将错误码通过返回值返回pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，读取返回值要比读取线程内的errno变量的开销小</p></blockquote><p>pthread_t实际是一个unsigned long类型，其本质就是一个进程地址空间上的一个地址，NPTL提供<code>pthread_t pthread_self(void);</code>函数来查看<br>创建一个线程就是创建一个pcb，但是线程中还有一些独有的数据，加载动态库就是在进程地址空间中的共享区，而我们用的NPTL函数本身就是动态库函数，所以线程独有的信息都在共享区，操作系统在共享区开辟了一块空间来存放每个线程独有的数据（栈、线程局部存储信息、线程在用户态的描述）而pthread_t就指向这个空间的地址，也可以使用命令pstack [进程id(线程组id)]查看<br>我们平常使用ps -L 查看到的pid就是线程组id，而LWP就是调度实体的线程id（内核级线程id）也叫轻量级进程id，Linux提供了gettid系统调用来返回其线程id（内核级线程id），可是glibc并没有将该系统调用封装起来，在开放接口来共程序员使用。如果确实需要获得线程ID，可以采用如下方法：<code>#include &lt;sys/syscall.h&gt; pid_t tid; tid = syscall(SYS_gettid);</code></p><h1 id="线程终止"><a class="markdownIt-Anchor" href="#线程终止"></a> 线程终止</h1><ol><li><p>从线程 return，如果是从主线程return，相当于exit，所有线程都结束</p></li><li><p>线程自己调用pthread_exit来终止自己</p></li></ol><blockquote><p><code>void pthread_exit(void *value_ptr);</code><br>value_ptr: 输出型参数，该线程退出时的退出码，注意不要指向一个局部变量，因为当线程的调用函数退出时，局部变量也就销毁了</p></blockquote><ol start="3"><li>一个线程可以调用pthread_cancel终止同一进程中的另一进程</li></ol><blockquote><p><code>int pthread_cancel(pthread_t thread);</code><br>参数传pthread_self()时终止自己，成功返回0，失败返回错误码</p></blockquote><h1 id="进程等待"><a class="markdownIt-Anchor" href="#进程等待"></a> 进程等待</h1><p>当一个线程退出时，如果空间没有被释放，新创建的线程也不会利用退出线程的资源，会发生内存泄漏，因此新线程在退出时主线程要通过等待的方式回收退出线程的资源并获取新线程退出时的状态</p><blockquote><p><code>int pthread_join(pthread_t thread, void **value_ptr);</code><br>value_ptr: 由于线程终止时返回一个指针，这个指针一般指向全局变量或者malloc分配的空间，所以进程等待接收参数的时候需要传入一个一级指针的地址来接收参数，成功返回0；失败返回错误码</p></blockquote><p>注意：该函数是以阻塞的方式进行等待的，thread线程以不同的方式终止，得到的线程终止状态也是不同的：</p><ul><li>线程以return的方式终止，value_ptr指向的空间中保存return返回的值</li><li>线程以pthread_exit的方式终止，value_ptr指向的空间中保存传给pthread_exit的参数</li><li>线程被别的线程调用pthread_cancel的方式终止，value_ptr指向的空间中保存常数PTHREAD_CANCELED，<code>#define PTHREAD_CANCELED (void\*)-1;</code></li><li>如果不关心新线程的退出状态，直接将value_ptr设置为NULL即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry1</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry2</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry3</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread3\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread3 is running~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2, t3;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, ThreadEntry1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, ThreadEntry2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t3, <span class="literal">NULL</span>, ThreadEntry3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret;</span><br><span class="line">    pthread_join(t1, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_join(t2, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_cancel(t3);</span><br><span class="line">    pthread_join(t3, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == PTHREAD_CANCELED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread3 return, return code PTHREAD_CANCELED\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"></p><p>我们说父子进程的执行顺序不一定，但是我们却很难看到子进程先于父进程执行，这里却很容易可以看到线程执行顺序不一定，这是因为每次创建一个进程的代价比较大，所以父进程就有很大的概率去执行，而线程的创建代价比较小，所以很容易看到执行顺序不一定这个结果，但是线程等待是串行的</p><h1 id="线程分离"><a class="markdownIt-Anchor" href="#线程分离"></a> 线程分离</h1><p>在默认情况下创建的线程是joinable的，线程退出后，要对其进行pthread_join操作，否则无法回收资源，造成内存泄漏，如果不关心线程的返回值，那么join就是一个负担，这个时候我们可以告诉操作系统线程退出时，由操作系统自动回收资源</p><blockquote><p><code>int pthread_detach(pthread_t thread);</code><br>也可以是线程自己分离：pthread_detach(pthread_self());一个分离的线程异常退出，整个进程也会异常退出，joinable和detached是两个对立的状态，两者不可能同时存在</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-15T16:00:00.000Z</published>
    <updated>2020-06-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1><p>进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过pcb实现的，所以linux下线程就是一个pcb，一个进程中的线程公用同一个虚拟地址空间，相较与传统pcb更加轻量化，也被称为轻量级进程。操作系统资源分配是直接分配给整个线程组，这个线程组就是进程，所以进程是资源分配的基本单位，而线程是进程实际运作的基本单位，cpu通过调度pcb来实现程序的调度，所以线程是调度的基本单位，ps -L中LWP为轻量级进程id，pid为这个线程组id<br>一个进程中的线程共享：</p><ol><li>同一虚拟地址空间：本质共享同一页表</li><li>文件描述符表：一个线程修改了一个文件，其他的线程访问到的文件也都改变</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL或者自定义的信号处理函数)</li><li>未决信号集：只要进程收到了信号，也就意味着所有线程收到了信号</li><li>当前工作目录、用户id和组id</li></ol><p>由于进程中的各个线程共用同一个虚拟地址空间，为了保证程序的合理性所以各个线程有自己的信息：</p><ol><li>线程ID</li><li>栈：防止调用栈混乱</li><li>一组寄存器：线程的上下文信息</li><li>errno：防止线程的errno被另一个线程覆盖</li><li>信号屏蔽字：防止线程在执行重要操作时被打断</li><li>调度优先级：各线程要被调度，就必须有优先级</li></ol><h1 id="线程的优缺点"><a class="markdownIt-Anchor" href="#线程的优缺点"></a> 线程的优/缺点</h1><p>优点：</p><ul><li>线程的创建与销毁成本更低，创建一个进程，我们需要给他分配虚拟地址空间，这个空间占用了一部分资源。创建一个线程，不需要分配虚拟地址空间，节约资源，增快了效率，销毁也比较快</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多，不需要切换页表，只用切换一小部分数据，效率较高</li><li>由于线程组中线程公用同一虚拟地址空间，所以相比进程线程间通信比较方便，只需知道地址就能访问同一空间</li><li>能充分利用多处理器的可并行数量，比如4核CPU，需要不停歇的进行CPU的运算操作，用四个线程运算操作，CPU占用率可达到400%（Linux下）充分利用了硬件资源，处理CPU密集型程序通常执行流个数为CPU核心数+1，若创建线程很多而CPU资源不够多，则大量进程切换调度成本会提高</li><li>I/O密集型应用，为了提高性能，将I/O操作重叠，多任务并行处理，多磁盘可以实现同时处理，线程可以同时等待不同的I/O操作</li></ul><p>缺点：</p><ul><li>缺乏保护访问控制、健壮性降低，需要考虑线程安全问题，异常以及系统调用exit会直接针对整个进程</li><li>性能损失，若CPU密集型程序线程的数量比可用的处理器多则增加了额外的同步和调度开销</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程与线程&quot;&gt;&lt;/a&gt; 进程与线程&lt;/h1&gt;&lt;p&gt;进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>智能指针模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源</p><h1 id="auot_ptr"><a class="markdownIt-Anchor" href="#auot_ptr"></a> auot_ptr</h1><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~AutoPtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt;&amp; ap)</span><br><span class="line">        : _ptr(ap._ptr) &#123;</span><br><span class="line">        <span class="comment">// 转移资源管理权</span></span><br><span class="line">        ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt;&amp; ap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="comment">// 转移资源管理权</span></span><br><span class="line">            _ptr = ap._ptr;</span><br><span class="line">            ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 像指针一样的操作</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bug：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AutoPtr&lt;T&gt; ap(<span class="keyword">new</span> T);</span><br><span class="line">AutoPtr&lt;T&gt; copy(ap);<span class="comment">// 拷贝后把ap对象的指针赋空了，通过ap对象访问资源时就会出bug（除非每次判断ap._ptr是否不为空）</span></span><br></pre></td></tr></table></figure><p>所以auto_ptr根本用不了</p><h1 id="c11-unique_ptr"><a class="markdownIt-Anchor" href="#c11-unique_ptr"></a> C++11 unique_ptr</h1><p>也叫scoped_ptr(boost库)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UniquePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UniquePtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~UniquePtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr并没有去实现类似scoped_array的unique_array，因为标准库中有vector</span></span><br><span class="line">    <span class="comment">// T&amp; operator[](size_t index) &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="comment">// const T&amp; operator[](size_t index) const &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    UniquePtr(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UniquePtr &amp; <span class="keyword">operator</span>=(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比auto_ptr，简单粗暴的防拷贝，勉强可以使用，但没有从根本解决问题</p><h1 id="c11-shared_ptr"><a class="markdownIt-Anchor" href="#c11-shared_ptr"></a> C++11 shared_ptr</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SharedPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr)</span><br><span class="line">        , _pRefCount(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">        , _pMutex(<span class="keyword">new</span> mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~SharedPtr() &#123; Release(); &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">        : _ptr(sp._ptr)</span><br><span class="line">        , _pRefCount(sp._pRefCount)</span><br><span class="line">        , _pMutex(sp._pMutex) &#123;</span><br><span class="line">        AddRefCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            Release();</span><br><span class="line">            <span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pRefCount = sp._pRefCount;</span><br><span class="line">            _pMutex = sp._pMutex;</span><br><span class="line">            AddRefCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁或者使用加1的原子操作</span></span><br><span class="line">        _pMutex-&gt;lock();</span><br><span class="line">        ++(*_pRefCount);</span><br><span class="line">        _pMutex-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* _pRefCount; <span class="comment">// 引用计数</span></span><br><span class="line">    T* _ptr;         <span class="comment">// 指向管理资源的指针</span></span><br><span class="line">    mutex* _pMutex;  <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="仿函数删除器"><a class="markdownIt-Anchor" href="#仿函数删除器"></a> 仿函数删除器</h1><p>上面代码析构函数是用delete来释放资源的，但是我们可能用以下几种方式申请资源：<br><code>SharedPtr&lt;int&gt; p(new int);</code><br><code>SharedPtr&lt;FILE&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int&gt; mp = ((int*)malloc(sizeof(int)));</code><br>这时候使用delete来释放，可能会出错，这时候就需要自定义删除方式，我们只需对上面代码稍加修改即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义我们自己的删除方式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Delete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Free</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Close</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fclose(p);</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span> = <span class="title">Delete</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他都不变，修改析构函数即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            D()(_ptr); <span class="comment">// 创建匿名对象，并调()重载</span></span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：<br><code>SharedPtr&lt;int&gt; np(new int);</code><br><code>SharedPtr&lt;FILE, Close&lt;FILE&gt;&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int, Free&lt;int&gt;&gt; mp((int*)malloc(sizeof(int)));</code></p><h2 id="shared_ptr的循环引用"><a class="markdownIt-Anchor" href="#shared_ptr的循环引用"></a> shared_ptr的循环引用</h2><p>shared_ptr并非完美，也有小缺陷</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _prev;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node1(<span class="keyword">new</span> ListNode);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node2(<span class="keyword">new</span> ListNode);</span><br><span class="line">    node1-&gt;_next = node2;</span><br><span class="line">    node2-&gt;_prev = node1;</span><br><span class="line">&#125; <span class="comment">// 这里会导致内存泄漏</span></span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"><br>出作用域后node1和node2对象被释放<br><img src="img2.png" alt="img2"><br>但是引用计数不为0，_date不会被释放，造成内存泄漏</p><p>当然,C++11库中也给出了响应的解决方法,就是weak_ptr</p><h2 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h2><p>weak_ptr要和shared_ptr搭配使用，在进行如上的赋值时，并不进行引用计数的加加操作，这也保证了在释放的时候不会因为引用计数不为0而没有正确释放，造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="c11-守卫锁"><a class="markdownIt-Anchor" href="#c11-守卫锁"></a> C++11 守卫锁</h1><p>lock_guard利用RAII思想，通过对象的生命周期控制锁的生命周期构造加锁，析构解锁，防止死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Mutex</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LockGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LockGuard(Mutex&amp; mtx)</span><br><span class="line">        :_mutex(mtx) &#123;</span><br><span class="line">        _mutex.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    ~LockGuard() &#123;</span><br><span class="line">        _mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    LockGuard(<span class="keyword">const</span> LockGuard&lt;Mutex&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 必须使用引用，保证同一个互斥量对象</span></span><br><span class="line">    Mutex&amp; _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="comment">// 进入作用域构造lg对象，加锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        LockGuard&lt;mutex&gt; lg(mtx);</span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出了作用域析构lg对象，解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源&lt;/p&gt;&lt;h1 id=&quot;auot_ptr&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#auot_ptr&quot;&gt;&lt;/a&gt; auot_ptr&lt;/h1&gt;&lt;p&gt;模拟实现：&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://Ranjiahao.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
