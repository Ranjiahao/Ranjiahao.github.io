<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>五种IO模型与及多路复用详解 | Ran</title><meta name="description" content="五种IO模型阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都是阻塞方式，流程简单，但是任务处理效率低，无法充分利用资源非阻塞IO：若内核还未将数据准备好，系统调用返回EWOULDBLOCK错误码，往往需要循环的方式反复尝试读写文件描述符，对资源的利用充分，但IO不够实时，且对CPU来说是较大的浪费可以通过int fcntl(int fd,"><meta property="og:type" content="article"><meta property="og:title" content="五种IO模型与及多路复用详解"><meta property="og:url" content="https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="Ran"><meta property="og:description" content="五种IO模型阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都是阻塞方式，流程简单，但是任务处理效率低，无法充分利用资源非阻塞IO：若内核还未将数据准备好，系统调用返回EWOULDBLOCK错误码，往往需要循环的方式反复尝试读写文件描述符，对资源的利用充分，但IO不够实时，且对CPU来说是较大的浪费可以通过int fcntl(int fd,"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-07-15T16:00:00.000Z"><meta property="article:modified_time" content="2020-07-15T16:00:00.000Z"><meta property="article:author" content="Ran"><meta property="article:tag" content="多路转接"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/index.html"><link rel="alternate" href="/atom.xml" title="Ran" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body class="main-center theme-green" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/Ranjiahao" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Ran</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">I am a student</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Xi&#39;an, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/Ranjiahao" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">45</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">25</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/AVL%E6%A0%91/" style="font-size:13px">AVL树</a> <a href="/tags/C-11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size:13px">C++11列表初始化</a> <a href="/tags/HTTP/" style="font-size:13px">HTTP</a> <a href="/tags/STL/" style="font-size:13.8px">STL</a> <a href="/tags/Socket/" style="font-size:13px">Socket</a> <a href="/tags/TCP/" style="font-size:13px">TCP</a> <a href="/tags/UDP/" style="font-size:13px">UDP</a> <a href="/tags/auto/" style="font-size:13px">auto</a> <a href="/tags/date%E7%B1%BB/" style="font-size:13px">date类</a> <a href="/tags/decltype/" style="font-size:13px">decltype</a> <a href="/tags/fork/" style="font-size:13px">fork</a> <a href="/tags/ipc/" style="font-size:13.6px">ipc</a> <a href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size:13px">lambda表达式</a> <a href="/tags/map-set/" style="font-size:13px">map/set</a> <a href="/tags/mysql/" style="font-size:13.2px">mysql</a> <a href="/tags/strtok/" style="font-size:13px">strtok</a> <a href="/tags/unordered-map-set/" style="font-size:13px">unordered_map/set</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size:13px">二叉搜索树</a> <a href="/tags/%E4%BD%8D%E5%9B%BE/" style="font-size:13px">位图</a> <a href="/tags/%E4%BF%A1%E5%8F%B7/" style="font-size:13px">信号</a> <a href="/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/" style="font-size:13px">僵尸进程</a> <a href="/tags/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/" style="font-size:13px">内核态与用户态</a> <a href="/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/" style="font-size:13px">内联函数</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size:13px">内部类</a> <a href="/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/" style="font-size:13px">函数重载</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" style="font-size:13px">动态内存</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93/" style="font-size:13px">动态库静态库</a> <a href="/tags/%E5%8F%8B%E5%85%83/" style="font-size:13px">友元</a> <a href="/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/" style="font-size:13px">可变参数列表</a> <a href="/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" style="font-size:13px">右值引用</a> <a href="/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" style="font-size:13px">命名空间</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size:13px">哈希</a> <a href="/tags/%E5%A4%9A%E6%80%81/" style="font-size:13px">多态</a> <a href="/tags/%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/" style="font-size:13px">多路转接</a> <a href="/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" style="font-size:13px">孤儿进程</a> <a href="/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/" style="font-size:13px">完美转发</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size:13px">布隆过滤器</a> <a href="/tags/%E6%8C%87%E9%92%88/" style="font-size:13.2px">指针</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size:14px">排序</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size:13px">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6IO/" style="font-size:13.2px">文件IO</a> <a href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" style="font-size:13px">文件系统</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" style="font-size:13px">智能指针</a> <a href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size:13px">构造函数</a> <a href="/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" style="font-size:13px">析构函数</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size:13px">模板</a> <a href="/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/" style="font-size:13px">浮点数</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size:13px">环境变量</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/" style="font-size:13px">类型萃取</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size:13.2px">类型转换</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size:13px">红黑树</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size:13.4px">线程</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size:13px">继承</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size:13px">网络基础</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/" style="font-size:13px">自定义类型</a> <a href="/tags/%E8%8C%83%E5%9B%B4for/" style="font-size:13px">范围for</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0/" style="font-size:13px">虚函数</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:13px">设计模式</a> <a href="/tags/%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/" style="font-size:13px">软硬链接</a> <a href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" style="font-size:13px">运算符重载</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size:13.4px">进程</a> <a href="/tags/%E9%93%BE%E6%8E%A5%E6%80%A7/" style="font-size:13px">链接性</a> <a href="/tags/%E9%94%81/" style="font-size:13px">锁</a> <a href="/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" style="font-size:13px">预处理器</a> <a href="/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/" style="font-size:13px">默认参数</a></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#五种io模型"><span class="toc-number">1.</span> <span class="toc-text">五种IO模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多路转接"><span class="toc-number">2.</span> <span class="toc-text">多路转接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-number">2.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">2.3.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lt模式与et模式"><span class="toc-number">2.3.1.</span> <span class="toc-text">LT模式与ET模式</span></a></li></ol></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-五种IO模型与多路转接详解" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">五种IO模型与及多路复用详解</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/" class="article-date"><time datetime="2020-07-15T16:00:00.000Z" itemprop="datePublished">2020-07-16</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Linux/">Linux</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/" rel="tag">多路转接</a></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/#comments" class="article-comment-link">评论</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h1 id="五种io模型"><a class="markdownIt-Anchor" href="#五种io模型"></a> 五种IO模型</h1><ul><li><p>阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都是阻塞方式，流程简单，但是任务处理效率低，无法充分利用资源</p></li><li><p>非阻塞IO：若内核还未将数据准备好，系统调用返回EWOULDBLOCK错误码，往往需要循环的方式反复尝试读写文件描述符，对资源的利用充分，但IO不够实时，且对CPU来说是较大的浪费<br>可以通过<code>int fcntl(int fd, int cmd, ... /* arg */ );</code>函数设置<code>int fl = fcntl(fd, F_GETFL);fcntl(fd, F_SETFL, fl | O_NONBLOCK)</code></p></li><li><p>信号驱动IO：建立SIGIO的信号处理程序，内核将数据准备好的时候，使用SIGIO信号通知应用程序进行IO操作，资源利用充分，比非阻塞IO实时</p></li><li><p>多路转接IO：发起多路转接IO，将需要等待的文件描述符添加监控，然后由内核轮询遍历，进程一直等待任意一个文件描述符就绪，然后进行IO操作</p></li><li><p>异步IO：发起异步IO系统调用，直接返回，然后由内核等待，并由内核自动拷贝数据，拷贝完成后通知应用程序，对资源的利用最为充分，且效率最高</p></li><li><p>这五种IO模型处理的效率逐渐增加，对资源(cpu)的利用也更加充分，但是流程也越来越复杂</p></li></ul><h1 id="多路转接"><a class="markdownIt-Anchor" href="#多路转接"></a> 多路转接</h1><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>系统调用<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>nfds：需要监视的最大的文件描述符值+1<br>readfds,writefds,exceptfds：分别对应需要检测的可读、可写、异常文件描述符集合<br>timeout：用来设置select()的等待时间。NULL表示select将一直被阻塞，直到某个文件描述符上发生了事件，0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生，特定的时间值：如果在指定的时间段里没有事件发生，select将超时返回<br>执行成功则返回文件描述词状态已改变的个数，如果返回0代表在描述词状态改变前已超过timeout时间，没有返回，当有错误发生时则返回-1，错误原因存于errno，此时参数readfds，writefds, exceptfds和timeout的值变成不可预测</p><p><strong>fd_set结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE        1024</span></span><br><span class="line"><span class="comment">// select.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> __fd_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NFDBITS   (8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>这个结构就是一个整数数组构成的位图，位图中对应的位来表示要监视的文件描述符，提供了一组操作fd_set的接口来方便的操作位图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来清除描述词组set中相关fd 的位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 用来测试描述词组set中相关fd 的位是否为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来设置描述词组set中相关fd的位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;         <span class="comment">// 用来清除描述词组set的全部位</span></span><br></pre></td></tr></table></figure><p><strong>timeval结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>    </span></span><br><span class="line"><span class="class">  &#123;</span>    </span><br><span class="line">    <span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds.  */</span>    </span><br><span class="line">    <span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds.  */</span>                     </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>定义指定监控事件的描述符集合（即位图），初始化集合后，将需要监控指定事件的描述符添加到指定事件（可读、可写、异常）的描述符集合中<br>select将描述符集合拷贝到内核当中，对集合中所有描述符进行轮询判断，当描述符就绪或者等待超时后就调用返回，返回后的集合中只剩下已就绪的描述符（未就绪会在位图中置为0）<br>用户通过遍历描述符，判断哪些描述符还在集合中，就可以知道哪些描述符已经就绪了，开始处理对应的IO事件</p><p>读就绪：socket内核中接收缓冲区中的字节数大于等于低水位标记SO_RCVLOWAT（默认1字节），此时可以无阻塞的读该文件描述符，并且返回值大于0；socket TCP通信中，对端关闭连接，此时对该socket读，则返回0；监听的socket上有新的连接请求；socket上有未处理的错误<br>写就绪：socket内核中发送缓冲区中的字节数（发送缓冲区的空闲位置大小）大于等于低水位标记SO_SNDLOWAT，此时可以无阻塞的写，并且返回值大于0；socket的写操作被关闭（close或者shutdown）对一个写操作被关闭的socket进行写操作，会触发SIGPIPE信号；socket使用非阻塞connect连接成功或失败之后；socket上有未读取的错误;<br>异常就绪：socket上收到带外数据</p><p><strong>缺点</strong></p><ol><li>select能监控的最大描述符有限，由宏__FD_SETSIZE决定，默认是1024个</li><li>select会将集合拷贝到内核中轮询遍历判断描述符是否就绪，效率会随着描述符的增多而越来越低</li><li>select监控完毕后返回的集合中只有已就绪的描述符，移除了未就绪的描述符，所以每次监控都必须要重新将描述符加入集合中，重新拷贝到内核</li><li>select返回的集合是一个位图而不是真正的描述符数组，所以需要用户遍历判断哪个描述符在集合中才能确认其是否就绪</li></ol><p><strong>优点</strong></p><ol><li>select遵循posix标准，可以跨平台移植</li><li>select的超时等待时间较为精确，可以精细到微秒</li></ol><p>tcp_select服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc</a></p><h2 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h2><p>系统调用接口<code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><br>fds：poll函数监听的结构列表，包含了三部分内容，文件描述符、监听的事件集合、返回的事件集合<br>nfds：表示fds数组的长度<br>timeout：表示poll函数的超时时间，单位是毫秒(ms)<br>返回值小于0，表示出错；返回值等于0，表示poll函数等待超时；返回值大于0，表示poll由于监听的文件描述符就绪而返回</p><p><strong>pollfd结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events和revents取值：POLLIN可读、POLLOUT可写</p><p><strong>原理</strong></p><ul><li><p>定义pollfd结构体数组，将需要监控的描述符以及监控的事件信息添加进去</p></li><li><p>发起监控调用poll，将数组中的数据拷贝到内核当中进行轮询遍历监控，当有描述符就绪或者等待超时后返回，返回时将已就绪的事件添加进pollfd结构体中的revents中（如果没就绪，则为0）</p></li><li><p>监控调用返回后，遍历pollfd数组中的每一个节点的revents，根据对应的就绪时间进行相应操作</p></li></ul><p><strong>缺点</strong></p><ol><li><p>每次调用poll都需要把大量的pollfd结构从用户态拷贝到内核中，在内核中轮询判断描述符是否就绪，效率会随着描述符的增加而下降</p></li><li><p>每次调用返回后需要用户自行判断revents才能知道是哪个描述符就绪了哪个事件</p></li><li><p>无法跨平台移植</p></li><li><p>超时等待时间只精确到毫秒</p></li></ol><p><strong>优点</strong></p><ol><li>poll通过描述符事件结构体的方式将select的描述符集合的操作流程合并在一起，简化了操作</li><li>poll并没有最大数量限制（但是数量过大后性能也是会下降）</li><li>poll每次监控不需要重新定义事件结构</li></ol><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><p>系统调用<br><code>int epoll_create(int size);</code>创建一个epoll的句柄<br>自从linux2.6.8之后，size参数是被忽略的，用完之后，必须调用close()关闭</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>注册要监听的事件类型<br>epfd：epoll_create返回的句柄<br>op：EPOLL_CTL_ADD，注册新的fd到epfd中；EPOLL_CTL_MOD，修改已经注册的fd的监听事件；EPOLL_CTL_DEL，从epfd中删除一个fd；<br>fd：需要监听的fd<br>event：告诉内核需要监听什么事</p><p><strong>epoll_event结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;    <span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure><p>events取值：EPOLLIN表示对应的文件描述符可以读 (包括对端SOCKET正常关闭)；EPOLLOUT表示对应的文件描述符可以写；EPOLLET将EPOLL设为边缘触发，一般将data.fd设置为需要监听的fd</p><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code>收集在epoll监控的事件中已经发送的事件（异步阻塞）<br>events：分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）<br>maxevents：告诉内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size参数<br>timeout：超时时间（毫秒，0会立即返回，-1是永久阻塞)<br>如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时，返回小于0表示函数失败</p><p><strong>原理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件，这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是log(n)，其中n为树的高度)而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当响应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback，它会将发生的事件添加到rdlist双链表中，在epoll中，对于每一个事件，都会建立一个epitem结构体，当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可，如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户，这个操作的时间复杂度是O(1)</p><p><strong>优点</strong></p><ol><li>文件描述符数目无上限</li><li>数据拷贝轻量，只在调用EPOLL_CTL_ADD将文件描述符结构拷贝到内核中</li><li>事件回调机制，避免使用遍历，而是使用回调函数的方式，将就绪的文件描述符结构加入到就绪队列中，epoll_wait返回直接访问就绪队列就知道哪些文件描述符就绪，这个操作时间复杂度O(1)即使文件描述<br>符数目很多, 效率也不会受到影响</li></ol><p><strong>缺点</strong></p><ol><li>无法跨平台移植</li><li>超时等待时间只精确到毫秒</li><li>在活动连接较多的时候，由于会大量触发回调函数，所以此时epoll的效率未必会select和poll高，所以epoll适用于连接数量多，但是活动连接少的情况</li></ol><p>应用场景：对于多连接，且多连接中只有一部分连接比较活跃时，比较适合使用epoll</p><h3 id="lt模式与et模式"><a class="markdownIt-Anchor" href="#lt模式与et模式"></a> LT模式与ET模式</h3><p>epoll默认状态下就是LT工作模式，只要接收缓冲区中数据大于低水位标记（可读），或者发送缓冲区中剩余空间大于低水位标记（可写）就会一直触发事件，支持阻塞读写和非阻塞读写，LT模式简单稳定<br>tcp_epoll_lt服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc</a></p><p>ET模式，只有新数据到来是触发可读时间，或者剩余空间大小从无到有的时候才会触发事件，只支持非阻塞的读写<br>tcp_epoll_et服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc</a><br>使用ET能够减少epoll触发的次数，但是代价就是必须一次把所有的数据都处理完，代码复杂，还有一种场景适合ET模式使用，如果我们需要接受一条数据，但是这条数据因为某种问题导致其发送不完整，需要分批发送。所以此时的缓冲区中数据只有部分，如果此时将其取出，则会增加维护数据的开销，正确的做法应该是等待后续数据到达后将其补全，再一次性取出。但是如果此时使用的是LT模式，就会因为缓冲区不为空而一直触发事件，所以这种情况下使用ET会比较好</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/" title="五种IO模型与及多路复用详解" target="_blank" rel="external">https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/Ranjiahao" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/Ranjiahao" target="_blank"><span class="text-dark">Ran</span><small class="ml-1x">I am a student</small></a></h3><div>stay healthy and happy</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/07/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/" title="二叉搜索树模拟实现"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2020/07/07/TCP%E5%8D%8F%E8%AE%AE/" title="TCP协议"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/Ranjiahao" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"",clientSecret:"",repo:"Ranjiahao.github.io",owner:"Ranjiahao",admin:["Ranjiahao"],id:md5(location.pathname),distractionFreeMode:!0});gitalk.render("comments")</script></body></html>