---
title: 进程程序替换
date: 2020-05-03 00:00:00
categories: Linux
tags: 进程
---

当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行
系统调用：
`int execve(const char* path, char* const argv[], char* const envp[]);`
库函数：
`int execl(const char* path, const char* arg, ...);`
`int execlp(const char* file, const char* arg, ...);`
`int execle(const char* path, const char* arg, ...,char* const envp[]);`
`int execv(const char* path, char* const argv[]);`
`int execvp(const char* file, char* const argv[]);`
`int execvpe(const char* file, char* const argv[], char* const envp[]);`
规律：exec必选
**v和l必须选其一**

* l(list) : 表示参数采用列表
* v(vector) : 参数用数组

**e、p可选可不选**
* p(path) : 有p自动搜索环境变量PATH
* e(env) : 表示自己维护环境变量

如果调用成功则加载新的程序从启动代码开始执行，不返回
如果调用出错则返回-1

```c
    char* const argv[] = {"ls", "-l", NULL};
    char *const envp[] = {"PATH=/bin:/usr/bin", "TERM=console", NULL};
    // l和v
    execl("/bin/ls", "ls", "-l", NULL);
    execv("/bin/ls", argv);
    // p和e
    execlp("ls", "ls", "-l", NULL);
    execve("/bin/ls", argv, envp);
```
这些库函数在调用时候，如果参数采用列表格式首先将参数替换成数组形式，然后如果有相对路径就在底层替换成绝对路径，然后根据自己维护的环境变量或者shell的环境变量组织envp，而后调execve接口
我们发现函数和进程之间有些许相似性：
c语言中，一个函数和一个函数可以通过return/call来通信，这类似与进程间的exit/exec&fork，进程可以fork/exec，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来返回值。调用它的进程可以通过wait来获取exit的返回值