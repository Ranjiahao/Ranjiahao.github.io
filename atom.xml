<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ranjiahao.github.io/"/>
  <updated>2020-05-19T16:00:00.000Z</updated>
  <id>https://ranjiahao.github.io/</id>
  
  <author>
    <name>Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态库静态库与软硬链接</title>
    <link href="https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态库"><a class="markdownIt-Anchor" href="#静态库"></a> 静态库</h1><p>静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可执行文件之后不再依赖静态库。所以速度会较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成静态库</span><br><span class="line">$ gcc -c test1.c test2.c</span><br><span class="line">$ ar -rc libmylib.a test1.o test2.o # ar是gnu归档工具，rc表示(replace and create)</span><br><span class="line">$ ar -tv libmylib.a # 查看静态库中的目录列表 t:列出静态库中的文件 v:verbose 详细信息</span><br></pre></td></tr></table></figure><h1 id="动态库"><a class="markdownIt-Anchor" href="#动态库"></a> 动态库</h1><p>动态库（.so）：程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码，在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制到内存中，动态库可以在多个程序间共享，所以动态链接使得可执行文件更小，节省了磁盘空间。操作系统采用虚拟内存机制允许物理内存中的一份动态库被要用到该库的所有进程共用，节省了内存和磁盘空间，但是，每次使用时，都要去调用动态库，所以速度会相对较慢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 生成动态库</span><br><span class="line">$ gcc -c -fPIC test1.c test2.c # -fPIX产生位置无关码</span><br><span class="line">$ gcc -shared test1.o test2.o -o libmylib.so # -sharde表示生成共享库格式</span><br></pre></td></tr></table></figure><h1 id="使用库"><a class="markdownIt-Anchor" href="#使用库"></a> 使用库</h1><p><code>$ gcc main.c -I ./include -L. -lmylib</code><br>-L: 指定库路径（默认是从usr/lib 或 usr/local/lib中寻找库文件）<br>-l: 指定库名（去掉lib以及版本号）<br>-I: 指定头文件搜索路径<br>可以将路径添加到环境变量LIBRARY_PATH中代替-L<br>运行动态库：由于动态链接在运行时需要动态库，所以要么拷贝.so文件到系统共享库路径下；要么添加路径到环境变量LD_LIBRARY_PATH中；或者在目录/etc/ld.so.conf.d/中创建mylib.conf，并且在其中填写存放动态库的路径，保存退出后，使用ldconfig命令更新/ld.so.conf.d目录<br>gcc默认动态链接，如果想使用第三方静态库，不能使用-static选项，因为-static选项是生成静态链接可执行程序，所有库都使用静态库，我们只希望这个第三方库使用静态库而不是所有，因此我们将第三方库拷贝到指定目录下然后使用-L选项指定路径，链接的就是静态库</p><h1 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h1><p>创建方式 ln srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln tmp tmp.hard</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode相同，而链接数从1变成了2<br>删除文件时干了两件事情：1.在目录中将对应的记录删除 2.将硬连接数-1，如果为0，则将对应<br>的磁盘释放</p><h1 id="软链接"><a class="markdownIt-Anchor" href="#软链接"></a> 软链接</h1><p>创建方式 ln -s srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln -s tmp tmp.soft</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode不相同，而tmp.soft的文件大小为被链接文件所给路径的长度</p><h1 id="链接的访问"><a class="markdownIt-Anchor" href="#链接的访问"></a> 链接的访问</h1><p><img src="img1.png" alt="img1"></p><p>硬链接hard link本质上和file没区别，与源文件file共用一个inode节点，通过inode来访问数据，而软链接soft link本质上是一个独立的文件，有自己的inode节点和自己的data block其中保存着file的路径，通过路径访问源文件</p><p>所以删除源文件，软链接文件失效；硬链接只是链接数-1，删除了目录文件data block中保存的目录项。由于软链接通过路径访问，硬链接通过inode访问，所以软链接可以跨分区，而硬链接不可跨分区，目录本身也是跨分区的所以不能设置硬链接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#静态库&quot;&gt;&lt;/a&gt; 静态库&lt;/h1&gt;&lt;p&gt;静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="动态库静态库" scheme="https://Ranjiahao.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="软硬链接" scheme="https://Ranjiahao.github.io/tags/%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="https://ranjiahao.github.io/2020/05/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://ranjiahao.github.io/2020/05/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机械硬盘的物理存储机制"><a class="markdownIt-Anchor" href="#机械硬盘的物理存储机制"></a> 机械硬盘的物理存储机制</h1><p>一个硬盘有多张盘片叠成，不同盘片有编号<br>每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号<br>每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位<br>N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位<br>所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位</p><h1 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h1><p>硬盘分区本质是硬盘这个物理概念转换成区这个逻辑概念，为下一步格式化做准备。<br>第一扇区有硬盘主引导记录及分区表， MBR扇区由引导代码(446bytes)、MBR分区表(64bytes)、MBR结束标志(2bytes)3部分构成，一共占用512bytes。MBR放有最基本的引导加载程序，是系统开机启动的关键环节，而分区表则跟分区有关，它记录了硬盘分区的相关信息，分区表仅有64bytes，最多只能记彔四块分区（分区其实就是对分区表进行设置），也可以设置成主分区+逻辑分区，这时也是最多4个分区号码，但是变成了4 = 3 + 1其中4是主分区和扩展分区加起来最多4个，3是主分区，1是扩展分区，占用了一个主分区号，从5开始都是逻辑分区。扩展分区的磁盘总量等于一个逻辑分区的磁盘总量。本质是利用额外的扇区来记录更多的分区信息。扩展分区不同于主分区，它本身并没有内容，它是为进一步逻辑分区提供空间的，只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区<br>最好单独分一个swap区，当有数据被存放在物理内存里面，但是这些数据又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap置换空间当中，而将速度较快的物理内存空间释放出来给真正需要的程序使用</p><h1 id="ext2文件系统"><a class="markdownIt-Anchor" href="#ext2文件系统"></a> ext2文件系统</h1><p><img src="img1.png" alt="img1"></p><p>Boot Block: 这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的MBR， 也就是这样才能实现多重引导的功能<br>Block group: ext2文件系统会根据分区的大小划分为数个Block Group<br>Super Block: 存放文件系统本身的结构信息，一般大小为1024bytes。记录的信息主要有: bolck 和 inode的总量，未使用的block和inode的数量，是否被挂载，一个block(1k|2k|4k mke2fs -b可以设置)，和inode(128bytes)的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了<br>Group Descriptor Table: 块组描述符，描述块组属性信息，这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段分别介于哪一个block号码之间<br>Block Bitmp: 记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用<br>inode Bitmap: 每个bit表示一个inode是否空闲可用<br>inode Table: 存放文件属性 如文件大小/权限/所有者，数据地址，最近修改时间等(ls -i可查看)<br>Date blocks：存放文件内容</p><p>创建一个新文件主要有以下几个操作：</p><ol><li>存储属性，内核通过inode Bitmap找到一个空闲的inode节点</li><li>存储数据，内核通过Block Bitmap找到了n个空闲块，将内核缓冲区的数据复制到块中</li><li>记录分配情况，内核在inode Table记录块列表等信息</li><li>添加文件名到目录，内核将入口（inode，filename等信息）添加到目录文件的block中，文件名和inode之间的对应关系将文件名和文件的内容及属性连接起来</li></ol><ul><li>所以文件名的记录是在目录的block当中，「新增/删除/更名文件名」与目录的w权限有关</li><li>stat file_name命令可查看这些信息</li></ul><h1 id="inode直接间接区"><a class="markdownIt-Anchor" href="#inode直接间接区"></a> inode直接/间接区</h1><p>inode要记录的资料非常多，却只有128bytes，因为inode记录block 号码的区域定义为12个直接，一个间接，一个双间接与一个三间接记录区<br>直接记录：里面有12个直接指向block号码的对照，这12条记录就能够直接取得block号码<br>间接记录：再拿一个block来当作记录block号码的记录区，如果文件太大时，就会使用间接的block来记录号码。同理，如果文件持续长大，那么就会利用所谓的双间接，第一个block仅再指出下一个记录号码的block在哪里，实际记录的在第二个block当中。依此类推，三间接就是利用第三层block来记录号码<br>12个直接指向： 12 * 1K = 12K<br>间接： 256 * 1K = 256K，block号码的记录占4bytes，因此1K的大小能够记录256笔记录<br>双间接： 256 * 256k = 64M，第一层block会指定256个间接<br>三间接：256 * 64M = 16G，第一层block会指定256个双间接</p><h1 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> vfs</h1><p>在一个区被格式化为一个文件系统之后，它就可以被Linux操作系统使用了，只是这个时候Linux操作系统还找不到它，所以我们还需要把这个文件系统注册进Linux操作系统的文件体系里，这个操作就叫挂载，把对不同文件系统的访问交给了VFS（虚拟文件系统），VFS能访问和管理各种不同的文件系，每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用</p><p><img src="img2.png" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机械硬盘的物理存储机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#机械硬盘的物理存储机制&quot;&gt;&lt;/a&gt; 机械硬盘的物理存储机制&lt;/h1&gt;&lt;p&gt;一个硬盘有多张盘片叠成，不同盘片有编号&lt;br&gt;每张盘片上的存储颗粒成环形一圈圈地排布，每一圈
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="文件系统" scheme="https://Ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>系统文件IO</title>
    <link href="https://ranjiahao.github.io/2020/05/16/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/"/>
    <id>https://ranjiahao.github.io/2020/05/16/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h1><p>文件描述符就是从0开始的整数，打开文件时，操作系统在内存中要创建相应的数据结构file来描述目标文件，而进程执行系统文件IO，必须让进程和文件关联起来。所以每个进程都有一个指针files, 指向一张表files_struct，表中包涵一个指针数组，每个元素都是一个指向打开文件的指针，本质上，文件描述符就是数组的下标</p><p><img src="img1.png" alt="img1"></p><h1 id="openclose"><a class="markdownIt-Anchor" href="#openclose"></a> open/close</h1><blockquote><p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>int open(const char *pathname, int flags);<br>int open(const char *pathname, int flags, mode_t mode);</p></blockquote><p>pathname: 要打开或创建的目标文件<br>flags: 一个或者多个常量进行或运算，构成flags<br>O_RDONLY: 只读打开，O_WRONLY: 只写打开，O_RDWR: 读，写打开。这三个常量，必须指定一个且只能指定一个<br>O_CREAT: 若文件不存在，则创建。需要使用mode选项，来指明新文件的访问权限<br>O_APPEND: 追加写打开<br>O_TRUNC: 打开文件截断为0<br>mode: 文件访问权限，如，0664，这里真实权限为mode &amp; ~umask，umask(0)设置权限掩码<br>返回值: 成功返回文件描述符，失败返回-1并设置errno</p><h1 id="close"><a class="markdownIt-Anchor" href="#close"></a> close</h1><blockquote><p>#include &lt;unistd.h&gt;<br>int close(int fd);</p></blockquote><p>fd: 文件描述符<br>返回值: 成功返回0，失败返回-1并设置errno</p><h1 id="writeread"><a class="markdownIt-Anchor" href="#writeread"></a> write/read</h1><blockquote><p>#include &lt;unistd.h&gt;<br>ssize_t write(int fd, const void *buf, size_t count);<br>ssize_t read(int fd, void *buf, size_t count);</p></blockquote><p>fd: 文件描述符<br>buf: 写入到文件描述符的指定的缓冲区/从文件描述符fd将字节数读入的缓冲区<br>count: 写入到文件描述符的字节数/从文件描述符读入的字节数<br>返回值: 成功返回写入/读入字节数，失败返回-1并设置errno</p><h1 id="lseek"><a class="markdownIt-Anchor" href="#lseek"></a> lseek</h1><blockquote><p>#include &lt;sys/types.h&gt;<br>#include &lt;unistd.h&gt;<br>off_t lseek(int fd, off_t offset, int whence);</p></blockquote><p>fd: 文件描述符<br>offset: 偏移量<br>whence:<br>SEEK_SET: 文件偏移量将被设置为offset<br>SEEK_CUR: 文件偏移量将被设置为当前文件偏移量加上offset，offset可正可负<br>SEEK_END: 文件偏移量将被设置为文件长度加上offset，offset可正可负<br>返回值: 成功返回新的偏移量，失败返回-1并设置errno</p><h1 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h1><h2 id="文件描述符分配原则"><a class="markdownIt-Anchor" href="#文件描述符分配原则"></a> 文件描述符分配原则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"myfile"</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// '\n'只能针对标准输出文件刷新缓冲区</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后我们发现本来应该输出到显示器上的内容却输出到了myfile当中，其中fd=1，所以文件描述符的分配原则为最小未使用原则</p><h2 id="dup2系统调用"><a class="markdownIt-Anchor" href="#dup2系统调用"></a> dup2系统调用</h2><blockquote><p>#include &lt;unistd.h&gt;<br>int dup2(int oldfd, int newfd);<br>让newfd下标对应的指针也指向oldfd下标对应的指针所指向的文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"myfile"</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"hehe\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, arr, <span class="built_in">strlen</span>(arr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// '\n'只能针对标准输出文件刷新缓冲区</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结束后文件myfile中<br>hehe<br>fd: 3</p><h1 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h1><p>一般C库函数写入文件时是全缓冲的，而写入显示器是行缓冲</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str1 = <span class="string">"printf\n"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"fwrite\n"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str3 = <span class="string">"write\n"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">    fwrite(str2, <span class="built_in">strlen</span>(str2), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, str3, <span class="built_in">strlen</span>(str3));</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行./a.out发现输出<br>printf<br>fwrite<br>write<br>但是运行./a.out &gt; file，则file文件中printf和fwrite被打印了两次，write还是一次</p><p>这是因为’\n’刷新缓冲区的作用只对标准输出有用，而对于普通文件来说数据的缓冲方式由行缓冲变成了全缓冲，而我们放在缓冲区中的数据，就不会被立即刷新，fork的时候，子进程会连缓冲区中数据一起拷贝，write没有变化，说明它没有用户级缓冲<br>C库当中的FILE结构体内(/usr/include/libio.h)包含了用户态的缓冲区定义，以及文件描述符，本质上都是通过文件描述符来访问的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件描述符&quot;&gt;&lt;/a&gt; 文件描述符&lt;/h1&gt;&lt;p&gt;文件描述符就是从0开始的整数，打开文件时，操作系统在内存中要创建相应的数据结构file来描述目标文件，而进程执行系统文件IO，必
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="文件IO" scheme="https://Ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6IO/"/>
    
  </entry>
  
  <entry>
    <title>SystemV消息队列</title>
    <link href="https://ranjiahao.github.io/2020/05/13/SystemV%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://ranjiahao.github.io/2020/05/13/SystemV%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-05-12T16:00:00.000Z</published>
    <updated>2020-05-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列是一种以链表式结构组织的数据，存放在内核中，是三个IPC对象类型中最具数据操作性的数据传送方式，可以根据数据类型来检索消息，有同步互斥机制，面向数据报，全双工通信<br>我们可以通过命令查看/删除系统中已有的消息队列<br><code>ipcs -q</code>/<code>ipcrm -q [msqid]</code><br>相关操作（系统调用）：</p><h1 id="消息队列创建打开"><a class="markdownIt-Anchor" href="#消息队列创建打开"></a> 消息队列创建/打开</h1><blockquote><p><code>int msgget(key_t key, int msgflg);</code><br>第一个参数key：给这个消息队列分配的密钥，同创建共享内存一样，系统返回对应共享内存的标识符，失败返回-1，并设置errno<br>第二个参数msgflg: IPC_CREAT如果不存在就创建，IPC_EXCL如果已经存在则返回失败，位或权限位：可以设置消息队列的访问权限<br>每创建一个消息队列，就会在用户空间组织这样的一个数据结构，用来设置或返回消息队列的信息</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span> <span class="comment">// 消息队列第一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span> <span class="comment">// 消息队列最后一个节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_cbytes; <span class="comment">// 当前队列字节数据      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qnum; <span class="comment">// 队列中的消息数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qbytes; <span class="comment">// 队列中最大字节数</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 时间属性</span></span><br><span class="line">    <span class="comment">// 最近接收和发送消息的进程pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="添加消息到消息队列中"><a class="markdownIt-Anchor" href="#添加消息到消息队列中"></a> 添加消息到消息队列中</h1><blockquote><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code><br>msgid:msgget函数返回的消息队列标识符<br>msgp:指向准备发送的消息，是一个用户自定义的结构体<br>msgsz:消息⻓度，不含消息类型，最大长度MSGMAX<br>msgflg:IPC_NOWAIT队列满非阻塞，返回EAGAIN错误，0阻塞</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msgp的格式：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype; <span class="comment">// 必须大于0</span></span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>]; <span class="comment">// 消息的长度，实际是一柔性数组，在实际使用时有用户自主指定大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将数据添加到队列尾，并且更新msg_last<br><img src="img1.png" alt="img1"></p><h1 id="从消息队列中接收消息"><a class="markdownIt-Anchor" href="#从消息队列中接收消息"></a> 从消息队列中接收消息</h1><blockquote><p><code>ssize_t msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg);</code><br>msgid: msgget函数返回的消息队列标识符<br>msgp: 指针指向准备接收的消息<br>msgsz: 是msgp指向的消息⻓度，不含消息类型<br>msgtype: 它可以实现接收优先级的简单形式<br>若 = 0 - 读取消息队列中最早的消息，以先进先出的方式读取消息<br>若 &gt; 0 - 读取消息队列类型为msgtyp最早的消息<br>若 &lt; 0 - 读取消息队列中，消息类型小于或等于msgtyp绝对值的消息中最小消息类型的最早消息<br>msgflg: IPC_NOWAIT设置非阻塞，MSG_NOERROR表示消息大小超过msgsz时被截断，MSG_EXCEPT表示接收类型不等于msgtyp的第一条消息<br>成功返回实际放到msgp⾥去的字符个数，失败返回-1，并设置errno</p></blockquote><h1 id="控制消息队列"><a class="markdownIt-Anchor" href="#控制消息队列"></a> 控制消息队列</h1><blockquote><p><code>int msgctl(int msqid,int cmd,struct msqid_ds* buf);</code><br>msgid: msgget函数返回的消息队列标识符<br>cmd:<br>IPC_RMID删除消息队列， IPC_STAT IPC_SET<br>cmd: IPC_RMID删除消息队列、IPC_STAT获取消息队列的当前关联值、IPC_SET根据buf设置消息队列关联值<br>buf: 保存着消息队列的模式状态和访问权限的数据结构，输入输出型参数<br>成功返回0；失败返回-1，并设置errno</p></blockquote><h1 id="从内核看本质"><a class="markdownIt-Anchor" href="#从内核看本质"></a> 从内核看本质</h1><p>内核维护着一个消息队列的全局数据结构ipc_ids，其中有一个指针指向一个数组。每当创建一个IPC对象内核就会创建一个ipc_perm，并且将它的地址放到结构体ipc_id中，这个数组就是这个结构体ipc_id组成的数组，数组最大的个数就是MSGMNI，所以说消息队列<mark>随内核持续</mark>，直到内核重新自举或者显示删除该对象为止。类似还有信号量、共享内存<br><img src="img2.png" alt="img2"></p><h1 id="代码实现server和client的交互"><a class="markdownIt-Anchor" href="#代码实现server和client的交互"></a> 代码实现server和client的交互</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/MessageQueue" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/MessageQueue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息队列是一种以链表式结构组织的数据，存放在内核中，是三个IPC对象类型中最具数据操作性的数据传送方式，可以根据数据类型来检索消息，有同步互斥机制，面向数据报，全双工通信&lt;br&gt;我们可以通过命令查看/删除系统中已有的消息队列&lt;br&gt;&lt;code&gt;ipcs -q&lt;/code&gt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>SystemV信号量</title>
    <link href="https://ranjiahao.github.io/2020/05/12/SystemV%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://ranjiahao.github.io/2020/05/12/SystemV%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-05-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了防止出现因多个进程同时访问一个共享资源引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。信号量就可以提供这样的一种访问机制，确保多个线程在对共享内存这样的共享资源同时读写时，使之实现同步与互斥，也就是说信号量用来<mark>调协进程对公共资源的访问的</mark><br>信号量本质上是一个计数器，也是临界资源，进程对其访问都是原子操作，信号量记录着临界资源的个数<br>信号量可以使用ipcs -s查看<br>使用ipcrm -s [semid]删除</p><h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1><p>信号量只能进行等待和发送信号两种操作，即P(sv)和V(sv)<br>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程并将其PCB放入队列中<br>V(sv)：如果等待队列中有其他进程因等待sv而被挂起，就让一个恢复运行，如果没有进程因等待sv而挂起，就给它加1<br>所以一个信号量不仅包含临界资源的数目，还必须维护一个队列<br>实际应用中信号量是不能单独定义的，而是定义一个信号量集，其中包含一组信号量，同一信号集中的信号量使用同一个引用ID，每个信号量集有一个与之对应的结构体，其中记录着各种信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">// 指向sem结构数组，数组中每一个元素对应一个信号量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">// 信号量的个数</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 时间相关描述</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中struct sem才是信号量的描述结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="keyword">pid_t</span> semid; <span class="comment">// 上一次进行操作的进程号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt; <span class="comment">// 等待可利用资源出现的进程数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">// 等待全部资源可被独占的进程数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统中的限制：<br>SEMVMX最大的信号值<br>SEMMNI系统允许的最大信号量集个数<br>SEMMNS系统允许的最大信号量个数<br>SEMMSL每个信号集中最大的信号量个数</p><h1 id="创建打开信号集"><a class="markdownIt-Anchor" href="#创建打开信号集"></a> 创建/打开信号集</h1><blockquote><p><code>int semget(key_t key, int nsems, int semflg);</code><br>参数key和semflg用法和共享内存相同<br>nsems: 信号量集中创建的信号量数量，如果创建信号集，sem_nsems将被设置为nsems；如果打开一个已存在的信号集，此参数就被忽略<br>如果调用成功，则返回信号量集合标识符，否则返回-1，并设置error</p></blockquote><h1 id="操作信号量集原子操作"><a class="markdownIt-Anchor" href="#操作信号量集原子操作"></a> 操作信号量集（原子操作）</h1><blockquote><p><code>int semop(int semid, struct sembuf *sops, unsigned nsops);</code><br>semid: semget返回的信号量集标识符<br>sops: 为sembuf结构数组指针，每一个元素表示一个操作，这个函数是一个原子操作，一旦执行就将执行数组中所有的操作<br>nsops: 为数组中元素的个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">// 表示信号量集中某一信号量序号(0~ipc_perm.sem_nsems)</span></span><br><span class="line"><span class="keyword">short</span> sem_op; <span class="comment">// 所执行的操作，如-1表示P操作消耗一个临界资源， 1表示V操作释放了一个临界资源</span></span><br><span class="line"><span class="keyword">short</span> sem_flg; <span class="comment">// 0表示没资源时阻塞等待，IPC_NOWAIT非阻塞，SEM_UNDO（将已申请的信号量还原为初识状态，即刚开始获得这个信号量时的状态）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制信号量集"><a class="markdownIt-Anchor" href="#控制信号量集"></a> 控制信号量集</h1><blockquote><p><code>int semctl(int semid, int semnum, int cmd, ...);</code><br>semid: semget返回的信号集标识符<br>semnum: 信号集中信号量的序号<br>cmd: 将要采取的动作<br>根据cmd参数具体内容，IPC_RMID删除信号量，可能有第四个参数，是一个联合体，当cmd为GET时返回对应值<br>成功返回0，失败返回-1，设置errno</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line"><span class="keyword">int</span> val; <span class="comment">// 用于SETVAL/GETVAL命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">// 用于IPC_STAT/IPC_SET命令，输入/输出型参数表示存放信号量集数据结构缓冲区</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>* _<span class="title">buf</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作演示"><a class="markdownIt-Anchor" href="#操作演示"></a> 操作演示</h1><p>子进程循环输出A和A到显示器上这2个A中间不可被打断<br>父进程循环输出B和B到显示器上这2个B中间不可被打断</p><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/Semaphore" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了防止出现因多个进程同时访问一个共享资源引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。信号量就可以提供这样的一种访问机制，确保多个线程在对共享内存这样的共享资源同时读写时，使之实现同步与互斥，也就是说信
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>SystemV共享内存</title>
    <link href="https://ranjiahao.github.io/2020/05/07/SystemV%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>https://ranjiahao.github.io/2020/05/07/SystemV%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</id>
    <published>2020-05-06T16:00:00.000Z</published>
    <updated>2020-05-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>共享内存就是将同一块物理内存映射到不同进程虚拟内存的共享区域，实现两个进程间通信。一旦这样的内存映射到进程地址空间的共享区，这些进程间数据传递不再涉及到内核，不再通过执行进入内核的系统调用来传递彼此的数据，所以说共享内存是最快的IPC形式<br>我们可以通过命令查看/删除系统中已有的共享内存<br><code>ipcs -m</code>/<code>ipcrm -m [shmid]</code><br>相关操作（系统调用）：</p><h1 id="创建共享内存"><a class="markdownIt-Anchor" href="#创建共享内存"></a> 创建共享内存</h1><p><code>int shmget(key_t key, size_t size, int shmflg);</code><br>key:进程对共享内存的访问都是间接的，需要提供一个参数key（非0整数，可为ftok() 的返回值，也可以用自己的宏）来告诉操作系统需要哪个共享内存，然后系统返回对应共享内存的标识符，失败返回-1，并设置errno<br>size:共享内存大小，PAGE_SIZE页面大小(4096)的整数倍，因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍<br>shmflg:由九个权限标志构成，用法和创建文件时使用的mode模式标志是一样的<br>IPC_CREAT：如果不存在就创建<br>IPC_EXCL： 如果已经存在则返回失败<br>位或权限位：共享内存位或权限位后可以设置共享内存的访问权限，格式和 open() 函数的 mode_t 一样，但可执行权限未使用</p><p><strong>共享内存数据结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* operation perms */</span></span><br><span class="line">    <span class="keyword">int</span> shm_segsz; <span class="comment">/* size of segment (bytes) */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_atime; <span class="comment">/* last attach time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_dtime; <span class="comment">/* last detach time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_ctime; <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> shm_cpid; <span class="comment">/* pid of creator */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> shm_lpid; <span class="comment">/* pid of last operator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> shm_nattch; <span class="comment">/* no. of current attaches */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> shm_unused; <span class="comment">/* compatibility */</span></span><br><span class="line">    <span class="keyword">void</span> *shm_unused2; <span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line">    <span class="keyword">void</span> *shm_unused3; <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="建立映射关系"><a class="markdownIt-Anchor" href="#建立映射关系"></a> 建立映射关系</h1><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code><br>shmid: 共享内存标识（shmget返回值）<br>shmaddr: 映射地址，通常为空，让系统来选择共享内存的地址；若不为NULL且shmflg无SHM_RND标记，若设置SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍<br>shmflg:<br>SHM_RDONLY:只读<br>0:共享内存具有可读可写权限<br>返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1，并设置errno</p><h1 id="解除映射"><a class="markdownIt-Anchor" href="#解除映射"></a> 解除映射</h1><p><code>int shmdt(const void *shmaddr);</code><br>shmaddr: 由shmat所返回的指针<br>成功返回0；失败返回-1，并设置errno</p><h1 id="控制共享内存"><a class="markdownIt-Anchor" href="#控制共享内存"></a> 控制共享内存</h1><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p><p>shmid:由shmget返回的共享内存标识码<br>cmd:IPC_RMID删除共享内存、IPC_STAT获取共享内存的当前关联值、IPC_SET根据buf设置共享内存关联值。注意：共享内存删除不会直接删除，而是判断映射连接数是否为0，为0直接删除否则拒绝后续其他进程的映射连接，为0时自动删除<br>buf:保存着共享内存的模式状态和访问权限的数据结构，输入输出型参数<br>成功返回0；失败返回-1</p><p>共享内存并未提供同步机制，一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，比如信号量</p><h1 id="关于函数ftok"><a class="markdownIt-Anchor" href="#关于函数ftok"></a> 关于函数ftok</h1><p>shmget函数中的第一个参数key相当于共享内存的钥匙，可以通过它能访问唯一的内存区域。由于key和内存是一一对应的，所以我们不难想到用这块内存的inod节点来生成密钥，这就有了ftok函数<br><code>key_t ftok(const char *pathname, int proj_id);</code><br>pathname就时你指定的文件名(该文件必须是存在而且可以访问的)，proj_id是子序号，虽然为int，但是只有8个比特被使用(0-255)<br>成功返回key值，失败返回-1</p><p>生成规则：返回的整数IPC键由proj_id的低序8位，struct stat中st_dev成员的低序8位，st_ino的低序16位组合而成</p><p>注意事项：<br>pathname指定的目录（文件）不能在程序运行期间删除或创建。因为文件每次创建时由系统赋予的索引节点可能不一样。这样一来，通过同一个pathname与proj_id就不能保证生成同一个IPC键</p><h1 id="代码实现server和client的交互"><a class="markdownIt-Anchor" href="#代码实现server和client的交互"></a> 代码实现server和client的交互</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/SharedMemory" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/SharedMemory</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;共享内存就是将同一块物理内存映射到不同进程虚拟内存的共享区域，实现两个进程间通信。一旦这样的内存映射到进程地址空间的共享区，这些进程间数据传递不再涉及到内核，不再通过执行进入内核的系统调用来传递彼此的数据，所以说共享内存是最快的IPC形式&lt;br&gt;我们可以通过命令查看/删除系
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>管道</title>
    <link href="https://ranjiahao.github.io/2020/05/06/%E7%AE%A1%E9%81%93/"/>
    <id>https://ranjiahao.github.io/2020/05/06/%E7%AE%A1%E9%81%93/</id>
    <published>2020-05-05T16:00:00.000Z</published>
    <updated>2020-05-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个进程各自有不同的用户地址空间，都是独立运行，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程把数据从用户空间拷到内核缓冲区，另一个进程再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信<br>我们常用 ‘|’ 符号来用一个命令来处理另一个命令的显示结果<br><code>cat test.c | less</code><br>这个过程本质上是创建cat进程传入参数test.c然后这个进程从用户态切换到内核态，将数据拷贝到内核中的缓冲区中，然后less进程切换到内核态取走缓冲区中的数据，返回用户态并处理数据。这个内核中的缓冲区就叫管道<br>管道的生命周期随进程，进程结束以后，相应的管道也会自动释放。有同步互斥机制、面向字节流的通信、半双工通信</p><h1 id="匿名管道"><a class="markdownIt-Anchor" href="#匿名管道"></a> 匿名管道</h1><blockquote><p>系统调用<br><code>int pipe(int pipefd[2]);</code><br>fd为输出型参数，传入一个空数组，返回文件描述符数组，fd[0]表示读端fd[1]表示写端，成功返回0，失败返回错误代码-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"creat pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程写数据，关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> mesg[] = <span class="string">"I am child"</span>;</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], mesg, <span class="built_in">strlen</span>(mesg));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child write:%s\n"</span>, mesg);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程读数据，关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> mesg[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], mesg, <span class="number">1023</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"father read:%s\n"</span>, mesg);</span><br><span class="line">        &#125;</span><br><span class="line">        waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="gif1.gif" alt="gif1"><br>父进程创建fd[2]数组，子进程fork后，fork了fd中的文件描述符，因此他们可以共同访问内核中的缓冲区（管道），也就是说这种方式仅适用与具有亲缘关系的进程<br><img src="img1.png" alt="img1"></p><h1 id="命名管道"><a class="markdownIt-Anchor" href="#命名管道"></a> 命名管道</h1><p>由于匿名管道只可用于具亲缘关系的进程间通信，所以我们要实现非亲缘进程间的通信就需要给这个内核中的缓冲区起个名字，使进程可以通过管道名字访问到这个内核中的缓冲区，进而实现进程间通信</p><p>可以通过mkfifo命令直接创建管道文件(此文件本质还是内核中的缓冲区)<br><code>mkfifo filename</code><br>或者通过库函数<br><code>int mkfifo(const char *filename,mode_t mode);</code><br>第一个参数为所要创建管道的全路径名，第二个参数为创建管道的权限，这里需要注意的是，该值会受到umask值的影响，所以最好先将umask的值设置为000</p><p><strong>打开规则</strong>：</p><p>open打开的时候可以通过参数O_NONBLOCK设置非阻塞</p><p>若只读打开：<br>阻塞直到有相应进程为写而打开该FIFO<br>O_NONBLOCK: 若没有进程为写而打开该FIFO，则立即返回成功</p><p>若只写打开：<br>阻塞直到有相应进程为读而打开该FIFO<br>O_NONBLOCK: 若没有进程为读而打开该FIFO，则立刻返回失败，错误码为ENXIO</p><p><strong>演示代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_write.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file = <span class="string">"./tmp.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果文件不是因为已经存在而报错，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(file, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_read.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file = <span class="string">"./tmp.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果文件不是因为已经存在而报错，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">read</span>(fd, buf, <span class="number">1023</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"read error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"write closed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"buf:[%s]\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="管道读写规则"><a class="markdownIt-Anchor" href="#管道读写规则"></a> 管道读写规则</h1><p>如果管道所有的写端都关闭，那么read循环读取完数据后返回0<br>如果写端没全部关闭，但是又不写入数据，则读端一直阻塞等待，等写端写入数据后读取</p><p>如果管道所有的读端都关闭，执行write时会产生SIGPIPE信号，导致write进程退出，进程异常终止<br>如果读端没全部关闭，但是缓冲区已经满了，则写端一直阻塞等待，等有空间在写入</p><p>若设置O_NONBLOCK则当管道满时或没有数据可读时返回-1，设置errno值为EAGAIN</p><p>当要写入的数据量不大于PIPE_BUF时（ulimit -a查看），linux将保证写入的原子性</p><p>那么系统分配的管道大小是多少呢？我们可以通过命令<br><code>cat /proc/sys/kernel/msgmax</code>查看</p><h1 id="从内核看管道"><a class="markdownIt-Anchor" href="#从内核看管道"></a> 从内核看管道</h1><p>进程向管道中写数据本质上就是创建一块内核空间并且将这个空间的inode信息放入f_inode中，将f_op设置为对这块内存的操作（读写等）然后将若干信息组织起来形成file结构体，并且将这个结构体的指针添加到进程的文件描述符数组中，这是进程就可以操作这个块内核空间了，另一个进程若想进行通信，就要使用相同的f_inode而f_op可以不同</p><h1 id="利用管道实现minishell"><a class="markdownIt-Anchor" href="#利用管道实现minishell"></a> 利用管道实现minishell</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/MiniShell" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/MiniShell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个进程各自有不同的用户地址空间，都是独立运行，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程把数据从用户空间拷到内核缓冲区，另一个进程再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信&lt;br&gt;我们常用 ‘|’ 符号来用一个命令来处理另一个命令的显
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>进程程序替换</title>
    <link href="https://ranjiahao.github.io/2020/05/03/%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2/"/>
    <id>https://ranjiahao.github.io/2020/05/03/%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行<br>系统调用：<br><code>int execve(const char* path, char* const argv[], char* const envp[]);</code><br>库函数：<br><code>int execl(const char* path, const char* arg, ...);</code><br><code>int execlp(const char* file, const char* arg, ...);</code><br><code>int execle(const char* path, const char* arg, ...,char* const envp[]);</code><br><code>int execv(const char* path, char* const argv[]);</code><br><code>int execvp(const char* file, char* const argv[]);</code><br><code>int execvpe(const char* file, char* const argv[], char* const envp[]);</code><br>规律：exec必选<br><strong>v和l必须选其一</strong></p><ul><li>l(list) : 表示参数采用列表</li><li>v(vector) : 参数用数组</li></ul><p><strong>e、p可选可不选</strong></p><ul><li>p(path) : 有p自动搜索环境变量PATH</li><li>e(env) : 表示自己维护环境变量</li></ul><p>如果调用成功则加载新的程序从启动代码开始执行，不返回<br>如果调用出错则返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123;<span class="string">"PATH=/bin:/usr/bin"</span>, <span class="string">"TERM=console"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="comment">// l和v</span></span><br><span class="line">execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">execv(<span class="string">"/bin/ls"</span>, argv);</span><br><span class="line"><span class="comment">// p和e</span></span><br><span class="line">execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">execve(<span class="string">"/bin/ls"</span>, argv, envp);</span><br></pre></td></tr></table></figure><p>这些库函数在调用时候，如果参数采用列表格式首先将参数替换成数组形式，然后如果有相对路径就在底层替换成绝对路径，然后根据自己维护的环境变量或者shell的环境变量组织envp，而后调execve接口<br>我们发现函数和进程之间有些许相似性：<br>c语言中，一个函数和一个函数可以通过return/call来通信，这类似与进程间的exit/exec&amp;fork，进程可以fork/exec，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来返回值。调用它的进程可以通过wait来获取exit的返回值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行&lt;br&gt;系统调用：&lt;br&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程终止与wait参数status</title>
    <link href="https://ranjiahao.github.io/2020/05/02/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E4%B8%8Ewait%E5%8F%82%E6%95%B0status/"/>
    <id>https://ranjiahao.github.io/2020/05/02/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E4%B8%8Ewait%E5%8F%82%E6%95%B0status/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见进程退出方法"><a class="markdownIt-Anchor" href="#常见进程退出方法"></a> 常见进程退出方法</h1><ol><li>exit或_exit退出<br>_exit系统调用函数：<code>void _exit(int status);</code><br>参数status定义了进程的终止状态，父进程通过wait获取该值。<br>虽然status是int，但是仅有低8位可以被父进程所用，实际上就是子进程的返回值。<br>exit库函数：<code>void exit(int status);</code><br>和_exit唯一的区别是退出前执行用户通过atexit或on_exit定义的清理函数然后刷新缓存关闭所有打开的流，最后调用_exit函数退出</li><li>return退出，和exit一样，exec/exit针对进程间通信，就像call/return针对函数间通信</li><li>信号终止</li></ol><h1 id="常见进程等待方法"><a class="markdownIt-Anchor" href="#常见进程等待方法"></a> 常见进程等待方法</h1><ol><li>wait系统调用函数（阻塞）<code>pid_t wait(int* status);</code><br>status为输出型参数，NULL表示不关心子进程状态<br>返回值：成功返回被等待进程的pid，失败返回-1</li><li>waitpid系统调用函数<br><code>pid_ t waitpid(pid_t pid, int* status, int options);</code><br>参数pid若为-1则等待任意一个进程，若&gt;0则等待特定的进程<br>参数options若为0则阻塞，若为WNOHANG则非阻塞</li></ol><h1 id="wait参数statu"><a class="markdownIt-Anchor" href="#wait参数statu"></a> wait参数statu</h1><p>status不仅仅是一个int类型参数，可以看作是一个位图<br>只研究其低16位：<br><img src="img1.png" alt="img1"><br>我们可以通过status &amp; 0x7f来判断异常信号是否为0；<br>若为0，则正常退出，然后可以通过(status &gt;&gt; 8) &amp; 0xff来获取子进程返回值。<br>sys/wait.h中提供了一些宏来简化这些操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">    <span class="comment">// 正常退出：((status) &amp; 0x7f) == 0</span></span><br><span class="line">    <span class="comment">// 打印退出码：(status &gt;&gt; 8) &amp; 0xff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child return: %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">    <span class="comment">// 异常退出：((signed char) (((status) &amp; 0x7f) + 1) &gt;&gt; 1) &gt; 0</span></span><br><span class="line">    <span class="comment">// 打印异常信号值：(status) &amp; 0x7f</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child signal: %d\n"</span>, WTERMSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见进程退出方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常见进程退出方法&quot;&gt;&lt;/a&gt; 常见进程退出方法&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;exit或_exit退出&lt;br&gt;_exit系统调用函数：&lt;code&gt;void _exit(int s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>fork、vfork、clone、system、popen</title>
    <link href="https://ranjiahao.github.io/2020/05/01/fork%E3%80%81vfork%E3%80%81clone%E3%80%81system%E3%80%81popen/"/>
    <id>https://ranjiahao.github.io/2020/05/01/fork%E3%80%81vfork%E3%80%81clone%E3%80%81system%E3%80%81popen/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-04-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h1><blockquote><p>系统调用：<code>pid_t fork(void);</code><br>子进程返回0，父进程返回子进程pid<br>出错返回-1，子进程不会被创建，会设置errno</p></blockquote><p>错误原因可能是：系统中有太多的进程，实际用户的进程数超过了限制，命令ulimit -a中max user processes可查看用户最大能创建的进程数<br>fork后，就有两个二进制代码相同的进程，都运行到相同的地方，由调度器决定谁先执行。<br>子进程是父进程的一份拷贝，代码共享，数据独有<br>代码共享：共享代码段，父子进程的指令双方都能看到<br>数据独有：数据段、堆、栈</p><h2 id="fork都做了那些事"><a class="markdownIt-Anchor" href="#fork都做了那些事"></a> fork都做了那些事？</h2><p>进程调用fork，由用户态切换到内核态<br>分配新的内存块和内核数据结构给子进程<br>将父进程部分数据结构内容拷贝至子进程<br>添加子进程到系统进程列表当中<br>fork返回，开始调度器调度</p><h2 id="写实拷贝"><a class="markdownIt-Anchor" href="#写实拷贝"></a> 写实拷贝</h2><p>通常，父子代码共享，父子再不写入时，数据也是共享的，子进程复制了父进程的task_struct，系统堆栈空间和页面表<br>任意一方写入时，便在物理空间中创建一份副本进行修改，并且映射到相同的虚拟地址空间中</p><p>也就是说：父进程和子进程共享物理页帧而不是复制页帧。只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的。当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的</p><h1 id="vfork"><a class="markdownIt-Anchor" href="#vfork"></a> vfork</h1><blockquote><p>系统调用<code>pid_t vfork(void);</code><br>调用方法和返回值和fork相同</p></blockquote><p>说起fork就不得不提类似的vfork，它直接共享了父进程的虚拟空间、物理空间，所以如果子进程（轻量级进程）修改数据则父进程会收到影响。也就是说子进程不可以return或者exit。但是可以_exit退出</p><p>子进程会导致父进程挂起，除非子进程exit或者execve才会唤起父进程</p><p>vfork存在的意义是为了快速创建进程，并且通过程序替换来运行其他程序，因为共享地址空间可以减少拷贝时间。但是自从fork实现写实拷贝后，此接口就几乎被淘汰了</p><h1 id="clone"><a class="markdownIt-Anchor" href="#clone"></a> clone</h1><blockquote><p>系统调用：<code>int clone(int (*fn)(void*), void* child_stack, int flags, void* arg);</code><br>fn 是需要执行的函数指针，即 clone 出来的子进程需要执行的函数内容。<br>child_stack 就明显是给子进程分配的系统堆栈空间的位置。（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值）<br>flags 用于描述子进程需要从父进程中继承哪些部分的内容，因此通过这个值可以控制产生进程、线程、甚至非父子关系而是兄弟关系的进程等等，功能强大（可以说是一个轻量级进程的系统调用）<br>arg就是传给子进程的参数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid:%d\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* <span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="number">8192</span>);</span><br><span class="line">    <span class="comment">// clone()第二个参数指定的是栈空间，栈是反向增长，</span></span><br><span class="line">    <span class="comment">// 所以这里传入申请的空间的尾部</span></span><br><span class="line">    <span class="keyword">int</span> pid = clone(&amp;Test, (<span class="keyword">char</span>*)<span class="built_in">stack</span>+<span class="number">8192</span>, CLONE_PARENT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Father pid:%d, child pid:%d\n"</span>, getpid(), pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="system"><a class="markdownIt-Anchor" href="#system"></a> system</h1><blockquote><p>库函数<code>int system(const char *command);</code><br>system()执行通过创建子进程执行/bin/sh -c命令指定的命令，并在命令完成后返回,在执行命令的时候,SIGCHLD将被阻塞，SIGINT和SIGQUIT将被忽略。<br>command:命令参数是指向包含shell命令行的以null结尾的字符串的指针。这个命令被传递给/bin/sh使用。<br>返回值:<br>fork()失败,返回-1<br>exec()失败,返回值相当于执行了exit(127)<br>参数command为NULL时返回1<br>system在执行期间调用进程会一直等待shell命令执行完成(waitpid等待子进程结束)才返回</p></blockquote><h1 id="popenpclose"><a class="markdownIt-Anchor" href="#popenpclose"></a> popen/pclose</h1><blockquote><p>库函数：<br><code>FILE *popen(const char *command, const char *type);</code><br><code>int pclose(FILE *stream);</code></p></blockquote><p>popen会调用fork产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令，参数type可用r代表读取，w代表写入。依照此type的值，popen会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可以利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中，若成功则返回文件指针，否则返回NULL,错误原因存在于errno中<br>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* fd = popen(<span class="string">"./cin"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fd, <span class="string">"hehe"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 保证popen打开的进程先退出</span></span><br><span class="line">    pclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cin.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ test.cc -o test</code><br><code>g++ cin.cc -o cin</code><br>然后执行<br><code>./cin</code><br><code>./test</code><br>一秒后输出<strong>hehe</strong><br>这个一个异步执行的过程：test进程调用popen后fork一个子进程调用exec函数去执行command，然后cin进程启动阻塞到cin&gt;&gt;阶段，同时popen返回管道的描述符，fprintf将数据写入管道中，此时cin就被唤醒，打印数据信息<br>如果不加sleep函数，可能父进程在子进程还没打印的时候先退出，就会变成孤儿进程，因此可能在标头之后打印。</p><h1 id="do_fork"><a class="markdownIt-Anchor" href="#do_fork"></a> do_fork</h1><blockquote><p>内核函数：<code>do_fork(unsigned long clone_flag, unsigned long usp, structpt_regs)</code><br>fork、vfork、clone最底层涉及到的都是 do_fork() 这个调用，只是传入参数不同，clone 可以认为就是个 do_fork() 的API外衣</p></blockquote><p>其中clone_flag为：</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>CLONE_PARENT</td><td>创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td></tr><tr><td>CLONE_FS</td><td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td></tr><tr><td>CLONE_FILES</td><td>子进程与父进程共享相同的文件描述符（file descriptor）表</td></tr><tr><td>CLONE_NEWNS</td><td>在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td></tr><tr><td>CLONE_SIGHAND</td><td>子进程与父进程共享相同的信号处理（signal handler）表</td></tr><tr><td>CLONE_PTRACE</td><td>若父进程被trace，子进程也被trace</td></tr><tr><td>CLONE_VFORK</td><td>父进程被挂起，直至子进程释放虚拟内存资源</td></tr><tr><td>CLONE_VM</td><td>子进程与父进程运行于相同的内存空间</td></tr><tr><td>CLONE_PID</td><td>子进程在创建时PID与父进程一致</td></tr><tr><td>CLONE_THREAD</td><td>Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td></tr></tbody></table><p>任何一位被置1了则表明创建的子进程和父进程共享该位对应的资源</p><p>vfork中clone_flag = CLONE_VFORK | CLONE_VM |SIGCHLD<br>这表示子进程和父进程共享地址空间、共享相同的信号处理表，同时do_fork会检查CLONE_VFORK，如果该位被置1了，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁</p><p>fork中clone_flag=SIGCHLD</p><h1 id="两道有意思的面试题"><a class="markdownIt-Anchor" href="#两道有意思的面试题"></a> 两道有意思的面试题</h1><p><strong>判断创建几个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fork() &amp;&amp; fork()) || fork()) &#123;</span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为8个，可以通过pstree命令查看：<br><img src="img1.png" alt="img1"><br>分析：<br>主进程从左到右，子进程从上到下执行。<br><img src="img2.png" alt="img1"></p><p><strong>判断输出*的个数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出6个*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出8个*，注意没有\n来刷新缓冲区，则子进程会拷贝父进程缓冲区中的数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fork&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork&quot;&gt;&lt;/a&gt; fork&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;系统调用：&lt;code&gt;pid_t fork(void);&lt;/code&gt;&lt;br&gt;子进程返回0，父进程返回子进程p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="fork" scheme="https://Ranjiahao.github.io/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>main函数的三个参数</title>
    <link href="https://ranjiahao.github.io/2020/04/17/main%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
    <id>https://ranjiahao.github.io/2020/04/17/main%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>C程序总是从main函数开始执行的，main函数的原型是：<br><code>int main(int argc, char* argv[], char* env[])</code></p><h1 id="argc与argv"><a class="markdownIt-Anchor" href="#argc与argv"></a> argc与argv</h1><p>argc表示传入main函数的参数个数<br>argv[]表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d]=[%s]\n"</span>,i,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段程序<code>gcc main.c -o main</code>生成可执行程序main<br><code>./main</code>运行：输出结果为argv[0]=[./main]<br><code>./main -a abc</code>运行：输出结果为<br>argv[0]=[./main]<br>argv[1]=[-a]<br>argv[2]=[abc]</p><p>可以总结出以下几点：<br>argv[0] 指向程序运行的全路径名 　　<br>argv[1] 指向在DOS命令行中执行程序名后的第一个字符串 　　<br>argv[2] 指向执行程序名后的第二个字符串<br>…<br>argv[argc]为NULL</p><h1 id="env"><a class="markdownIt-Anchor" href="#env"></a> env</h1><p>每个进程都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以NULL结尾的环境字符串，env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value 为ENVVAR的对应值<br>环境变量通常具有全局特性，系统设置更加方便(切换用户会还原)</p><h2 id="常见的环境变量"><a class="markdownIt-Anchor" href="#常见的环境变量"></a> 常见的环境变量</h2><p>PATH: 命令的搜索路径<br>HOME: 用户家目录<br>SHELL: 当前Shell通常是/bin/bash</p><h2 id="环境变量相关命令"><a class="markdownIt-Anchor" href="#环境变量相关命令"></a> 环境变量相关命令</h2><p><code>echo $(NAME)</code>可以查看指定环境变量<br><code>export (val)</code>声明一个新的环境变量<br><code>env</code>显示所有环境变量<br><code>unset (NAME)</code>清除环境变量<br><code>set</code>显示本地定义的shell变量和环境变量</p><h2 id="通过代码查看环境变量"><a class="markdownIt-Anchor" href="#通过代码查看环境变量"></a> 通过代码查看环境变量</h2><p>由于环境变量具有继承特性，我们可以创建进程来继承shell的环境变量并且打印出来</p><ul><li>通过第三个参数获得</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过libc中定义的全局变量environ获取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; environ[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过系统调用接口获取或设置环境变量</li></ul><p>getenv 和putenv 也是定义在stdlib.h 中，函数原型如下：</p><p><code>char *getenv(const char *name);</code><br><code>int putenv(char *str);</code></p><h2 id="main执行和main执行"><a class="markdownIt-Anchor" href="#main执行和main执行"></a> ./main执行和main执行</h2><p>有些指令可以直接执行，不需要带路径，而我们写的可执行程序必须要加上路径，这是由于默认的搜索路径为PATH，我们只需将PATH修改即可：<br><code>PATH=$PATH:./</code><br>但是需要注意的是不要覆盖PATH防止类似ls的命令用不了</p><h2 id="是否应该使用第三个参数env"><a class="markdownIt-Anchor" href="#是否应该使用第三个参数env"></a> 是否应该使用第三个参数env</h2><p>ISO C/ISO C++ ,POSIX 标准都不支持main三个参数的定义形式，VC和GNU编译器都扩展了main函数的定义，所以目前可以这样使用。如果要编写更加可移植的程序，应该使用全局环境变量environ来代替env的作用，如果要访问特定的环境变量，应该使用getenv和putenv函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C程序总是从main函数开始执行的，main函数的原型是：&lt;br&gt;&lt;code&gt;int main(int argc, char* argv[], char* env[])&lt;/code&gt;&lt;/p&gt;&lt;h1 id=&quot;argc与argv&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="环境变量" scheme="https://Ranjiahao.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>进程基础</title>
    <link href="https://ranjiahao.github.io/2020/04/16/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://ranjiahao.github.io/2020/04/16/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程是程序执行时的一个实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，是当前状态和相关系统资源描述的活动单元</p><h1 id="进程与可执行程序的区别"><a class="markdownIt-Anchor" href="#进程与可执行程序的区别"></a> 进程与可执行程序的区别</h1><p>可执行程序是指令和数据的集合，作为一种数据资料长期存在，是一个静态概念。而进程是可执行程序的一次执行过程，是有生命期，是暂时的，是一个动态概念。所以同一个可执行程序可以对应多个进程</p><h1 id="进程标识方法"><a class="markdownIt-Anchor" href="#进程标识方法"></a> 进程标识方法</h1><h2 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h2><p>进程信息被放在一个叫做进程控制块的数据结构，linux下就是task_struct结构体，其中主要内容有：<br>标识符：PID标识和PPID等<br>状态：任务状态，退出代码，退出信号等<br>优先级：相对于其他进程的优先级<br>程序计数器：程序中即将被执行的下一条指令的地址<br>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针<br>上下文数据：进程执行时处理器的寄存器中的数据<br>I／O状态信息：包括显示的IO请求，分配给进程的IO设备和被进程使用的文件列表<br>记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等<br>其他信息</p><h2 id="pid与ppid"><a class="markdownIt-Anchor" href="#pid与ppid"></a> PID与PPID</h2><p>标识和区分进程的ID，是在当前linux系统中唯一的非负整数。进程运行时PID由操作系统随机分配，同一个程序运行两次会产生两个进程，也就有两个不同的PID</p><p>每个进程除了一定有PID还会有PPID(1号进程除外)通过PPID可以找到父进程的信息</p><p>PID为1的进程是由内核创建的init进程，其他子进程都是由它衍生出来，所有进程都来自于一个进程，所以Linux的进程模型也叫做进程树<br>查看方式：<br>可以通过/proc系统文件夹查看<br>通过top或者ps -ef命令来查看<br>通过系统调用函数getpid()getppid()</p><h1 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h1><p>R运行状态：并不意味着进程一定在运行中，同一时刻可能有多个进程处于此状态，这些进程的task_struct结构被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）它表明进程要么是在运行中，要么在运行队列里。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行</p><p>S可中断睡眠状态：意味着进程在等待某时间的发生（如，等待资源），这些进程的task_struct结构被放入对应事件的等待队列中，当这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒</p><p>D不可中断的睡眠状态：指进程不响应异步信号，因此无法用kill杀掉，除非reboot，通常此状态是在等待IO，比如磁盘IO，网络IO，其他外设IO</p><p>T暂停状态、t跟踪状态：ctrl+z可以通过发送SIGSTOP信号，暂停状态，这个被暂停的进程可以通过发送SIGCONT信号让进程继续运行。跟踪状态是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于跟踪状态，跟踪状态的进程不能响应sigcont信号而被唤醒，只能等到调试进程通过ptrace系统调用执行</p><p>X死亡状态：这个状态只是一个返回状态，你不会在任务列表里看到这个状态</p><p>Z僵尸进程：当子进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码</p><h1 id="进程优先级"><a class="markdownIt-Anchor" href="#进程优先级"></a> 进程优先级</h1><p>cpu资源分配的先后顺序，就是指进程的优先级。由于linux是多任务环境的，所以配置优先级可以改善系统性能。还可以把进程运行到指定的CPU上，把不重要的进程安排到某个CPU，可大大改善系统整体性能</p><h2 id="pri与ni"><a class="markdownIt-Anchor" href="#pri与ni"></a> PRI与NI</h2><p>命令ps -l可查看进程的PRI与NI，PRI为进程的优先级，越小优先级别越高；NI为优先级修正数值；所以PRI(new)=PRI(old)+NI，所以，调整进程优先级，Linux下，就是调整进程NI值。NI其取值范围是-20至19，一共40个级别，PRI默认为80</p><h2 id="更改ni"><a class="markdownIt-Anchor" href="#更改ni"></a> 更改NI</h2><p>进入top后按“r”–&gt;输入进程PID–&gt;输入nice值<br>renice -n (ni_val) -p (pid)<br>nice -n (ni_val) ./exe —在运行的时候直接设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是程序执行时的一个实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，是当前状态和相关系统资源描述的活动单元&lt;/p&gt;&lt;h1 id=&quot;进程与可执行程序的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程与可执行程序的区别
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序总结</title>
    <link href="https://ranjiahao.github.io/2020/04/08/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://ranjiahao.github.io/2020/04/08/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">额外空间复杂度</th><th style="text-align:center">in-place</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">true</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">true</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n<sup>2</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">true</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(n * log n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">false</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(n * log n)</td><td style="text-align:center">O(log n)</td><td style="text-align:center">true</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(n<sup>1.3</sup>)</td><td style="text-align:center">O(1)</td><td style="text-align:center">true</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(n * log n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">true</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">O(max(n,范围))</td><td style="text-align:center">O(范围)</td><td style="text-align:center">false</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(p(n+b))</td><td style="text-align:center">O(n+b)</td><td style="text-align:center">false</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">O(n + n(log n - log m))</td><td style="text-align:center">O(m+n)</td><td style="text-align:center">false</td><td style="text-align:center">依赖于桶内排序</td></tr></tbody></table><p>冒泡排序：n比较小时考虑采用、实现简单但速度慢、每次只移动相邻两个元素</p><p>选择排序：n比较小时考虑采用、实现简单但速度慢、移动次数较少但不稳定、数据不敏感</p><p>插入排序：n比较小时考虑采用、实现简单但速度慢、由于元素移动代价小于元素交换代价所以速度略优于冒泡排序、n越小越有序效率越高</p><p>归并排序：n比较大时考虑采用、数据不敏感、需要O(n)额外空间</p><p>快速排序：n比较大时考虑采用、速度快元素移动少但不稳定、序列越乱，效率越高</p><p>希尔排序：在中小型数组中效率特别快、比较是其中最主要的操作、不稳定</p><p>堆排序：适合处理海量数据、不稳定、数据不敏感</p><p>计数排序：当数据范围比较小时速度非常快</p><p>基数排序：适合多关键字排序</p><p>桶排序：当范围已经知道，而且空间不是很重要的情况下考虑采用桶排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:center&quot;&gt;名称&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;平均时间复杂度&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;额外空间复杂度&lt;/th&gt;&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基排序</title>
    <link href="https://ranjiahao.github.io/2020/04/07/%E5%9F%BA%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/07/%E5%9F%BA%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-04-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于桶排序来实现。通过键值的部分信息，将要排序的元素分配至某些“桶”中，以此达到排序的作用。基数排序的方式可以采用LSD或MSD，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始<br>时间复杂度：O(p(n+b))<br>其中：分配为O(n)、收集为O(b)、p为收集分配趟数<br>空间复杂度：O(n+b)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设元素最多有MaxDigit个关键字，基数全是同样的Radix</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxDigit 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Radix 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认次位D=1, 主位D&lt;=MaxDigit</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序 - 次位优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LSDRadixSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(Radix);</span><br><span class="line">    <span class="comment">// 将原始序列存入链表list</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> D = <span class="number">1</span>; D &lt;= MaxDigit; D++) &#123;</span><br><span class="line">        <span class="comment">// 分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : <span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> Di = GetDigit(i, D);</span><br><span class="line">            arr[Di].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收集</span></span><br><span class="line">        <span class="built_in">list</span>.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : arr) &#123;</span><br><span class="line">            <span class="built_in">list</span>.insert(<span class="built_in">list</span>.end(), l.begin(), l.end());</span><br><span class="line">            l.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将list倒入array[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = *<span class="built_in">list</span>.begin();</span><br><span class="line">        <span class="built_in">list</span>.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心递归函数：对array[L]...array[R]的第D位数进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSD</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (D == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(Radix);</span><br><span class="line">    <span class="comment">// 将原始序列存入链表list</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Di = GetDigit(i, D);</span><br><span class="line">        arr[Di].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集</span></span><br><span class="line">    <span class="keyword">int</span> left = L;</span><br><span class="line">    <span class="keyword">int</span> right = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : l) &#123;</span><br><span class="line">            <span class="built_in">array</span>[right++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归对该桶数据排序，位数减1</span></span><br><span class="line">        MSD(<span class="built_in">array</span>, left, right - <span class="number">1</span>, D - <span class="number">1</span>);</span><br><span class="line">        left = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序 - 主位优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSDRadixSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    MSD(<span class="built_in">array</span>, <span class="number">0</span>, size - <span class="number">1</span>, MaxDigit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于桶排序来实现。通过键值的部分信息，将要排序的元素分配至某些“桶”中，以此达到排序的作用。基数排序的方式可以采用LSD或MSD，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始&lt;br&gt;时间复杂度：O(p(n+b))&lt;br&gt;其中：分配为O(n)、收集为
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="https://ranjiahao.github.io/2020/04/06/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/06/%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>将数组分到有限数量的桶子里，每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序<br>时间复杂度：<br>最好：对于n个待排数据，m个桶，当n=m时，极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(n)<br>最坏：当m=1时，即极限情况下只有一个桶时。桶排序的最坏效率达到O(n * log n)<br>平均：n + n + n/m * log(n/m ) * m + n = 3n + n(log n - log m) = O(n + n(log n - log m))<br>空间复杂度：O(m + n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">double</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求数组最大值和最小值，并算出差值d</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> min = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; min) &#123;</span><br><span class="line">            min = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d = max - min;</span><br><span class="line">    <span class="comment">// 一般创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定</span></span><br><span class="line">    <span class="comment">// OR 桶数量等于原始数列的元素数量+1，除了第一个桶只包含数列最小值，最后一个桶只包含数列最大值，中间各个桶的区间按照比例确定</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;&gt; bucketArr(bucketNum);</span><br><span class="line">    <span class="comment">// 遍历数组，将每个元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>)((<span class="built_in">array</span>[i] - min) * (bucketNum - <span class="number">1</span>) / d);</span><br><span class="line">        bucketArr[num].push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个桶内部进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">        bucketArr[i].sort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入数组</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : bucketArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : bucket) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i++] = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将数组分到有限数量的桶子里，每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序&lt;br&gt;时间复杂度：&lt;br&gt;最好：对于n个待排数据，m个桶，当n=m时，极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(n)&lt;br&gt;最坏：当m=1时，即极
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="https://ranjiahao.github.io/2020/04/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上<br>时间复杂度：O(max(n,范围))<br>空间复杂度：O(范围)<br>稳定性：稳定<br>优点：计数排序在数据范围集中时，效率很高<br>缺点：当数列元素不是整数或最大最小值差距过大时，并不适用计数排序</p><h1 id="初步实现"><a class="markdownIt-Anchor" href="#初步实现"></a> 初步实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大数和最小数，确定序列的范围</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; min) &#123;</span><br><span class="line">            min = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rang为序列的范围，开辟额外数组，初始化全为0</span></span><br><span class="line">    <span class="keyword">int</span> rang = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* countArr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * rang);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rang; ++i) &#123;</span><br><span class="line">        countArr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        countArr[<span class="built_in">array</span>[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将序列拷贝回原序列</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rang; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (countArr[i]--) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(countArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h1><p>从功能上看，这段代码只是简单地按照统计数组的下标输出了元素值，并没有真正给原始数列进行排序。如果放在现实业务里，比如给学生的考试分数排序，遇到相同的分数就会分不清谁是谁。我们需要稍微改变之前的逻辑，对统计数组做一下变形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span> sortArr[],<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大数和最小数，确定序列的范围</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; min) &#123;</span><br><span class="line">            min = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rang为序列的范围，开辟额外数组，初始化全为0</span></span><br><span class="line">    <span class="keyword">int</span> rang = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* countArr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * rang);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rang; ++i) &#123;</span><br><span class="line">        countArr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        countArr[<span class="built_in">array</span>[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对所有的计数累加   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rang; i++) &#123;</span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sortArr[--countArr[<span class="built_in">array</span>[i] - min]] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(countArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上&lt;br&gt;时间复杂度：O(max(n,范围))&lt;br&gt;空间复杂度：O(范围)&lt;br&gt;稳定
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://ranjiahao.github.io/2020/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。经常被使用的是二路归并算法，即将两个已经排序的序列合并成一个序列的操作<br>时间复杂度：O(n * log n) 数据不敏感<br>空间复杂度：O(n)<br>稳定性：稳定<br>时间复杂度计算过程：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mi>T</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>3</mn></msup><mi>T</mi><mo stretchy="false">[</mo><mi>n</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>3</mn></msup><mo stretchy="false">]</mo><mo>+</mo><mn>3</mn><mi>n</mi><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mi>T</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">T[n]=2T[n/2]+n=2^2T[n/2^2]+2n=2^3T[n/2^3]+3n=...=2^mT[1]+mn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span></span></span></span><br>此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup><mspace width="2em"><mi>m</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">n=2^m \qquad m=log\,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:2em"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span></span></span></span><br>得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>T</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mtext>  </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">T[n]=nT[1]+n\;log\,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span></span></span></span><br>所以归并排序时间复杂度为O(n * log n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">int</span> extra[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [low, high)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = low; <span class="comment">// [low, mid)</span></span><br><span class="line">    <span class="keyword">int</span> j = mid; <span class="comment">// [mid, high)</span></span><br><span class="line">    <span class="keyword">int</span> k = low; <span class="comment">// extra[low, high)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[j]) &#123;<span class="comment">// =保证了稳定性</span></span><br><span class="line">            extra[k++] = <span class="built_in">array</span>[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            extra[k++] = <span class="built_in">array</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid) &#123;</span><br><span class="line">        extra[k++] = <span class="built_in">array</span>[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; high) &#123;</span><br><span class="line">        extra[k++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = low; x &lt; high; x++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[x] = extra[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortInner</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> extra[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high - low &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// size &lt;= 1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 平均切割</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 2. 分治处理左右两个小区间</span></span><br><span class="line">    MergeSortInner(<span class="built_in">array</span>, low, mid, extra);  <span class="comment">// [low, mid)</span></span><br><span class="line">    MergeSortInner(<span class="built_in">array</span>, mid, high, extra); <span class="comment">// [mid, high)</span></span><br><span class="line">    <span class="comment">// 3. 合并两个有序数组</span></span><br><span class="line">    Merge(<span class="built_in">array</span>, low, mid, high, extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* extra = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    MergeSortInner(<span class="built_in">array</span>, <span class="number">0</span>, size, extra);</span><br><span class="line">    <span class="built_in">free</span>(extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortNoR</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* extra = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    <span class="comment">// 左右两个小区间的长度都是i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j = j + <span class="number">2</span> * i) &#123;</span><br><span class="line">            <span class="comment">// 根据i和j, 确定low, mid, high</span></span><br><span class="line">            <span class="keyword">int</span> low = j;</span><br><span class="line">            <span class="keyword">int</span> mid = low + i;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt;= size) &#123;</span><br><span class="line">                <span class="comment">// 没有右边的小区间，不需要合并</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> high = mid + i;</span><br><span class="line">            <span class="keyword">if</span> (high &gt; size) &#123;</span><br><span class="line">                high = size;</span><br><span class="line">            &#125;</span><br><span class="line">            Merge(<span class="built_in">array</span>, low, mid, high, extra);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(extra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。经常被使用的是二路归并算法，即将两个已经排序的序列合并成一个序列的操作&lt;br&gt;时间复杂度：O(n * log n) 数据不敏感&lt;br&gt;空间复杂度：O(n)&lt;br&gt;稳定性：稳定&lt;br&gt;时间
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>交换排序</title>
    <link href="https://ranjiahao.github.io/2020/04/03/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/03/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h1><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾<br>时间复杂度：<br>最好：正序 比较次数n 移动次数0<br>最坏：反序 比较次数n<sup>2</sup> 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)<br>空间复杂度：O(1)<br>稳定性：稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> isSorted = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">        <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j + <span class="number">1</span>]);</span><br><span class="line">                isSorted = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2><p>我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sortBorder = size; sortBorder &gt; <span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 无序 [0, sortBorder - 1]</span></span><br><span class="line">        <span class="comment">// 有序 [sortBorder, size - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j + <span class="number">1</span>]);</span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortBorder = lastExchangeIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br>每一层的Partition：<br>时间复杂度 O(n)<br>空间复杂度 O(1)<br>快速排序时间复杂度：<br>最好：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>  </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=2T(n/2)+O(n)=&gt;T(n)=O(n\;log\,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>最坏：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T(n-1)+O(n)=&gt;T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mfrac><mn>2</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>T</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mo>&gt;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>  </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\frac1{n}\sum_{k=1}^n(T(n-k)+T(k-1))+n=\frac2{n}\sum_{k=1}^nT(k)+n=&gt;T(n)=O(n\;log\,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.03148em">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>快速排序空间复杂度：<br>空间消耗在于递归调用的栈帧消耗，最终消耗的情况是二叉树的高度，二叉树的高度在log(n) ~ n变化<br>最好：O(log n)<br>最坏：O(n)<br>平均：O(log n)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hover</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left;    <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right - <span class="number">1</span>; <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[right]; <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt;= pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt;= pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值和begin所在的下标交换，和第一个比pivot大的数交换</span></span><br><span class="line">    swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖坑</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left; <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right;  <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[right]; <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt;= pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[end] = <span class="built_in">array</span>[begin];</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt;= pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[begin] = <span class="built_in">array</span>[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[begin] = pivot;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_3</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[d]);</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>[d], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortInner</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="comment">// size &lt;= 1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 确定基准值</span></span><br><span class="line">    <span class="comment">// 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标</span></span><br><span class="line">    <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">    <span class="comment">// [left, right]  的区间被分成三部分</span></span><br><span class="line">    <span class="comment">// [left, d - 1]  &lt;= pivot</span></span><br><span class="line">    <span class="comment">// [d]            == pivot</span></span><br><span class="line">    <span class="comment">// [d + 1, right] &gt;= pivot</span></span><br><span class="line">    <span class="comment">// 3. 分治处理所有两个小区间</span></span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, left, d - <span class="number">1</span>);</span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, d + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    QuickSortInner(<span class="built_in">array</span>, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortNoR</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存要排序区间的左右边界</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(size - <span class="number">1</span>); <span class="comment">// right</span></span><br><span class="line">    <span class="built_in">stack</span>.push(<span class="number">0</span>);        <span class="comment">// left</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">        <span class="comment">// [d + 1, right]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(right);</span><br><span class="line">        <span class="built_in">stack</span>.push(d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// [left, d - 1]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(d - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">stack</span>.push(left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-2"><a class="markdownIt-Anchor" href="#优化-2"></a> 优化</h2><ol><li>上面的版本我们选择array[right]作为基准值，这其实是一种很不聪明的取法，当初始序列一开始就是有序的，则快速排序时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T(n-1)+O(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>所以pivot最好用三数取中法来选取</li><li>Partition函数中，如果有元素正好等于pivot，最好停下来做交换，虽然这样做了很多无谓的交换，但是最后i和j会停在比较中间的位置，主元也会被换在在比较中间的位置，这样做每一次递归的时候，原始序列基本被等分成两个等长的序列这样时间复杂度为O(n * log n)；如果不停下来交换而继续移动指针，这样其中一个指针是不动的，导致主元被放在一个端点，这样就成了O(n<sup>2</sup>)复杂度的算法了</li><li>对于大规模数据我们用递归，而对于递归的数据规模充分的小的时候则停止递归，直接调用简单排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUTOFF 7 <span class="comment">// 数组长度阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Median3</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[center]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[center]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[center] &gt; <span class="built_in">array</span>[right]) &#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[center], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时A[left] &lt;= A[center] &lt;= A[right]</span></span><br><span class="line">    swap(<span class="built_in">array</span>[center], <span class="built_in">array</span>[right - <span class="number">1</span>]); <span class="comment">// 将基准pivot藏到右边</span></span><br><span class="line">    <span class="comment">// 只需要考虑A[left + 1] … A[right - 2]</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">array</span>[right - <span class="number">1</span>];  <span class="comment">// 返回基准Pivot</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = Median3(<span class="built_in">array</span>, left, right); <span class="comment">// 基准值</span></span><br><span class="line">    <span class="comment">// 只需要考虑A[left + 1] … A[right - 2]</span></span><br><span class="line">    <span class="keyword">int</span> begin = left + <span class="number">1</span>; <span class="comment">// [left, begin] 保证 &lt;= pivot</span></span><br><span class="line">    <span class="keyword">int</span> end = right - <span class="number">2</span>;  <span class="comment">// [end, right]  保证 &gt;= pivot</span></span><br><span class="line">     <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[begin] &lt; pivot) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; <span class="built_in">array</span>[end] &gt; pivot) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把基准值和begin所在的下标交换，和第一个比pivot大的数交换</span></span><br><span class="line">    swap(<span class="built_in">array</span>[begin], <span class="built_in">array</span>[right]);</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortInner</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((right - left) &gt; CUTOFF) &#123;</span><br><span class="line">        <span class="comment">// 调用快速排序</span></span><br><span class="line">        <span class="comment">// 1. 确定基准值</span></span><br><span class="line">        <span class="comment">// 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标</span></span><br><span class="line">        <span class="keyword">int</span> d = Partition_1(<span class="built_in">array</span>, left, right);</span><br><span class="line">        <span class="comment">// [left, right]  的区间被分成三部分</span></span><br><span class="line">        <span class="comment">// [left, d - 1]  &lt;= pivot</span></span><br><span class="line">        <span class="comment">// [d]            == pivot</span></span><br><span class="line">        <span class="comment">// [d + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="comment">// 3. 分治处理所有两个小区间</span></span><br><span class="line">        QuickSortInner(<span class="built_in">array</span>, left, d - <span class="number">1</span>);</span><br><span class="line">        QuickSortInner(<span class="built_in">array</span>, d + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InsertSort(<span class="built_in">array</span> + left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h1&gt;&lt;p&gt;从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="https://ranjiahao.github.io/2020/04/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接选择排序"><a class="markdownIt-Anchor" href="#直接选择排序"></a> 直接选择排序</h1><p>每一次从待排序的数据元素中选出最小（和最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完<br>时间复杂度：O(n<sup>2</sup>) 数据不敏感<br>比较次数n<sup>2</sup><br>移动次数正序为0，反序为n<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">        <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 要查找整个无序区间的最大值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt;= <span class="built_in">array</span>[maxIdx]) &#123;</span><br><span class="line">                maxIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// maxIdx 记录着无序区间部分最大的数的下标</span></span><br><span class="line">        <span class="comment">// 和无序区间的最后一个位置的数进行交换</span></span><br><span class="line">        swap(<span class="built_in">array</span>[maxIdx], <span class="built_in">array</span>[size - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSortOP</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = size - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 有序 [0, begin - 1]  最小的数</span></span><br><span class="line">    <span class="comment">// 有序 [end + 1, size - 1] 最大的数</span></span><br><span class="line">    <span class="comment">// 无序 [begin, end]</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = begin;</span><br><span class="line">        <span class="keyword">int</span> max = begin;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[max]) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[min]) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小的数放到无序区间的最开始</span></span><br><span class="line">        <span class="comment">// 最大的数放到无序区间的最末尾</span></span><br><span class="line">        swap(<span class="built_in">array</span>[min], <span class="built_in">array</span>[begin]);</span><br><span class="line">        <span class="keyword">if</span> (max == begin) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(<span class="built_in">array</span>[max], <span class="built_in">array</span>[end]);</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1><p>从最大（小）堆顶不断取走堆顶元素放到有序序列中，直到堆的元素被全部取完<br>时间复杂度：O(n * log n) 数据不敏感<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; <span class="built_in">array</span>[right] &gt; <span class="built_in">array</span>[left]) &#123;</span><br><span class="line">        max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[index] &gt;= <span class="built_in">array</span>[max]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>[max], <span class="built_in">array</span>[index]);</span><br><span class="line">    Heapify(<span class="built_in">array</span>, size, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点，一直到 0，不断的向下调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Heapify(<span class="built_in">array</span>, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建大堆</span></span><br><span class="line">    CreateHeap(<span class="built_in">array</span>, size); <span class="comment">// n</span></span><br><span class="line">    <span class="comment">// 无序 [0, size - 1 - i]</span></span><br><span class="line">    <span class="comment">// 有序 [size - i, size - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// n * log n</span></span><br><span class="line">        <span class="comment">// 交换最大的数和无序区间的最后一个数</span></span><br><span class="line">        swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[size - <span class="number">1</span> - i]);</span><br><span class="line">        <span class="comment">// 堆的性质被破坏了，要调整的是剩余无序部分的长度 size - 1 - i</span></span><br><span class="line">        Heapify(<span class="built_in">array</span>, size - <span class="number">1</span> - i, <span class="number">0</span>); <span class="comment">// log n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建堆时间复杂度：<br>对满二叉树而言，第i层(根为第0层)有2<sup>i</sup>个节点<br>由于建堆过程自底向上，以交换作为主要操作，因此第i层任意节点在最不利情况下，需要经过(n−i)次交换操作才能完成以该节点为堆根节点的建堆过程<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n)=2^0(n−0)+2^1(n−1)+...+2^n(n−n)=\sum_{i=0}^n{(2^i(n-i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.124374em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.804292em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">2T(n)=2^1(n-0)+2^2(n-1)+2^{n+1}(n-n)=\sum_{i=1}^{n+1}{(2^i(n-i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-.29971000000000003em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.954008em"><span style="top:-2.40029em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.29971000000000003em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>2</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2T(n)-T(n)=2^{n+1}-2-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathdefault">n</span></span></span></span><br>总节点数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">1+2+4+...+2^n=2^{n+1}−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.664392em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span></span></span></span><br>忽略减1取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">＝</mi><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N＝2^{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mord cjk_fallback">＝</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">−</mi><mn>2</mn><mi mathvariant="normal">−</mi><mi>n</mi><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">−</mi><mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>N</mi></mrow><mi>N</mi></mfrac><mi mathvariant="normal">−</mi><mfrac><mn>2</mn><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo>≈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N)=2^{n+1}−2−n=N(1−\frac{log\,N}{N}−\frac2N)≈N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.13889em">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">2</span><span class="mord">−</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-.345em"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9322159999999999em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.446108em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:.01968em">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:.03588em">g</span><span class="mspace mtight" style="margin-right:.19516666666666668em"></span><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.845108em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:.10903em">N</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathdefault" style="margin-right:.10903em">N</span></span></span></span><br>堆排序时间复杂度：<br>调整堆顶n-1次，总共比较次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mn>2</mn><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(log(n-1)+log(n-2)+...+log2)&lt;2n(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:.01968em">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br>因此，堆排序时间复杂度为O(n * log n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接选择排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#直接选择排序&quot;&gt;&lt;/a&gt; 直接选择排序&lt;/h1&gt;&lt;p&gt;每一次从待排序的数据元素中选出最小（和最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完&lt;br&gt;时间复杂
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="https://ranjiahao.github.io/2020/04/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://ranjiahao.github.io/2020/04/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h1><p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列<br>时间复杂度：<br>最好：正序 比较次数n 移动次数0<br>最坏：反序 比较次数n<sup>2</sup> 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)<br>空间复杂度：O(1)<br>稳定性：稳定</p><p>利用二分查找实现插入排序<br>最好：正序 比较次数n * log n 移动次数0<br>最坏：反序 比较次数n * log n 移动次数n<sup>2</sup><br>平均：O(n<sup>2</sup>)</p><p>数据越少、越接近有序排序性能越好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; key; j--) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二分查找实现插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSortBS</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 有序 [0, i - 1]</span></span><br><span class="line">        <span class="comment">// 无序 [i, size - 1]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[mid] == <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 是要插入的位置的下标</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; left; k--) &#123;</span><br><span class="line">            <span class="built_in">array</span>[k] = <span class="built_in">array</span>[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[left] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h1><p>由于插入排序数据越少、越接近有序排序性能越好，希尔排序就是利用插入排序的这两个特点实现的，希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br>时间复杂度：<br>最好：O(n)<br>最坏：O(n<sup>2</sup>)<br>平均：O(1.3)<br>希尔排序的时间复杂度与增量的选取有关，Hibbard增量序列O(n<sup>5/4</sup>)，Sedgewick增量序列O(n<sup>7/6</sup>)<br>空间复杂度：O(1)<br>稳定性：不稳定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSortWithGap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; key; j -= gap) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j + gap] = <span class="built_in">array</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + gap] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = size;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 原始增量序列</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// gap = gap / 3 + 1;</span></span><br><span class="line">        InsertSortWithGap(<span class="built_in">array</span>, size, gap);</span><br><span class="line">        <span class="keyword">if</span> (gap == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接插入排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#直接插入排序&quot;&gt;&lt;/a&gt; 直接插入排序&lt;/h1&gt;&lt;p&gt;把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列&lt;br
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="排序" scheme="https://Ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
