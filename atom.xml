<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ranjiahao.github.io/"/>
  <updated>2020-07-25T16:00:00.000Z</updated>
  <id>https://ranjiahao.github.io/</id>
  
  <author>
    <name>Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>位图与布隆过滤器</title>
    <link href="https://ranjiahao.github.io/2020/07/26/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://ranjiahao.github.io/2020/07/26/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h1><p>在哈希表中，如果要在表中存放一个整数，此时就要申请一个整型的内存来存放它，一个整型数据在32位或64位平台下都占4个字节。如果现在需要存储的数据非常多，比如说40亿个不重复的数据，就需要160亿个字节来存储，1GB的内存表示的是10亿个字节，此时就需要16GB的内存来存放这些数据，而我们普通的电脑内存一般都是4G的内存，这显然是存放不下的。我们知道，内存中的最小单位是比特位。如果能用一个比特位来存放一个整型，只需要0.5GB的内存。一个比特位可以表示一个0或1。如果要表示40亿个数据，可以申请0.5GB的内存。如果要存放的数据为10，就将第10个比特位设置为1。如果要查找的数据为100，就查看第100个比特位处的状态，如果为1说明，100存在于这堆数据中，如果为0说明不存在</p><p>位图的应用：</p><ol><li>快速查找某个数据是否在一个集合中</li><li>排序</li><li>求两个集合的交集、并集等</li><li>操作系统中磁盘块标记</li></ol><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitset.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BitSet(<span class="keyword">size_t</span> range) &#123;</span><br><span class="line">        <span class="comment">// +1是为了防止数据小于32和向上取整</span></span><br><span class="line">        _bs.resize((range &gt;&gt; <span class="number">5</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 存储</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        _bs[index] |= (<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> (_bs[index] &gt;&gt; bitIdx) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = number &gt;&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIdx = number % <span class="number">32</span>;</span><br><span class="line">        _bs[index] &amp;= (~(<span class="number">1</span> &lt;&lt; bitIdx));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _bs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应用：</p><ol><li>给定100亿个整数，设计算法找到只出现一次的整数？<br>100亿个整数，一个整数占4个字节，总共需要400亿字节。1GB = 10亿字节，所以需要40GB的内存。因此不能直接将数据加载到内存中<br>对于任意的整数，可以分三个状态进行讨论：没有出现，出现一次，出现多次。因此三个状态可以两个比特位来存放。其中：00表示没有出现的整数，01表示出现1次的整数，10表示出现两次的整数，11舍弃不用。所以可以用位图来对这些数据进行处理，此时内存占用就可以减少为1GB<br>实现思路如下： 首先在内存中创建一个1GB的位图，初始化时全部设置为0。然后遍历100亿个整数，遇到一个整数，将该整数的2倍处的连续两个比特位先设置为01，当遇到两次或两次以上的情形时，将这两个比特位设置为01即可。遍历完所有整数后，对位图的设置就结束了<br>然后，从头开始遍历位图，一次提取两个比特位，如果这两个比特位对应的数字为01，说明这两个比特位对应的数字只出现了一次。遍历完整个位图之后，就找到了所有只出现一次的数字</li><li>给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？<br>方案1：将其中一个文件的整数位置映射到一个位图，读取第二个文件判断是否在位图中。500M内存<br>方案2：将文件1的整数映射到位图1中，将文件2的整数映射到位图2中，然后两个位图按位与得到交集。1G内存</li></ol><h1 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器"></a> 布隆过滤器</h1><p>新闻客户端推荐系统如何实现推送去重的？ 用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。如何快速查找呢？<br>用哈希表存储用户记录，缺点：浪费空间<br>用位图存储用户记录，缺点：不能处理哈希冲突<br>将哈希与位图结合，即布隆过滤器</p><p>可以用位图加上多个字符串哈希函数的方法来实现布隆过滤器。字符串哈希函数越多，一个字符串对应的下标值也就越多，冲突的概率就会越小<br>可以用来告诉你 “某样东西一定不存在或者可能存在”</p><p><img src="img1.png" alt="img1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitset.hpp"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun1</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">131</span> + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun2</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">65599</span> + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HFun3</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) &#123;</span><br><span class="line">            hash = hash * magic + ch;</span><br><span class="line">            magic *= <span class="number">378551</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">HFun1</span>, <span class="title">class</span> <span class="title">HFun2</span>, <span class="title">class</span> <span class="title">HFun3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BloomFilter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// m： bitSet大小</span></span><br><span class="line">    <span class="comment">// n: 元素个数</span></span><br><span class="line">    <span class="comment">// k: 哈希函数的数量</span></span><br><span class="line">    <span class="comment">// k = (m/n)* ln2</span></span><br><span class="line">    <span class="comment">// m = k * n / ln2 = 1.4 * k * n</span></span><br><span class="line">    BloomFilter(<span class="keyword">size_t</span> number)</span><br><span class="line">        : _bs(<span class="number">5</span> * number)</span><br><span class="line">        , _bitCount(<span class="number">5</span> * number) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">int</span> index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">int</span> index3 = HFun3()(data) % _bitCount;</span><br><span class="line"></span><br><span class="line">        _bs.Set(index1);</span><br><span class="line">        _bs.Set(index2);</span><br><span class="line">        _bs.Set(index3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = HFun1()(data) % _bitCount;</span><br><span class="line">        <span class="comment">// 只要有一个位置为0说明不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index2 = HFun2()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index3 = HFun3()(data) % _bitCount;</span><br><span class="line">        <span class="keyword">if</span> (!_bs.Find(index3)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 可能误判</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供删除</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitSet _bs;</span><br><span class="line">    <span class="keyword">size_t</span> _bitCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：在对布隆过滤器的基本操作中，没有删除某一字符串的操作。因为一个字符串对应多个下标处的状态，一个下标处的状态也可能被多个字符串使用。所以，一旦将一个字符串删除，就会将该字符串对应的多个下标处的1均置为0，此时就会影响其他的字符串。因此不能对布隆过滤器进行删除操作。改进支持删除的方法：将布隆过滤器中的每个比特位扩展成一个小的计数器，插入元素时给k个计数器(k个哈希函数计算出的哈希地址)加一，删除元素时，给k个计数器减一，通过多占用几倍存储空间的代价来增加删除操作</p><p>缺点：</p><ol><li>有误判率不能准确判断元素是否在集合中(补救方法：再建立一个白 名单，存储可能会误判的数据)</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素，如果采用计数方式删除，可能会存在计数回绕问题</li></ol><p>优点：</p><ol><li>时间复杂度为O(K) (K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>不能获取元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ol><p>应用：</p><ol><li>给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法<br>近似算法：将文件1的query映射到一个布隆过滤器中，读取文件2中的query，判断在不在布隆过滤器中，在就是交集。缺陷：判断出来的交集中的数不准确，但是不会遗漏数据<br>精准算法：哈希切分，将文件A和文件B都分为1000个小文件，i=hashstr(query)%1000得到的i是多少就将query放入对应的A(i)或B(i)中，然后将A(i)数据放入set中，查找B(i)看是否在交集中</li><li>给一个超过100G大小的log file, log中存着IP地址, 设计算法找到top K的IP？如何直接用Linux系统命令实现？<br>先创建1000个小文件A0~A999，读取IP计算i=hashstr(ip)%1000，i是多少IP就进入对应编号Ai小文件，这样相同IP一定进入同一小文件，利用map&lt;string, int&gt;统计ip出现的次数，用一个大小为k的小顶堆即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#位图&quot;&gt;&lt;/a&gt; 位图&lt;/h1&gt;&lt;p&gt;在哈希表中，如果要在表中存放一个整数，此时就要申请一个整型的内存来存放它，一个整型数据在32位或64位平台下都占4个字节。如果现在需要存储的数据非
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="位图" scheme="https://Ranjiahao.github.io/tags/%E4%BD%8D%E5%9B%BE/"/>
    
      <category term="布隆过滤器" scheme="https://Ranjiahao.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突、unorde_map/set模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/24/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%81unorde_map,set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/24/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%81unorde_map,set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-07-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>哈希是一种O(1)查找的数据结构，可以不经过任何比较，一次直接从表中得到要搜索的元素。通过hashFunc使元素的存储位置与它的关键码之间能够建立一一映射的关系<br>在插入元素时，由待插入元素的值根据一个特殊函数（哈希函数）计算出该元素的存储位置，并将该元素放置在此处。在搜索元素时，还是由搜索的元素值根据这个特殊函数计算存储位置，直接在该位置将元素取出即可<br>常见的哈希函数有：<br>直接定址法 Hash（Key）= A * Key + B 直接取关键字本身或者他的线性函数来作为散列地址<br>除留余数法 Hash(key) = key % capacity 最常用的哈希函数，用一个数来对key取模，一般来说这个数都是容量<br>由于直接定址、除留余数法这些函数要求key必须为整形，而对于字符串类型就要别的方式，比如BKD对字符串每一个字符的ascii值或者字符串的大小进行计算，来推导出一个不容易产生冲突的key值，但是尽管如此，对与不同的数据根据哈希函数计算出来的值也是可能相同的，这就产生了哈希冲突，我们可以设计精妙的哈希函数来使产生哈希冲突的可能性尽可能的低，但不可能避免哈希冲突解决哈希冲突常见的办法有两种：闭散列和开散列</p><h1 id="闭散列"><a class="markdownIt-Anchor" href="#闭散列"></a> 闭散列</h1><p>当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的下一个空位置中去，我们可以用线性探测或者二次探测的方法来寻找下一个空位置<br><strong>线性探测：</strong> 从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止<br>插入：通过哈希函数获取待插入元素在哈希表中的位置，如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素<br>删除：采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索，因此线性探测采用标记的伪删除法来删除一个元素<br>线性探测缺点：一旦发生哈希冲突，所有的冲突连在一起，容易产生数据堆积，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降低<br><strong>二次探测：</strong> 找下一个空位置的方法为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">H_i = (H_0 + i^2) \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">m</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo>−</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">H_i = (H_0 - i^2) \% m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">m</span></span></span></span>其中：i = 1,2,3…，是通过散列函数Hash(x)对元素的关键码key进行计算得到的位置，m是表的大小<br>研究表明当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次，因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容<br>二次探测缺点：空间利用率低<br><strong>提高性能：</strong> (1)由于表中元素越多，产生冲突的概率越大，所以我们引入了负载因子，当容量到达百分之八十的时候就进行扩容操作。(2)除留余数法，最好模一个素数</p><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> STATE &#123;</span><br><span class="line">    EMPTY, EXIST, DELETE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hashNode</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;K, V&gt; _data;</span><br><span class="line">    STATE _state = EMPTY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了实现简单，将比较直接与元素绑定在一起</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashNode&lt;K, V&gt; Node;</span><br><span class="line"></span><br><span class="line">    HashTable(<span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>)</span><br><span class="line">        : _ht(n)</span><br><span class="line">        , _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        <span class="comment">// 计算索引</span></span><br><span class="line">        <span class="keyword">int</span> index = data.first % _ht.size();</span><br><span class="line">        <span class="comment">// 判断当前位置是否有元素，若没有，则直接插入</span></span><br><span class="line">        <span class="comment">// 新的元素可以放在：EMPTY,DELETE</span></span><br><span class="line">        <span class="keyword">while</span> (_ht[index]._state == EXIST) &#123;</span><br><span class="line">            <span class="comment">// 如果有：判读当前位置的元素的key是否和插入的数据相同</span></span><br><span class="line">            <span class="keyword">if</span> (_ht[index]._data.first == data.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有， 且key不同，继续向后遍历，找一个空的位置，进行插入（线性探测）</span></span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> (index == _ht.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素插入</span></span><br><span class="line">        _ht[index]._data = data;</span><br><span class="line">        _ht[index]._state = EXIST;</span><br><span class="line">        ++_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_ht.size() == <span class="number">0</span> || _size * <span class="number">10</span> / _ht.size() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">// 负载因子大于阈值，进行增容</span></span><br><span class="line">            <span class="comment">// int newC = _ht.size() == 0 ? 10 : 2 * _ht.size();</span></span><br><span class="line">            <span class="keyword">size_t</span> newC = getNextPrime(_ht.size());</span><br><span class="line">            HashTable&lt;K, V&gt; newHt(newC);</span><br><span class="line">            <span class="comment">// 旧表元素重新插入到新表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ht[i]._state == EXIST) &#123;</span><br><span class="line">                    newHt.Insert(_ht[i]._data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 旧表新表交换</span></span><br><span class="line">            <span class="built_in">std</span>::swap(_ht, newHt._ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = key % _ht.size();</span><br><span class="line">        <span class="comment">// 直到遇到空结束</span></span><br><span class="line">        <span class="keyword">while</span> (_ht[index]._state != EMPTY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ht[index]._state == EXIST) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_ht[index]._data.first == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &amp;_ht[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> (index == _ht.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        Node* pos = Find(key);</span><br><span class="line">        <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">            pos-&gt;_state = DELETE;</span><br><span class="line">            --_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> getNextPrime(<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> PRIMECOUNT = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> primeList[PRIMECOUNT] = &#123;</span><br><span class="line">            <span class="number">53u</span>l, <span class="number">97u</span>l, <span class="number">193u</span>l, <span class="number">389u</span>l, <span class="number">769u</span>l,</span><br><span class="line">            <span class="number">1543u</span>l, <span class="number">3079u</span>l, <span class="number">6151u</span>l, <span class="number">12289u</span>l, <span class="number">24593u</span>l,</span><br><span class="line">            <span class="number">49157u</span>l, <span class="number">98317u</span>l, <span class="number">196613u</span>l, <span class="number">393241u</span>l, <span class="number">786433u</span>l,</span><br><span class="line">            <span class="number">1572869u</span>l, <span class="number">3145739u</span>l, <span class="number">6291469u</span>l, <span class="number">12582917u</span>l, <span class="number">25165843u</span>l,</span><br><span class="line">            <span class="number">50331653u</span>l, <span class="number">100663319u</span>l, <span class="number">201326611u</span>l, <span class="number">402653189u</span>l, <span class="number">805306457u</span>l,</span><br><span class="line">            <span class="number">1610612741u</span>l, <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRIMECOUNT; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (primeList[i] &gt; sz) &#123;</span><br><span class="line">                <span class="keyword">return</span> primeList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primeList[PRIMECOUNT - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; _ht;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="开散列"><a class="markdownIt-Anchor" href="#开散列"></a> 开散列</h1><p>对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来（数据过多时可能会转为建立红黑树），各链表的头结点存储在哈希表中，开散列最好的情况是每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容</p><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash.hpp</span></span><br><span class="line"><span class="comment">// 开散列</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">HashNode</span> &#123;</span></span><br><span class="line">    HashNode(<span class="keyword">const</span> V&amp; data = V())</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    V _data;</span><br><span class="line">    HashNode&lt;V&gt;* _next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">HashIterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _HashIterator&lt;K, V, KeyOfValue, HFun&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板友元类声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">struct</span> _<span class="title">HashIterator</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到非空链表的头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">            <span class="comment">// this: 当前调用函数的对象hastTbale</span></span><br><span class="line">            <span class="keyword">if</span> (_ht[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> iterator(_ht[i], <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashTable(<span class="keyword">size_t</span> N = <span class="number">10</span>) &#123;</span><br><span class="line">        _ht.resize(N);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> hashIndex(<span class="keyword">const</span> K&amp; key, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        HFun hf;</span><br><span class="line">        <span class="comment">// 哈希函数把key转成整数</span></span><br><span class="line">        <span class="keyword">return</span> hf(key) % sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> V&amp; data) &#123;</span><br><span class="line">        CheckCapacity();</span><br><span class="line">        <span class="comment">// 计算位置</span></span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">int</span> index = hashIndex(kov(data), _ht.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历单链表</span></span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == kov(data)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入：头插</span></span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        cur-&gt;_next = _ht[index];</span><br><span class="line">        _ht[index] = cur;</span><br><span class="line">        ++_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> getNextPrime(<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> PRIMECOUNT = <span class="number">28</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> primeList[PRIMECOUNT] = &#123;</span><br><span class="line">            <span class="number">53u</span>l, <span class="number">97u</span>l, <span class="number">193u</span>l, <span class="number">389u</span>l, <span class="number">769u</span>l,</span><br><span class="line">            <span class="number">1543u</span>l, <span class="number">3079u</span>l, <span class="number">6151u</span>l, <span class="number">12289u</span>l, <span class="number">24593u</span>l,</span><br><span class="line">            <span class="number">49157u</span>l, <span class="number">98317u</span>l, <span class="number">196613u</span>l, <span class="number">393241u</span>l, <span class="number">786433u</span>l,</span><br><span class="line">            <span class="number">1572869u</span>l, <span class="number">3145739u</span>l, <span class="number">6291469u</span>l, <span class="number">12582917u</span>l, <span class="number">25165843u</span>l,</span><br><span class="line">            <span class="number">50331653u</span>l, <span class="number">100663319u</span>l, <span class="number">201326611u</span>l, <span class="number">402653189u</span>l, <span class="number">805306457u</span>l,</span><br><span class="line">            <span class="number">1610612741u</span>l, <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRIMECOUNT; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (primeList[i] &gt; sz) &#123;</span><br><span class="line">                <span class="keyword">return</span> primeList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primeList[PRIMECOUNT - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_size == _ht.size()) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> newC = getNextPrime(_ht.size());</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pNode&gt; newHt;</span><br><span class="line">            newHt.resize(newC);</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            <span class="comment">// 移动旧表的元素到新表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; _ht.size(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 单链表头节点</span></span><br><span class="line">                pNode cur = _ht[i];</span><br><span class="line">                <span class="comment">// 遍历单链表</span></span><br><span class="line">                <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                    pNode next = cur-&gt;_next;</span><br><span class="line">                    <span class="comment">// 重新计算在新表中的位置</span></span><br><span class="line">                    <span class="keyword">int</span> index = hashIndex(kov(cur-&gt;_data), newHt.size());</span><br><span class="line">                    <span class="comment">// 头插</span></span><br><span class="line">                    cur-&gt;_next = newHt[index];</span><br><span class="line">                    newHt[index] = cur;</span><br><span class="line">                    cur = next;</span><br><span class="line">                &#125;</span><br><span class="line">                _ht[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::swap(_ht, newHt); <span class="comment">// start, finish, endOfStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = key % _ht.size();</span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashIndex(key, _ht.size());</span><br><span class="line">        pNode cur = _ht[index];</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) == key) &#123;</span><br><span class="line">                <span class="comment">// 判断是否为头</span></span><br><span class="line">                <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    _ht[index] = cur-&gt;_next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent-&gt;_next = cur-&gt;_next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">                --_size;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指针数组</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pNode&gt; _ht;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">HashIterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> HashNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _HashIterator&lt;K, V, KeyOfValue, HFun&gt; Self;</span><br><span class="line">    <span class="keyword">typedef</span> HashTable&lt;K, V, KeyOfValue, HFun&gt; HTable;</span><br><span class="line"></span><br><span class="line">    _HashIterator(pNode node, HTable* pht)</span><br><span class="line">        : _node(node)</span><br><span class="line">        , _pht(pht) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_next) &#123;</span><br><span class="line">            _node = _node-&gt;_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KeyOfValue kov;</span><br><span class="line">            <span class="comment">// 下一个非空链表的头节点</span></span><br><span class="line">            <span class="keyword">size_t</span> index = _pht-&gt;hashIndex(kov(_node-&gt;_data), _pht-&gt;_ht.size());</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; _pht-&gt;_ht.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_pht-&gt;_ht[index]) &#123;</span><br><span class="line">                    _node = _pht-&gt;_ht[index];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == _pht-&gt;_ht.size()) &#123;</span><br><span class="line">                _node = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _node;</span><br><span class="line">    HTable* _pht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="unordered_map-set模拟实现"><a class="markdownIt-Anchor" href="#unordered_map-set模拟实现"></a> unordered_map、set模拟实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hash.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hashFun</span> &#123;</span></span><br><span class="line">    <span class="function">K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashFun</span>&lt;std::string&gt; &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">        <span class="comment">// BKD</span></span><br><span class="line">        <span class="keyword">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : str) &#123;</span><br><span class="line">            hash = hash * <span class="number">131</span> + e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template &lt;&gt;</span></span><br><span class="line"><span class="comment">//struct hashfun&lt;自定义类型&gt; &#123;</span></span><br><span class="line"><span class="comment">//size_t operator()(const 自定义类型&amp; key) &#123;</span></span><br><span class="line"><span class="comment">//        // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">HFun</span> = <span class="title">hashFun</span>&lt;K&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UMap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MapKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue, HFun&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="comment">// pair&lt;iterator, bool&gt;</span></span><br><span class="line">        <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; ret = _ht.insert(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">        <span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HashTable&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue, HFun&gt; _ht;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HFun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">USet</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SetKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> HashTable&lt;K, K, SetKeyOfValue, HFun&gt;::iterator iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> K&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _ht.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HashTable&lt;K, K, SetKeyOfValue, HFun&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;&lt;p&gt;哈希是一种O(1)查找的数据结构，可以不经过任何比较，一次直接从表中得到要搜索的元素。通过hashFunc使元素的存储位置与它的关键码之间能够建立
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="哈希" scheme="https://Ranjiahao.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="unordered_map/set" scheme="https://Ranjiahao.github.io/tags/unordered-map-set/"/>
    
  </entry>
  
  <entry>
    <title>红黑树与map、set模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8Emap%E3%80%81set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/23/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8Emap%E3%80%81set%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-22T16:00:00.000Z</published>
    <updated>2020-07-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于AVL树不适用一些经常修改的结构，这是因为AVL树追求绝对的平衡，所以就有了一种近似平衡的二叉搜索树红黑树，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。</p><p>红黑树在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black，它有这些特点：</p><ol><li>每个结点不是红色就是黑色</li><li>根节点是黑色的</li><li>如果一个节点是红色的，则它的两个孩子结点是黑色的</li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li><li>每个叶子结点都是黑色的(此处的叶子结点指的是空结点)</li></ol><p>由于红黑树的这些特点，所以红黑树能保证其最长路径中节点个数不会超过最短路径节点个数的两倍</p><p>红黑树的插入：<br>首先按照二叉搜索树的规则插入新节点，如果新节点设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换和树旋转来调整<br>插入红色节点后，分情况讨论当前红黑树的状态</p><ol><li>其双亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整</li><li>其双亲节点的颜色是红色，约定n为当前节点，p为父节点，g为祖父节点，u为叔叔节点<br>(2.1) n为红，p为红，g为黑，u存在且为红，则需要将p、u改为黑，g改为红，然后把g当成n，继续向上调整<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png" alt="2.1"><br>(2.2) n为红，p为红，g为黑，u不存在/u为黑<br>(2.2.1) p为g的左孩子，n为p的左孩子，进行右单旋转，同理p为g的右孩子，n为p的右孩子，进行左单旋转<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png" alt="2.2.1"><br>(2.2.2) p为g的左孩子，n为p的右孩子，进行左旋转后变为情况2.2.1，再进行右旋<br>同理p为g的右孩子，n为p的左孩子，进行右旋转后变为情况2.2.1，再进行左旋<br><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png" alt="2.2.2"></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RBTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> COLOR &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">RBTNode</span> &#123;</span></span><br><span class="line">    RBTNode(<span class="keyword">const</span> V&amp; data = V())</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _parent(<span class="literal">nullptr</span>)</span><br><span class="line">        , _color(RED) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V _data;</span><br><span class="line">    RBTNode&lt;V&gt;* _left;</span><br><span class="line">    RBTNode&lt;V&gt;* _right;</span><br><span class="line">    RBTNode&lt;V&gt;* _parent;</span><br><span class="line">    COLOR _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">RBTreeIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RBTNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;V&gt; Self;</span><br><span class="line"></span><br><span class="line">    _RBTreeIterator(pNode node)</span><br><span class="line">        : _node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node != it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; it) &#123;</span><br><span class="line">        <span class="keyword">return</span> _node == it._node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_right) &#123;</span><br><span class="line">            <span class="comment">// 找到右子树的最左节点</span></span><br><span class="line">            _node = _node-&gt;_right;</span><br><span class="line">            <span class="keyword">while</span> (_node-&gt;_left) &#123;</span><br><span class="line">                _node = _node-&gt;_left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上回溯</span></span><br><span class="line">            pNode parent = _node-&gt;_parent;</span><br><span class="line">            <span class="keyword">while</span> (parent-&gt;_right == _node) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特殊情况：迭代器在根节点位置，并且根节点无右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (_node-&gt;_right != parent) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="comment">// 迭代器在head位置</span></span><br><span class="line">        <span class="comment">// _node-&gt;color == RED 排除根节点</span></span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;_parent-&gt;_parent == _node &amp;&amp; _node-&gt;_color == RED) &#123;</span><br><span class="line">            _node = _node-&gt;_right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_node-&gt;_left) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">            _node = _node-&gt;_left;</span><br><span class="line">            <span class="keyword">while</span> (_node-&gt;_right) &#123;</span><br><span class="line">                _node = _node-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上回溯</span></span><br><span class="line">            pNode parent = _node-&gt;_parent;</span><br><span class="line">            <span class="keyword">while</span> (parent-&gt;_left == _node) &#123;</span><br><span class="line">                _node = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            _node = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树结构：为了后续实现关联式容器简单，红黑树的实现中增加一个头结点</span></span><br><span class="line"><span class="comment">// 因为跟节点必须为黑色，为了与根节点进行区分，将头结点给成黑色</span></span><br><span class="line"><span class="comment">// 并且让头结点的Parent指向红黑树的根节点，Left指向红黑树中最小的节点，Right指向红黑树中最大的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RBTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RBTNode&lt;V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;V&gt; iterator;</span><br><span class="line"></span><br><span class="line">    RBTree(<span class="keyword">const</span> V&amp; data = V()) &#123;</span><br><span class="line">        _header = <span class="keyword">new</span> Node(data);</span><br><span class="line">        _header-&gt;_left = _header;</span><br><span class="line">        _header-&gt;_right = _header;</span><br><span class="line">        _header-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_header-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(_header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> V&amp; data)</span> </span>&#123;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">if</span> (_header == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kov(cur-&gt;_data) &lt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> iterator(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> V&amp; data) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是空树</span></span><br><span class="line">        <span class="keyword">if</span> (_header-&gt;_parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pNode root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="comment">// 根节点的颜色必须为黑的</span></span><br><span class="line">            root-&gt;_color = BLACK;</span><br><span class="line">            root-&gt;_parent = _header;</span><br><span class="line"></span><br><span class="line">            _header-&gt;_left = root;</span><br><span class="line">            _header-&gt;_right = root;</span><br><span class="line">            _header-&gt;_parent = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(root), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根节点开始搜索合适的叶子</span></span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        KeyOfValue kov;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (kov(cur-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kov(cur-&gt;_data) &lt; kov(data)) &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(cur), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        pNode newNode = cur;</span><br><span class="line">        <span class="keyword">if</span> (kov(parent-&gt;_data) &gt; kov(data)) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整：修改颜色，旋转</span></span><br><span class="line">        <span class="comment">// cur和parent的颜色都为红色, 需要调整</span></span><br><span class="line">        <span class="keyword">while</span> (cur != _header-&gt;_parent &amp;&amp; cur-&gt;_parent-&gt;_color == RED) &#123;</span><br><span class="line">            pNode parent = cur-&gt;_parent;</span><br><span class="line">            pNode gParent = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                pNode uncle = gParent-&gt;_right;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_color == RED) &#123;</span><br><span class="line">                    <span class="comment">// 更新颜色</span></span><br><span class="line">                    parent-&gt;_color = uncle-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="comment">// 向上继续更新</span></span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// u不存在/u存在且为黑</span></span><br><span class="line">                    <span class="comment">// 判断是否存在双旋的场景</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_right == cur) &#123;</span><br><span class="line">                        RotateLeft(parent);</span><br><span class="line">                        <span class="built_in">std</span>::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 右旋</span></span><br><span class="line">                    RotateRight(gParent);</span><br><span class="line">                    <span class="comment">// 修改颜色</span></span><br><span class="line">                    parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="comment">// 结束调整</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNode uncle = gParent-&gt;_left;</span><br><span class="line">                <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_color == RED) &#123;</span><br><span class="line">                    uncle-&gt;_color = parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    cur = gParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// u不存在/u存在且为黑</span></span><br><span class="line">                    <span class="comment">// 判断是否存在双旋的场景</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                        RotateRight(parent);</span><br><span class="line">                        <span class="built_in">std</span>::swap(cur, parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    RotateLeft(gParent);</span><br><span class="line">                    parent-&gt;_color = BLACK;</span><br><span class="line">                    gParent-&gt;_color = RED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点的颜色必须为黑色</span></span><br><span class="line">        _header-&gt;_parent-&gt;_color = BLACK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整之后，根可能发生变化</span></span><br><span class="line">        _header-&gt;_left = leftMost();</span><br><span class="line">        _header-&gt;_right = rightMost();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(newNode), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">leftMost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;_left) &#123;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">rightMost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pNode cur = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;_right) &#123;</span><br><span class="line">            cur = cur-&gt;_right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateRight</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subL = parent-&gt;_left;</span><br><span class="line">        pNode subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subL-&gt;_right = parent;</span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        pNode gParent = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        <span class="keyword">if</span> (subLR) &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _header-&gt;_parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                gParent-&gt;_left = subL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gParent-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = gParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _header-&gt;_parent = subL;</span><br><span class="line">            subL-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateLeft</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subR = parent-&gt;_right;</span><br><span class="line">        pNode subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        <span class="keyword">if</span> (subRL) &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _header-&gt;_parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_parent-&gt;_left == parent) &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_left = subR;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = parent-&gt;_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _header-&gt;_parent = subR;</span><br><span class="line">            subR-&gt;_parent = _header;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_header-&gt;_parent);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 红黑树的检测分为两步：</span></span><br><span class="line">        <span class="comment">// 1. 检测其是否满足二叉搜索树(中序遍历是否为有序序列)</span></span><br><span class="line">        <span class="comment">// 2. 检测其是否满足红黑树的性质</span></span><br><span class="line">        pNode root = _header-&gt;_parent;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_color == RED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计一条路径黑色的数量</span></span><br><span class="line">        <span class="keyword">int</span> blackCount = <span class="number">0</span>;</span><br><span class="line">        pNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_color == BLACK) &#123;</span><br><span class="line">                ++blackCount;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">return</span> _isRBTree(root, blackCount, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _isRBTree(pNode root, <span class="keyword">int</span> blackCount, <span class="keyword">int</span> curBlackCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curBlackCount != blackCount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加黑节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_color == BLACK) &#123;</span><br><span class="line">            ++curBlackCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有红色连续</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_parent-&gt;_color == RED &amp;&amp; root-&gt;_color == RED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _isRBTree(root-&gt;_left, blackCount, curBlackCount)</span><br><span class="line">            &amp;&amp; _isRBTree(root-&gt;_right, blackCount, curBlackCount);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pNode _header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"RBTree.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MapKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue&gt;::iterator iterator;</span><br><span class="line">    <span class="comment">// typedef _RBTreeIterator&lt;pair&lt;K, V&gt;&gt; iterator;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Find(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> K&amp; key) &#123;</span><br><span class="line">        <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; ret = _rbt.Insert(<span class="built_in">std</span>::make_pair(key, V()));</span><br><span class="line">        <span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTree&lt;K, <span class="built_in">std</span>::pair&lt;K, V&gt;, MapKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SetKeyOfValue</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> K&amp; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedef typename RBTree&lt;K, K, SetKeyOfValue&gt;::iterator iterator;</span></span><br><span class="line">    <span class="keyword">typedef</span> _RBTreeIterator&lt;K&gt; iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> K&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Find(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;iterator, <span class="keyword">bool</span>&gt; Insert(<span class="keyword">const</span> K&amp; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> _rbt.Insert(data);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTree&lt;K, K, SetKeyOfValue&gt; _rbt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于AVL树不适用一些经常修改的结构，这是因为AVL树追求绝对的平衡，所以就有了一种近似平衡的二叉搜索树红黑树，相对而言，降低了插入和旋转的次数，所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。&lt;/p&gt;&lt;p&gt;红黑树在每个结点上
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="红黑树" scheme="https://Ranjiahao.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="map/set" scheme="https://Ranjiahao.github.io/tags/map-set/"/>
    
  </entry>
  
  <entry>
    <title>AVL树模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/18/AVL%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/18/AVL%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>AVL树是一种高度平衡的二叉树，它改进了普通二叉搜索树在极端情况下会退化成单支效率低下的问题，AVL树中在每个节点中加入了平衡因子，使得左右子树的高度差不超过1，这样可以使得高度保持在log n，从而避免的极端情况下的查找效率低下问题，但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修改，就不太适合</p><p>插入：<br>首先根据二叉搜索树的规则插入新的节点，然后调整平衡因子即可<br>如果新节点插入到Parent的左侧，则Parent的平衡因子-1<br>如果新节点插入到Parent的右侧，则Parent的平衡因子+1<br>这时Parent的平衡因子有三种情况-1、0、1<br>若为0，则说明之前的平衡因子为-1/1，插入后调整为0，则插入成功返回即可<br>若为-1/1，则说明之前的平衡因子为0，插入后变为-1/1，则AVL树高度增加需要向上寻找，看看有没有别的平衡被破坏的节点<br>若为2，则说明违反了AVL树的性质，需要旋转处理</p><p>旋转：根据节点插入位置的不同，AVL树的旋转分为四种</p><ol><li>Parent的平衡因子为2，说明Parent的右子树高，设Parent的右子树的根为SubR<br>当SubR的平衡因子为1时，执行左单旋<br>当SubR的平衡因子为-1时，执行右左双旋</li><li>Parent的平衡因子为-2，说明Parent的左子树高，设Parent的左子树的根为SubL<br>当SubL的平衡因子为-1是，执行右单旋<br>当SubL的平衡因子为1时，执行左右双旋</li></ol><p>旋转完成后，原Parent为根的子树个高度降低，已经平衡，不需要再向上更新</p><p>单旋：</p><p><img src="img1.png" alt="img1"></p><p>双旋：</p><p><img src="img2.png" alt="img2"></p><p><img src="img3.png" alt="img3"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVLTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    AVLNode(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span><br><span class="line">        : _data(data)</span><br><span class="line">        , _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _parent(<span class="literal">nullptr</span>)</span><br><span class="line">        , _bf(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;K, V&gt; _data;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _left;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _right;</span><br><span class="line">    AVLNode&lt;K, V&gt;* _parent;</span><br><span class="line">    <span class="keyword">int</span> _bf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> AVLNode&lt;K, V&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;K, V&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜索</span></span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data.first == data.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data.first &gt; data.first) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_data.first &gt; data.first) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">            <span class="comment">// 更新平衡因子</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_right == cur) &#123;</span><br><span class="line">                ++parent-&gt;_bf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --parent-&gt;_bf;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-1</span> || parent-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 向上继续更新</span></span><br><span class="line">                cur = parent;</span><br><span class="line">                parent = parent-&gt;_parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 左边的左边高</span></span><br><span class="line">                    RotateRight(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右边的右边高</span></span><br><span class="line">                    RotateLeft(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> &amp;&amp; cur-&gt;_bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右边的左边高</span></span><br><span class="line">                    <span class="keyword">int</span> bf = cur-&gt;_left-&gt;_bf;</span><br><span class="line">                    RotateRight(cur);</span><br><span class="line">                    RotateLeft(parent);</span><br><span class="line">                    <span class="keyword">if</span> (bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                        cur-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>) &#123;</span><br><span class="line">                        parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// cur-&gt;_left 没有子树</span></span><br><span class="line">                        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">-2</span> &amp;&amp; cur-&gt;_bf == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 左边的右边高</span></span><br><span class="line">                    <span class="keyword">int</span> bf = cur-&gt;_right-&gt;_bf;</span><br><span class="line">                    RotateLeft(cur);</span><br><span class="line">                    RotateRight(parent);</span><br><span class="line">                    <span class="keyword">if</span> (bf == <span class="number">-1</span>) &#123;</span><br><span class="line">                        parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>) &#123;</span><br><span class="line">                        cur-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// cur-&gt;_right 没有子树</span></span><br><span class="line">                        parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateRight</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subL = parent-&gt;_left;</span><br><span class="line">        pNode subLR = subL-&gt;_right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subL-&gt;_right = parent;</span><br><span class="line">        parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        pNode gParent = parent-&gt;_parent;</span><br><span class="line">        parent-&gt;_parent = subL;</span><br><span class="line">        <span class="keyword">if</span> (subLR) &#123;</span><br><span class="line">            subLR-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gParent-&gt;_left == parent) &#123;</span><br><span class="line">                gParent-&gt;_left = subL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gParent-&gt;_right = subL;</span><br><span class="line">            &#125;</span><br><span class="line">            subL-&gt;_parent = gParent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _root = subL;</span><br><span class="line">            subL-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新平衡因子</span></span><br><span class="line">        subL-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateLeft</span><span class="params">(pNode parent)</span> </span>&#123;</span><br><span class="line">        pNode subR = parent-&gt;_right;</span><br><span class="line">        pNode subRL = subR-&gt;_left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新left/right</span></span><br><span class="line">        subR-&gt;_left = parent;</span><br><span class="line">        parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新parent</span></span><br><span class="line">        <span class="keyword">if</span> (subRL) &#123;</span><br><span class="line">            subRL-&gt;_parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != _root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;_parent-&gt;_left == parent) &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_left = subR;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent-&gt;_parent-&gt;_right = subR;</span><br><span class="line">            &#125;</span><br><span class="line">            subR-&gt;_parent = parent-&gt;_parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _root = subR;</span><br><span class="line">            subR-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent-&gt;_parent = subR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新平衡因子</span></span><br><span class="line">        subR-&gt;_bf = parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftH = Height(root-&gt;_left);</span><br><span class="line">        <span class="keyword">int</span> rightH = Height(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> leftH &gt; rightH ? leftH + <span class="number">1</span> : rightH + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalance(_root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _isBalance(pNode root) &#123;</span><br><span class="line">    <span class="comment">// 1. 验证其为二叉搜索树</span></span><br><span class="line">    <span class="comment">//     如果中序遍历可得到一个有序的序列，就说明为二叉搜索树</span></span><br><span class="line">    <span class="comment">// 2. 验证其为平衡树</span></span><br><span class="line">    <span class="comment">//     每个节点子树高度差的绝对值不超过1(注意节点中如果没有平衡因子)</span></span><br><span class="line">    <span class="comment">//     节点的平衡因子是否计算正确</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightH = Height(root-&gt;_right);</span><br><span class="line">        <span class="keyword">int</span> leftH = Height(root-&gt;_left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;_bf != rightH - leftH) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data.first &lt;&lt; <span class="string">":"</span> &lt;&lt; root-&gt;_data.second &lt;&lt; <span class="string">"不平衡"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"平衡因子:"</span> &lt;&lt; root-&gt;_bf &lt;&lt; <span class="string">"高度差："</span> &lt;&lt; rightH - leftH &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(root-&gt;_bf) &lt; <span class="number">2</span></span><br><span class="line">            &amp;&amp; _isBalance(root-&gt;_left)</span><br><span class="line">            &amp;&amp; _isBalance(root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNode _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AVL树是一种高度平衡的二叉树，它改进了普通二叉搜索树在极端情况下会退化成单支效率低下的问题，AVL树中在每个节点中加入了平衡因子，使得左右子树的高度差不超过1，这样可以使得高度保持在log n，从而避免的极端情况下的查找效率低下问题，但是如果要对AVL树做一些结构修改的操
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="AVL树" scheme="https://Ranjiahao.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/07/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/07/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-16T16:00:00.000Z</published>
    <updated>2020-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树是一种特殊的二叉树，查找、插入时间复杂度较低O(log n)，它有这几个性质：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值</li><li>任意节点的左、右子树也分别为二叉搜索树</li><li>空树也是二叉搜索树</li></ul><p>查找：<br>由于它的这些性质，所以在查找的时候从根节点开始查找<br>在二叉搜索树b中查找x的过程为：<br>若b是空树，则搜索失败<br>若x等于b节点数据域的值，则查找成功<br>若x小于b节点数据域的值，则搜索左子树<br>若x大于b节点数据域的值，则搜索右子树<br>由于搜索的长度为树的高度，所以在一个平衡的情况下搜索效率为O(log n)</p><p>插入：<br>向一个二叉搜索树b中插入一个节点s的算法，过程为：<br>若树是空树，则将s所指节点作为根节点插入<br>若s-&gt;data等于b的根节点的数据域之值，则返回<br>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中<br>若s-&gt;data大于b的根节点的数据域之值，则把s所指节点插入到右子树中<br>同样插入效率为O(log n)</p><p>删除：</p><ol><li>若要删除的结点无孩子结点，直接删除即可</li><li>若要删除的结点只有左孩子结点，使被删除节点的双亲结点指向被删除节点的左孩子结点</li><li>若要删除的结点只有右孩子结点，使被删除节点的双亲结点指向被删除结点的右孩子结点</li><li>若要删除的结点有左、右孩子结点，在它的右子树中寻找关键码最小或在左子树寻找关键码最大的节点，用它的值填补到被删除节点中，效率O(log n)</li></ol><p>但这这样存在一些问题，当二叉搜索树退化为左右单支时，它的平均比较次数为n/2，这样二叉搜索树性能就失去了，所以我们可以通过别的办法来改进，如AVL树、红黑树…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BSTree.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    BSTNode(<span class="keyword">const</span> T&amp; data = T())</span><br><span class="line">        : _left(<span class="literal">nullptr</span>)</span><br><span class="line">        , _right(<span class="literal">nullptr</span>)</span><br><span class="line">        , _data(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    BSTNode&lt;T&gt;* _left;</span><br><span class="line">    BSTNode&lt;T&gt;* _right;</span><br><span class="line">    T _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> BSTNode&lt;T&gt; Node;</span><br><span class="line">    <span class="keyword">typedef</span> Node* pNode;</span><br><span class="line"></span><br><span class="line">    BSTree()</span><br><span class="line">        : _root(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    BSTree(<span class="keyword">const</span> BSTree&lt;T&gt;&amp; bst) &#123;</span><br><span class="line">        _root = Copy(bst._root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTree&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BSTree&lt;T&gt;&amp; bst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;bst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_root) &#123;</span><br><span class="line">                destroy(_root);</span><br><span class="line">            &#125;</span><br><span class="line">            _root = Copy(bst._root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~BSTree() &#123;</span><br><span class="line">        destroy(_root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pNode <span class="title">Find</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入新的节点</span></span><br><span class="line">        cur = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="comment">// 判断插入的位置</span></span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;_data &gt; data) &#123;</span><br><span class="line">            parent-&gt;_left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;_right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode cur = _root;</span><br><span class="line">        pNode parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data == data) &#123;</span><br><span class="line">                <span class="comment">// 找到了要删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点右为空</span></span><br><span class="line">                    <span class="keyword">if</span> (cur != _root) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                            parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _root = cur-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                    cur = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点左为空</span></span><br><span class="line">                    <span class="keyword">if</span> (cur != _root) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent-&gt;_left == cur) &#123;</span><br><span class="line">                            parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _root = cur-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                    cur = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 要删除的节点左右都不为空</span></span><br><span class="line">                    <span class="comment">// 寻找左子树最大节点，或右子树最小节点替换</span></span><br><span class="line">                    pNode leftMax = cur-&gt;_left;</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    <span class="comment">// 寻找最右节点</span></span><br><span class="line">                    <span class="keyword">while</span> (leftMax-&gt;_right) &#123;</span><br><span class="line">                        parent = leftMax;</span><br><span class="line">                        leftMax = leftMax-&gt;_right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 交换值 cur&lt;--&gt;左子树最右节点</span></span><br><span class="line">                    cur-&gt;_data = leftMax-&gt;_data;</span><br><span class="line">                    <span class="comment">// 删除最右节点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent-&gt;_left == leftMax) &#123;</span><br><span class="line">                        <span class="comment">// 左子树的最右节点为左子树的根</span></span><br><span class="line">                        parent-&gt;_left = leftMax-&gt;_left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左子树的最右节点不为左子树的根</span></span><br><span class="line">                        parent-&gt;_right = leftMax-&gt;_left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> leftMax;</span><br><span class="line">                    leftMax = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;_data &gt; data) &#123;</span><br><span class="line">                cur = cur-&gt;_left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;_right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _Inorder(_root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">pNode <span class="title">Copy</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode newRoot = <span class="keyword">new</span> Node(root-&gt;_data);</span><br><span class="line">        newRoot-&gt;_left = Copy(root-&gt;_left);</span><br><span class="line">        newRoot-&gt;_right = Copy(root-&gt;_right);</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            destroy(root-&gt;_left);</span><br><span class="line">            destroy(root-&gt;_right);</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _Inorder(pNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _Inorder(root-&gt;_left);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            _Inorder(root-&gt;_right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNode _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉搜索树是一种特殊的二叉树，查找、插入时间复杂度较低O(log n)，它有这几个性质：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值&lt;/li&gt;&lt;li&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值&lt;/l
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="二叉搜索树" scheme="https://Ranjiahao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型与及多路复用详解</title>
    <link href="https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2020/07/16/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2020-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五种io模型"><a class="markdownIt-Anchor" href="#五种io模型"></a> 五种IO模型</h1><ul><li><p>阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都是阻塞方式，流程简单，但是任务处理效率低，无法充分利用资源</p></li><li><p>非阻塞IO：若内核还未将数据准备好，系统调用返回EWOULDBLOCK错误码，往往需要循环的方式反复尝试读写文件描述符，对资源的利用充分，但IO不够实时，且对CPU来说是较大的浪费<br>可以通过<code>int fcntl(int fd, int cmd, ... /* arg */ );</code>函数设置<code>int fl = fcntl(fd, F_GETFL);fcntl(fd, F_SETFL, fl | O_NONBLOCK)</code></p></li><li><p>信号驱动IO：建立SIGIO的信号处理程序，内核将数据准备好的时候，使用SIGIO信号通知应用程序进行IO操作，资源利用充分，比非阻塞IO实时</p></li><li><p>多路转接IO：发起多路转接IO，将需要等待的文件描述符添加监控，然后由内核轮询遍历，进程一直等待任意一个文件描述符就绪，然后进行IO操作</p></li><li><p>异步IO：发起异步IO系统调用，直接返回，然后由内核等待，并由内核自动拷贝数据，拷贝完成后通知应用程序，对资源的利用最为充分，且效率最高</p></li><li><p>这五种IO模型处理的效率逐渐增加，对资源(cpu)的利用也更加充分，但是流程也越来越复杂</p></li></ul><h1 id="多路转接"><a class="markdownIt-Anchor" href="#多路转接"></a> 多路转接</h1><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>系统调用<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>nfds：需要监视的最大的文件描述符值+1<br>readfds,writefds,exceptfds：分别对应需要检测的可读、可写、异常文件描述符集合<br>timeout：用来设置select()的等待时间。NULL表示select将一直被阻塞，直到某个文件描述符上发生了事件，0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生，特定的时间值：如果在指定的时间段里没有事件发生，select将超时返回<br>执行成功则返回文件描述词状态已改变的个数，如果返回0代表在描述词状态改变前已超过timeout时间，没有返回，当有错误发生时则返回-1，错误原因存于errno，此时参数readfds，writefds, exceptfds和timeout的值变成不可预测</p><p><strong>fd_set结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE        1024</span></span><br><span class="line"><span class="comment">// select.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> __fd_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NFDBITS   (8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>这个结构就是一个整数数组构成的位图，位图中对应的位来表示要监视的文件描述符，提供了一组操作fd_set的接口来方便的操作位图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来清除描述词组set中相关fd 的位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 用来测试描述词组set中相关fd 的位是否为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;  <span class="comment">// 用来设置描述词组set中相关fd的位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;         <span class="comment">// 用来清除描述词组set的全部位</span></span><br></pre></td></tr></table></figure><p><strong>timeval结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>    </span></span><br><span class="line"><span class="class">  &#123;</span>    </span><br><span class="line">    <span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds.  */</span>    </span><br><span class="line">    <span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds.  */</span>                     </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>定义指定监控事件的描述符集合（即位图），初始化集合后，将需要监控指定事件的描述符添加到指定事件（可读、可写、异常）的描述符集合中<br>select将描述符集合拷贝到内核当中，对集合中所有描述符进行轮询判断，当描述符就绪或者等待超时后就调用返回，返回后的集合中只剩下已就绪的描述符（未就绪会在位图中置为0）<br>用户通过遍历描述符，判断哪些描述符还在集合中，就可以知道哪些描述符已经就绪了，开始处理对应的IO事件</p><p>读就绪：socket内核中接收缓冲区中的字节数大于等于低水位标记SO_RCVLOWAT（默认1字节），此时可以无阻塞的读该文件描述符，并且返回值大于0；socket TCP通信中，对端关闭连接，此时对该socket读，则返回0；监听的socket上有新的连接请求；socket上有未处理的错误<br>写就绪：socket内核中发送缓冲区中的字节数（发送缓冲区的空闲位置大小）大于等于低水位标记SO_SNDLOWAT，此时可以无阻塞的写，并且返回值大于0；socket的写操作被关闭（close或者shutdown）对一个写操作被关闭的socket进行写操作，会触发SIGPIPE信号；socket使用非阻塞connect连接成功或失败之后；socket上有未读取的错误;<br>异常就绪：socket上收到带外数据</p><p><strong>缺点</strong></p><ol><li>select能监控的最大描述符有限，由宏__FD_SETSIZE决定，默认是1024个</li><li>select会将集合拷贝到内核中轮询遍历判断描述符是否就绪，效率会随着描述符的增多而越来越低</li><li>select监控完毕后返回的集合中只有已就绪的描述符，移除了未就绪的描述符，所以每次监控都必须要重新将描述符加入集合中，重新拷贝到内核</li><li>select返回的集合是一个位图而不是真正的描述符数组，所以需要用户遍历判断哪个描述符在集合中才能确认其是否就绪</li></ol><p><strong>优点</strong></p><ol><li>select遵循posix标准，可以跨平台移植</li><li>select的超时等待时间较为精确，可以精细到微秒</li></ol><p>tcp_select服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_select_srv.cc</a></p><h2 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h2><p>系统调用接口<code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><br>fds：poll函数监听的结构列表，包含了三部分内容，文件描述符、监听的事件集合、返回的事件集合<br>nfds：表示fds数组的长度<br>timeout：表示poll函数的超时时间，单位是毫秒(ms)<br>返回值小于0，表示出错；返回值等于0，表示poll函数等待超时；返回值大于0，表示poll由于监听的文件描述符就绪而返回</p><p><strong>pollfd结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events和revents取值：POLLIN可读、POLLOUT可写</p><p><strong>原理</strong></p><ul><li><p>定义pollfd结构体数组，将需要监控的描述符以及监控的事件信息添加进去</p></li><li><p>发起监控调用poll，将数组中的数据拷贝到内核当中进行轮询遍历监控，当有描述符就绪或者等待超时后返回，返回时将已就绪的事件添加进pollfd结构体中的revents中（如果没就绪，则为0）</p></li><li><p>监控调用返回后，遍历pollfd数组中的每一个节点的revents，根据对应的就绪时间进行相应操作</p></li></ul><p><strong>缺点</strong></p><ol><li><p>每次调用poll都需要把大量的pollfd结构从用户态拷贝到内核中，在内核中轮询判断描述符是否就绪，效率会随着描述符的增加而下降</p></li><li><p>每次调用返回后需要用户自行判断revents才能知道是哪个描述符就绪了哪个事件</p></li><li><p>无法跨平台移植</p></li><li><p>超时等待时间只精确到毫秒</p></li></ol><p><strong>优点</strong></p><ol><li>poll通过描述符事件结构体的方式将select的描述符集合的操作流程合并在一起，简化了操作</li><li>poll并没有最大数量限制（但是数量过大后性能也是会下降）</li><li>poll每次监控不需要重新定义事件结构</li></ol><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><p>系统调用<br><code>int epoll_create(int size);</code>创建一个epoll的句柄<br>自从linux2.6.8之后，size参数是被忽略的，用完之后，必须调用close()关闭</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>注册要监听的事件类型<br>epfd：epoll_create返回的句柄<br>op：EPOLL_CTL_ADD，注册新的fd到epfd中；EPOLL_CTL_MOD，修改已经注册的fd的监听事件；EPOLL_CTL_DEL，从epfd中删除一个fd；<br>fd：需要监听的fd<br>event：告诉内核需要监听什么事</p><p><strong>epoll_event结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;    <span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure><p>events取值：EPOLLIN表示对应的文件描述符可以读 (包括对端SOCKET正常关闭)；EPOLLOUT表示对应的文件描述符可以写；EPOLLET将EPOLL设为边缘触发，一般将data.fd设置为需要监听的fd</p><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code>收集在epoll监控的事件中已经发送的事件（异步阻塞）<br>events：分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）<br>maxevents：告诉内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size参数<br>timeout：超时时间（毫秒，0会立即返回，-1是永久阻塞)<br>如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时，返回小于0表示函数失败</p><p><strong>原理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件，这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是log(n)，其中n为树的高度)而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当响应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback，它会将发生的事件添加到rdlist双链表中，在epoll中，对于每一个事件，都会建立一个epitem结构体，当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可，如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户，这个操作的时间复杂度是O(1)</p><p><strong>优点</strong></p><ol><li>文件描述符数目无上限</li><li>数据拷贝轻量，只在调用EPOLL_CTL_ADD将文件描述符结构拷贝到内核中</li><li>事件回调机制，避免使用遍历，而是使用回调函数的方式，将就绪的文件描述符结构加入到就绪队列中，epoll_wait返回直接访问就绪队列就知道哪些文件描述符就绪，这个操作时间复杂度O(1)即使文件描述<br>符数目很多, 效率也不会受到影响</li></ol><p><strong>缺点</strong></p><ol><li>无法跨平台移植</li><li>超时等待时间只精确到毫秒</li><li>在活动连接较多的时候，由于会大量触发回调函数，所以此时epoll的效率未必会select和poll高，所以epoll适用于连接数量多，但是活动连接少的情况</li></ol><p>应用场景：对于多连接，且多连接中只有一部分连接比较活跃时，比较适合使用epoll</p><h3 id="lt模式与et模式"><a class="markdownIt-Anchor" href="#lt模式与et模式"></a> LT模式与ET模式</h3><p>epoll默认状态下就是LT工作模式，只要接收缓冲区中数据大于低水位标记（可读），或者发送缓冲区中剩余空间大于低水位标记（可写）就会一直触发事件，支持阻塞读写和非阻塞读写，LT模式简单稳定<br>tcp_epoll_lt服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_lt_srv.cc</a></p><p>ET模式，只有新数据到来是触发可读时间，或者剩余空间大小从无到有的时候才会触发事件，只支持非阻塞的读写<br>tcp_epoll_et服务器：<a href="https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/blob/master/socket/tcp/tcp_epoll_et_srv.cc</a><br>使用ET能够减少epoll触发的次数，但是代价就是必须一次把所有的数据都处理完，代码复杂，还有一种场景适合ET模式使用，如果我们需要接受一条数据，但是这条数据因为某种问题导致其发送不完整，需要分批发送。所以此时的缓冲区中数据只有部分，如果此时将其取出，则会增加维护数据的开销，正确的做法应该是等待后续数据到达后将其补全，再一次性取出。但是如果此时使用的是LT模式，就会因为缓冲区不为空而一直触发事件，所以这种情况下使用ET会比较好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;五种io模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#五种io模型&quot;&gt;&lt;/a&gt; 五种IO模型&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;阻塞IO：系统调用会一直等待，直到内核数据准备就绪，然后进行内核和用户空间的数据交换。所有的套接字，默认都
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="多路转接" scheme="https://Ranjiahao.github.io/tags/%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://ranjiahao.github.io/2020/07/07/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ranjiahao.github.io/2020/07/07/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2020-07-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>有连接：只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费，应用程序可以不用顾虑提供尽职服务的IP网络上可能发生的各种问题，依然可以转发数据</li><li>可靠：检验和、序列号、确认应答、超时重传、连接管理</li><li>避免大量丢包：滑动窗口机制、流量控制、拥塞控制</li><li>提高性能：延时确认应答、捎带应答、快速重传</li><li>面向字节流：创建一个TCP的socket，同时在内核中创建一个发送缓冲区和一个接收缓冲区。发送数据时，tcp根据头部将除头部外的数据写入发送缓冲区，如果发送的字节数太长，会被拆分成多个TCP的数据包发出，如果发送的字节数太短，就会先在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的时机发送出去。接收数据时，数据也是从网卡驱动程序到达内核的接收缓冲区，然后应用程序可以调用read从接收缓冲区拿数据。缺陷：应用层数据粘包，可以采用特殊字符间隔(如http，数据中如果有这个特殊字符就要进行转义)、数据定长(保证每次都按固定大小读取即可，可能需要补位)、在应用层协议头中定义数据长度方式来解决(如http、udp)</li></ul><p>协议格式<br><img src="img1.png" alt="img1"><br>32位序列号：每发送一次数据，序列号就会累加一次该数据的字节数大小，序列号是由随机数作为初始值，通过SYN包传递给主机（SYN和FIN包并不携带数据，但会作为一个字节增加对应的序号）<br>32位确认应答号：下一次应该收到数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都被正常接收<br>4位数据偏移：可也看作TCP首部长度，该字段长4位，单位为4字节，不包括选项的话，数据偏移量最小设置5，说明TCP首部是5*4=20位，最大15*4=60位<br>4位保留位：一般全0，为了以后扩展使用<br>8位置控制位：<br><img src="img2.png" alt="img2"><br>CWR：用于IP首部ECN字段，ECE标志为1时，则通知对方已将拥塞窗口缩小<br>ECE：用于IP首部ECN字段，收到IP首部ECN为1时，则置为1，通知通信对方，发送网络拥塞<br>URG：紧急指针是否有效<br>ACK：确认号是否有效<br>PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走，为0时则先进行缓存<br>RST：出现异常，重新建立连接，复位报文段<br>SYN：请求建立连接，同步报文段<br>FIN：通知对方，本端关闭，结束报文段<br>16位窗口大小：通知从相同TCP首部的确认应答号所指位置开始能接收的数据大小，如果窗口为0，则表示可以发送窗口探测，以了解最新窗口大小，这个数据必须是1个字节，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位<br>16位校验和：和UDP一样还需要校验伪首部，区别在于TCP校验和无法关闭<br><img src="img3.png" alt="img3"><br>16位紧急指针：在URG为1时才有效，指向紧急数据末尾，也就是说从数据首位到紧急指针所指向的位置为紧急数据。一般在暂时中断通信或中断通信的情况下使用，此外紧急指针也用作表示数据流分段的标志<br>选项：含有最大段长度情况、窗口扩大因子、时间戳字段（区分新老序列号）等</p><h1 id="确认应答机制"><a class="markdownIt-Anchor" href="#确认应答机制"></a> 确认应答机制</h1><p>TCP将每个字节的数据都进行了编号（初始值是在建立连接以后由随机数生成，计算则是每一字节加一）即为序列号，每一个ACK都带有对应的确认序列号，如果确认应答，说明数据已经成功到达对端，反之，则数据丢失的可能性很大，在一定时间没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。也可能对方已经收到数据只是返回的确认应答在途中丢失，这种情况下也会进行重发，接收端在发现有相同数据到达时会丢弃数据<br><img src="img4.png" alt="img4"><br>数据长度并未写入TCP首部，通过IP首部中数据包长度-IP首部长度-TCP首部长度</p><h1 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h1><p>在重发数据之前，等待确认应答到来的那个特定时间间隔，如过超过了这个时间仍未收到确认应答，发送端将进行数据重发。TCP在每次发包时都会计算往返时间及其偏差，将这个往返时间和偏差相加，超时重传的时间就是比这个总和要稍大一点的值<br>在BSD的Unix以及Windows系统中，超时都以0.5s为单位进行控制，因此超时重传时间都是0.5s的整数倍，偏差最小值也是0.5s，所以最小重发时间至少为1s，不过，由于最初的数据包还不知道往返时间，所以重发时间一般设置为6s左右，若数据被重发以后还是收不到确认应答，则再次重发，等待确认应答的时间将会以2倍、4倍的指数函数延长，当达到一定重发次数后，就会判断为网络或对端主机异常，强制关闭连接</p><h1 id="连接管理机制"><a class="markdownIt-Anchor" href="#连接管理机制"></a> 连接管理机制</h1><p>TCP利用首部控制字段来管理TCP连接<br><img src="img5.png" alt="img5"><br>在建立TCP连接的同时，也可以确定发送数据包的单位（MSS最大消息长度）两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后会在两者之间选择一个较小的值使用<br>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位</p><h2 id="保活机制"><a class="markdownIt-Anchor" href="#保活机制"></a> 保活机制</h2><blockquote><p>sysctl -a | grep keepalive<br>默认：通信双方7200s没有数据往来，则每隔75s发送一个保活探测数据报，要求对方进行响应<br>若连续9次没有得到响应，则认为连接断开，并将socket状态置为CLOSE_WAIT</p></blockquote><h2 id="三次握手四次挥手"><a class="markdownIt-Anchor" href="#三次握手四次挥手"></a> 三次握手/四次挥手</h2><p>三次握手：客户端通过向服务器端发送一个SYN来创建一个主动打开，并进入状态SYN_SENT，客户端把这段连接的序号设定为随机数A，服务器端应当为一个合法的SYN回送一个SYN/ACK，并进入状态SYN_RCVD。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。最后，客户端再发送一个ACK，并进入状态ESTABLISHED，此时包的序号被设定为A+1，而ACK的确认码则为B+1。当服务端收到这个ACK的时候，就完成了三次握手，并进入状态ESTABLISHED<br>如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端会重发SYN-ACK(超时重传)，一定次数后还是没有收到ACK就会从未完成连接队列中删除套接字<br>三次握手原因：如果是两次握手，那么假设客户端第一次握手的SYN在网络中延迟了，超时后客户端未收到服务器的确认报文，就会重传一份SYN，然后服务端返回确认报文，TCP连接建立，接着若客户端最早发送的SYN到达服务端，服务端也回复ACK，然后又建立一个TCP连接，而且这个服务端一直在等待客户端数据造成大量资源开销。还有种情况是，若客户端收到SYN后，回复ACK丢包，也会造成多余的资源开销。同时三次握手可以满足两个条件：A确定B能收发信息，B确定A能收发信息<br>四次挥手：<br><img src="img6.png" alt="img6"><br>客户端主动调用close或shutdown(fd, WR)时，向服务器发送FIN，同时进入FIN_WAIT_1，表示客户端不再发送数据。服务器收到FIN包后立马回复ACK，同时进入CLOSE_WAIT状态。客户端收到ACK后进入FIN_WAIT_2。由于客户端只是关闭了写端，还能读取数据，服务端可以继续发送数据，在完成数据传送后，将发送一个FIN，同时进入LAST_ACK，表示服务端不再发送数据。客户端收到FIN后，回复ACK，同时进入TIME_WAIT，2MSL后进入CLOSED状态。服务端收到ACK后进入CLOSED状态<br>2MSL：cat /proc/sys/net/ipv4/tcp_fin_timeout 查看msl的值，Centos7上默认配置的值是60s，保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的）<br>同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN，这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK）</p><h3 id="time_waitclose_wait"><a class="markdownIt-Anchor" href="#time_waitclose_wait"></a> TIME_WAIT/CLOSE_WAIT</h3><p>TIME_WAIT是主动关闭方出现的状态，如果一台主机出现大量的TIME_WAIT，证明这台主机大量的主动关闭了连接，常见于爬虫服务器，可以调整TIME_WAIT时间，或者地址重用允许套接字绑定使用的中地址端口，使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示端口释放后立即就可以被再次使用<code>int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</code></p><p>CLOSE_WAIT是被动关闭方的状态，<br>一般来说服务器上出现大量的CLOSE_WAIT状态，原因就是服务器没有正确的关闭socket，导致四次挥手没有正确完成，只需要加上对应的close即可解决问题</p><h1 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h1><p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，包的往返时间越长通信性能就越低，为解决这个问题，TCP引入了窗口这个概念，我们可以一次发送多条数据，并行压缩等待时间，也就是说，在发送了一个段以后不必一直等待确认应答，而是继续发送<br><img src="img7.png" alt="img7"><br>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，窗口内的数据即使没有收到确认应答也可以发送出去，发送端在收到窗口左沿第一段数据的确认应答后，窗口左沿才向右移动<br><img src="img8.png" alt="img8"></p><p><strong>丢包情况</strong><br>情况一：数据包抵达，ACK丢失<br><img src="img9.png" alt="img9"><br>这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认，如果第一条ack(下一个是1001)丢失，主机A收到第二条ack(下一个是2001)，则主机A就可以推断数据2001之前的数据都顺利到达不需要重发<br>情况二：数据包丢失<br><img src="img10.png" alt="img10"><br>如果1001~2000数据包丢失，则发送端会一直收到序号为1001的确认应答，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回，而发送端如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发，这个时候接收端收到了1001之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端其实之前就已经收到了（这里是选择重传协议，类似还有停止等待协议、回退n步协议），被放到了接收端操作系统内核的接收缓冲区中，这种机制叫快速重传</p><h1 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h1><p>接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送就会造成丢包，继而引起丢包重传等等一系列连锁反应，因此TCP支持根据接收端的处理能力来决定发送端的发送速度。接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，TCP首部中，又一个专门的字段用来通知窗口大小，接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端，这个字段的值越大，说明网络的吞吐量越高<br><img src="img11.png" alt="img11"></p><h1 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h1><p>虽然TCP有了滑动窗口机制，能够高效可靠的发送大量的数据，但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题，为了解决此问题，TCP引入慢启动机制，先发少量的数据，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据<br><img src="img12.png" alt="img12"><br>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念，将这个拥塞窗口的大小设置为1个数据段(1MSS)发送的数据，之后每一次确认应答，拥塞窗口就增加，在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后选择其中较小的值，发送比其还要小的数据量。不过，随着每次往返，阻塞窗口也会以1、2、4等指数函数的增长，可能会导致网络拥塞的发生，为了不增长的那么快，因此不能使拥塞窗口单纯加倍，所以引入了慢启动阈值的概念，只要拥塞窗口的值超出了这个阈值，每收到一次确认应答时，只允许以<br>（1个数据段字节数/拥塞窗口字节数）*1个数据段字节数的比例放大拥塞窗口<br><img src="img13.png" alt="img13"><br>TCP的通信开始时，并没有设置相应的慢启动阈值，而是在超时重发时，才会设置为当时拥塞窗口（实际已发送但未收到确认应答的数据量）一半的大小，由重复确认应答进行高速重发控制时，慢启动阈值的大小被设置为当时窗口大小的一半，然后将窗口大小设置为该启动阈值+3个数据段的大小（这种网络拥堵相较于超时重发要轻一些）</p><h1 id="nagle算法"><a class="markdownIt-Anchor" href="#nagle算法"></a> Nagle算法</h1><p>TCP中为了提高网络利用率，经常使用一个叫Nagle的算法。发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制，仅在满足下列任意一种条件下才能发送数据</p><ul><li>已发送的数据都已经收到确认应答时</li><li>可以发送最大段长度(MSS)的数据时</li></ul><h1 id="延时确认应答"><a class="markdownIt-Anchor" href="#延时确认应答"></a> 延时确认应答</h1><p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口，因为刚接收完数据，还没来得及从缓冲区取出。为此，可以在接收数据后不立即返回确认应答，而是延迟一段时间的机制。</p><ul><li>在没有收到2*最大段长度的数据（和操作系统有关）为止不做确认应答</li><li>其他情况下，最大延迟0.5s（有些操作系统为0.2s，时间越小、CPU的负荷会越高，性能也下降；反之时间越长可能导致超时重发，窗口在只有1个数据段时，性能也会下降）<br><img src="img14.png" alt="img14"></li></ul><h1 id="捎带应答"><a class="markdownIt-Anchor" href="#捎带应答"></a> 捎带应答</h1><p>在一些通信中TCP的确认应答和回执数据可以通过一个包发送，通过这种机制，可以使收发的数据量减少。接收数据以后如果立刻返回确认应答，就无法实现捎带应答，而是将所接收的数据传给应用处理生成返回数据以后再进行发送请求为止，延时确认应答时实现捎带应答的基础<br><img src="img15.png" alt="img15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;有连接：只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费，应用程序可以不用顾虑提供尽职服务的IP网络上可能发生的各种问题，依然可以转发数据&lt;/li&gt;&lt;li&gt;可靠：检验和、序列号、确认应答、超时重传、连接管理&lt;/li&gt;&lt;li&gt;避免大量丢包：滑动窗口机
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="TCP" scheme="https://Ranjiahao.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="https://ranjiahao.github.io/2020/07/06/UDP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ranjiahao.github.io/2020/07/06/UDP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-05T16:00:00.000Z</published>
    <updated>2020-07-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>无连接：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，知道了对端的IP和端口就可以随时发送数据</li><li>不可靠：应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上，即使出现网络拥堵，UDP也无法进行流量控制等避免网络堵塞行为，此外，传输途中即使出现丢包，UDP也不负责重发，也不保证包序，需要应用层来保证这些，报头短，不需要可靠传输，所以传输速度快</li><li>面向数据报：应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并（如果发送端调用一次sendto，发送100个字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节；而不能循环调用10次recvfrom，每次接收10个字节）不能够灵活的控制读写数据的次数和数量</li><li>UDP没有真正意义上的发送缓冲区，sendto会直接将整个报文交给内核，由内核将数据传给网络层协议后进行后续的传输动作。UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃</li><li>全双工通信：UDP的socket既能读，也能写，udp在协议栈层面实现了广播功能：通过给一个ip地址发送数据，实现将数据发送到局域网所有主机</li><li>通常被用在包总量较少的通信（DNS、SNMP等）、即时通信、限定于LAN等特定网络中的应用通信、广播通信（广播，多播）RIP、DHCP等</li></ul><p>协议格式：<br><img src="img1.png" alt="img1"><br>16位包长度：限制了UPD报文总长度，包含包头在内不能超过64K，如果需要传输的数据超过64K，就要在应用层手动分包，多次发送，并在接收端手动拼装<br>16位校验和：数据传输过程中会产生误码，0可能变为1，1可能变为0，所以需要校验，以16比特为单位对报文进行取反求和，若进位则将进位加到校验和字段中。接收端接收到校验和后，执行相同的操作，得到检验和结果为全1，则数据未出错<br>由于UDP首部只有五元组中的源端口和目标端口，余下三项都在IP首部里，若其他三项信息被破坏则就可能导致该收包的应用收不到包，不该收到包的应用却收到了包，为了解决这个问题，就引入了伪首部的概念，此外IPv6的IP首部无校验和字段，TCP或UDP通过伪首部，得以对5元组进行校验，实现即使在IP首部并不可靠的情况下仍然能提供可靠的通信传输<br>伪首部：<br><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200820152924511.png" alt="image-20200820152924511"><br>伪首部的明智之处在于，用它来计算校验和，我们能提供这些保护，而不必真的发送为报头本身的那些域。从而消除了用在伪真报头中的TCP的IP域的重复使用；避免了冗余和带宽的浪费。其缺点在于这种计算校验和的方法需要更多的时间和精力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;无连接：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，知道了对端的IP和端口就可以随时发送数据&lt;/li&gt;&lt;li&gt;不可靠：应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上，即使出现网络拥堵，UDP也无法进行流量控制等避免网络堵塞行为，此外，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="UDP" scheme="https://Ranjiahao.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>SocketAPI</title>
    <link href="https://ranjiahao.github.io/2020/07/03/SocketAPI/"/>
    <id>https://ranjiahao.github.io/2020/07/03/SocketAPI/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>套接字就是网络进程的进程ID，和普通进程ID不同，网络进程的ID是由运行这个进程的计算机IP地址和这个进程使用的端口所组成</p><h1 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h1><p><strong>通信流程</strong><br>服务端：</p><ol><li>创建套接字，在内核中创建socket结构体，通过这个结构体使进程和网卡建立联系</li><li>为套接字绑定地址信息，在内核创建的socket结构体中描述地址和协议信息，客户端需要知道服务端的地址，所以服务端地址必须固定</li><li>接收数据，从socket的接收缓冲区中接收数据</li><li>发送数据，将数据放在socket的发送缓存区中，操作系统选择合适的时机封装发送数据</li><li>关闭套接字，释放资源</li></ol><p>客户端：</p><ol><li>创建套接字</li><li>为套接字绑定地址信息，客户端不推荐主动绑定地址信息，让操作系统选择合适的地址和端口绑定，降低端口冲突概率</li><li>发送数据</li><li>接收数据</li><li>关闭套接字</li></ol><blockquote><p>创建/关闭socket<br><code>int socket(int domain, int type, int protocol);</code><br><code>int close(int fd);</code><br>domain: 地址域，确定本次通信协议版本的地址结构，AF_INET(IPV4网络协议)、AF_INET6(IPV6网络协议)、AF_UNIX(本地通信协议)<br>type: 套接字类型，SOCK_STREAM(数据流式套接字)SOCK_DGRAM(数据报式套接字)<br>protocol: 协议类型，0套接字类型默认协议，IPPROTO_TCP(6) IPPROTO_UDP(17)这些宏netinet/in.h中<br>成功返回文件描述符，失败返回-1，并设置错误码</p></blockquote><blockquote><p>绑定端口号(TCP/UDP服务器端)<br><code>int bind(int socket, const struct sockaddr *address, socklen_t address_len);</code><br>socket: socket函数返回的文件描述符<br>成功返回0，失败返回-1，并设置错误码<br>address&amp;address_len: 由于各种网络协议的地址格式并不相同，如sockaddr_in(IPV4)、sockaddr_in6(IPV6)、sockaddr_un(UNIX Domain Socket)等，这些结构体大小不一定相同，所以需要传入地址大小。但是前16位都是地址类型，socket API使用的时候需要强制转化成struct sockaddr类型传入函数，函数内部通过前16位确定协议类型，用不同处理方式处理信息内容<br>以ipv4为例：<br><img src="img1.png" alt="img1"></p></blockquote><p><strong>地址转换函数</strong><br>我们通常用点分十进制的字符串表示IP地址，以下函数可以在字符串表示和in_addr表示之间转换<br>点分十进制字符串转uint32_t：<br><code>in_addr_t inet_addr(const char *cp);</code><br><code>int inet_aton(const char *cp, struct in_addr *inp);</code><br><code>int inet_pton(int af, const char *src, void *dst);</code> 兼容IPV6<br>uinit32_t转点分十进制字符串：<br><code>char *inet_ntoa(struct in_addr in);</code><br><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 兼容IPV6<br>inet_ntoa函数，是把这个返回结果放到了静态存储区，不需要我们手动进行释放<br>但是连续调用两次会覆盖上一次的结果，不是线程安全的函数<br>多线程环境下，推荐使用inet_ntop</p><blockquote><p>接收/发送数据<br><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code><br>sockfd: socket操作句柄<br>buf: 用于接收从接收缓冲区取出的数据<br>len: 要接收的数据长度<br>flags: 默认为0，表示阻塞<br>src_addr: 用于接收发送方的地址信息<br>addrlen: 输入输出型参数，输入要获取的地址长度，输出实际获取的地址长度<br>成功返回实际接收到的数据字节长度，失败返回-1，并设置错误码<br><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code><br>sockfd: socket操作句柄<br>buf: 要往发送缓冲区发送的数据首地址<br>len: 要发送的数据长度<br>flags: 默认为0，表示阻塞<br>dest_addr: 接收方地址信息<br>addrlen: 地址信息长度<br>成功返回实际发送的数据字节长度，失败返回-1，并设置错误码</p></blockquote><h1 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h1><p><strong>通信流程</strong><br>服务端：</p><ol><li>创建套接字，在内核中创建socket结构体，通过这个结构体使进程和网卡建立联</li><li>为套接字绑定地址信息，在内核创建的socket结构体中描述地址和协议信息，客户端需要知道服务端的地址，所以服务端地址必须固定</li><li>进入listen状态，等待客户端连接，内核中维护了两个队列：未完成连接队列和已完成连接队列，队列的最大容量就为backlog，队列满了则新连接请求将会被丢弃。当客户端创建套接字对服务器端的监听套接字发起连接请求，此时内核创建新套接字，用五元组唯一标识，放入半连接接队列，当三次握手完成后，则将这个新的套接字放入全连接队列中</li><li>accept，从监听套接字的已完成连接队列中获取一个新套接字，通信由新的套接字完成</li><li>接收数据/发送数据，TCP协议提供全双工通信</li><li>关闭套接字，释放资源</li></ol><p>客户端：</p><ol><li>创建套接字</li><li>为套接字绑定地址信息，客户端不推荐主动绑定地址信息，让操作系统选择合适的地址和端口绑定，降低端口冲突概率</li><li>connect向服务器发起连接请求</li><li>发送数据/接收数据</li><li>关闭套接字</li></ol><blockquote><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>sockfd: socket操作句柄<br>addr: 对端地址<br>addrlen: 对端地址长度<br><code>int listen(int sockfd, int backlog);</code><br>sockfd: 监听套接字句柄<br>backlog: 最大并发连接数<br>成功返回0，失败返回-1，并设置错误码<br><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>sockfd: 监听套接字句柄<br>addr: 输出型参数获取客户端地址<br>addrlen: 输入输出型参数，输入调用者提供的缓冲区addr的长度以避免缓冲区溢出，输出客户端地址结构体的实际长度</p></blockquote><blockquote><p>接收/发送数据<br><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code><br><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code><br>由于tcp通信套接字中已经标识了五元组，因此不需要对方信息<br>recv没有数据阻塞，连接断开则返回0<br>send缓冲区满了则阻塞，连接断开触发SIGPIPE异常</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;套接字就是网络进程的进程ID，和普通进程ID不同，网络进程的ID是由运行这个进程的计算机IP地址和这个进程使用的端口所组成&lt;/p&gt;&lt;h1 id=&quot;udp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#udp&quot;&gt;&lt;/a&gt; UDP&lt;/h1&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="Socket" scheme="https://Ranjiahao.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="https://ranjiahao.github.io/2020/07/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://ranjiahao.github.io/2020/07/01/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议分层"><a class="markdownIt-Anchor" href="#协议分层"></a> 协议分层</h1><p>IOS提出OSI参考模型，帮助不同类型的主机实现数据传输，这一模型将通信协议中必要的功能分成了7层，这一模型中，每个分层都接收由它下一层所提供的特定服务，并为上一层提供服务，上下层之间交互所遵守的约定叫”接口“，同一层之间交互所遵守的约定叫”协议“，分层可以将每一个独立使用，即使系统中某些分层变化，也不影响整个系统，OSI参考模型通过每一层协议定义了每一层的作用，这7层自上向下分别是<br>应用层：针对特定应用的协议，文件传输、电子邮件、远程登录等协议<br>表示层：设备固有数据格式和网络标准数据格式的转换<br>会话层：通信管理，负责建立和断开通信连接，以及数据的分割等数据传输相关的管理<br>传输层：管理两个节点之间的数据传输（端与端之间的数据交流）<br>网络层：地址管理与路由选择，路由器工作在网路层<br>数据链路层：负责物理层面互连节点之间的通信和识别数据帧，交换机工作在数据链路层<br>物理层：负责0、1比特流与电压高低、关的闪灭之间的互换、界定连接器和网线规格，集线器工作在物理层<br>对于一台主机，它的操作系统内核实现了从传输层到物理层的内容<br>对于一台路由器，它实现了从网络层到物理层<br>对于一台交换机，它实现了从数据链路层到物理层<br>对于集线器，它只实现了物理层<br>但是并不绝对，很多交换机也实现了网络层的转发，很多路由器也实现了部分传输层的内容（比如端口转发）<br>由于OSI7层模型复杂又不实用，所以我们通常用TCP/IP四层模型，将应用层、表示层、会话层统称应用层，由于物理层考虑比较少，所以TCP/IP四层模型包括：应用层、传输层、网络层、链路层</p><h1 id="电路交换与分组交换"><a class="markdownIt-Anchor" href="#电路交换与分组交换"></a> 电路交换与分组交换</h1><p>电路交换中，交换机主要负责数据的中转处理。计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接，因此计算机之间发送数据时，需要通过交换机与目标主机建立通信电路。由于一台计算机在收发信息时会独占整个电路，如果并发用户数超过交换机之间的通信线路数，就意味着通信无法实现。<br>为此，新的方法出现，让连接到通信电路的计算机将所要发送的数据分成多个数据包，在分组的首部写入发送端和接收端的地址，按照一定顺序排列后分别发送给路由器，路由器收到这个数据后缓存到自己的缓冲区队列中，然后转发给目标计算机，计算机与路由器，路由器与路由器之间通常只有一条共享线路，所以分组交换中通信速度和网络拥堵的情况有关，路由器的缓存饱和或溢出时，也可能发生分组数据丢失的情况</p><h1 id="mac地址"><a class="markdownIt-Anchor" href="#mac地址"></a> MAC地址</h1><p>MAC地址用来识别数据链路层中相连的节点，长度为48位，即6个字节，一般用16进制数字加上冒号的形式来表示，在网卡出厂时就确定了，不能修改，mac地址通常是唯一的，人们可以通过制造商识别号、制造商内部产品编号以及产品通用编号确保MAC地址的唯一性。（虚拟机中的mac地址不是真实的mac地址，可能会冲突，也有些网卡支持用户配置mac地址）虽然MAC地址中的制造商识别、产品编号、通用编号等信息在某种程度上有一定层次性，但是对于寻找地址并没有起到任何作用，所以不能算有层次的地址，虽然MAC地址是真正负责最终通信的地址，但是在实际寻址过程中，IP地址却必不可少</p><h1 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h1><p>MAC地址描述的是路途上的每一个区间的起点和终点。IP地址描述的是路途总体的起点和终点。<br>IP地址是IP协议中，用来标识网络中的唯一一台主机的地址。IP协议有两个版本IPv4，IPv6。IPv4中，IP地址是一个4字节的32位的整数(uint32_t)。IPv6中，IP地址是一个16字节的128位的整数(uint8_t ip[16])<br>两台主机通过网络来互相通信来发送数据时，就需要知道对方的IP地址，找到对方的主机，才能将数据发给它。所以在发送数据时，该数据包中还应包含两个IP地址，一个是目的IP，用于指明数据是发给谁的。一个是源IP，用于告诉对方该数据是哪台主机发送的，以便向其回发消息<br>当我们通过网络将数据发送给目的IP指定的主机时，目的主机要调用哪个进程对该数据进行处理，所以，此时还需要知道主机中处理数据的进程号。因此，需要引入端口号</p><h1 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h1><p>端口号是一个2字节16位的整数，用来标识一个主机中唯一的一个进程，IP地址 + 端口号能够标识网络上的某一台主机的某一个进程，当源主机通过网络将数据发送给目的主机后，调用该端口号指定的进程来对数据进行处理，在网络通信中，每条数据都包含一个五元组（源ip地址，源端口，目的ip地址，目的端口，协议类型）可以通过netstat -n查看<br>一个端口号只能绑定一个进程<br>一个进程可以绑定多个端口号，因为一个进程可以创建多个socket<br>0 - 1023: 知名端口号，HTTP，FTP，SSH等这些广为使用的应用层协议，他们的端口号都是固定的，命令cat /etc/services可查看<br>1024 - 65535: 操作系统动态分配的端口号，客户端程序的端口号，就是由操作系统从这个范围分配的</p><h1 id="网络字节序"><a class="markdownIt-Anchor" href="#网络字节序"></a> 网络字节序</h1><p>网络通信中源主机要通过内存将数据先发给源主机的网卡，然后发送到网络中，目的主机将网络中的数据项接收到目的主机的网卡上，再传入到目的主机的内存中，然后通过CPU对数据进行处理<br>发送主机将发送缓冲区的数据按低地址到高地址的顺序发出，接收主机从网络中也是按低地址到高地址的顺序将数据接收到接受缓冲区中<br>而数据在内存中的存储有大小端之分。如果在源主机的内存为小端，而目的主机以大端的形式来接受数据时，此时，就会导致数据错误<br>TCP/IP协议规定，网络数据流均采用大端，当发送消息时，先将数据放到发送缓冲区中，再将数据转换为大端字节序后发送，同理接收数据时，先将数据接收到接收缓冲区中，然后再将数据转换为主机字节序后读取</p><p>主机的存储模式和cpu的架构有关，我们常用的X86架构是小端模式<br>可以通过下面两种方法判断主机字节序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEnd1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (*(<span class="keyword">char</span>*)&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEnd2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">&#125;un;</span><br><span class="line">un.i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> un.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络字节序列与主机字节序列转换可以通过以下接口来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure><p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回<br>如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回</p><h1 id="传输流程"><a class="markdownIt-Anchor" href="#传输流程"></a> 传输流程</h1><p><img src="img1.png" alt="img1"></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段，在网络层叫做数据报，在链路层叫做帧，应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部，称为封装，首部信息中包含了一些类似于首部有多长，载荷有多长，上层协议是什么等信息，数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的上层协议字段将数据交给对应的上层协议处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协议分层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#协议分层&quot;&gt;&lt;/a&gt; 协议分层&lt;/h1&gt;&lt;p&gt;IOS提出OSI参考模型，帮助不同类型的主机实现数据传输，这一模型将通信协议中必要的功能分成了7层，这一模型中，每个分层都接收由它下一
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="网络基础" scheme="https://Ranjiahao.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>线程的同步与互斥</title>
    <link href="https://ranjiahao.github.io/2020/06/30/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
    <id>https://ranjiahao.github.io/2020/06/30/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-06-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的互斥"><a class="markdownIt-Anchor" href="#线程的互斥"></a> 线程的互斥</h1><p>由于一个进程中的多个线程共享同一个虚拟地址空间。除了一些私有数据，其余大部分资源都是共享的，为了保证线程安全一次只允许一个线程对其访问，这些数据就称为临界资源，包含临界资源的代码段称为临界区。我们可以通过一把锁实现：当线程进入临界区执行时，不允许其他线程进入该临界区。如果多个线程同时要求执行临界区的代码，并且临界区没有线程在执行，那么只能允许一个线程进入该临界区，Linux上提供的这把锁叫互斥量</p><h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2><h3 id="初始化销毁互斥量"><a class="markdownIt-Anchor" href="#初始化销毁互斥量"></a> 初始化/销毁互斥量</h3><blockquote><p>静态初始化<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code><br>动态初始化<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code><br>mutex: 输出型参数，要初始化的互斥量<br>attr: 互斥锁属性一般设置NULL<br>成功返回0，失败返回错误码<br>销毁<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code><br>静态初始化的互斥量不需要销毁；不要销毁一个已经加锁的互斥量；已经销毁的互斥量，要确保后面不会有线程再尝试加锁</p></blockquote><h3 id="互斥量加锁和解锁"><a class="markdownIt-Anchor" href="#互斥量加锁和解锁"></a> 互斥量加锁和解锁</h3><blockquote><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>trylock非阻塞加锁<br><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code><br>成功返回0，失败返回错误码</p></blockquote><h3 id="互斥锁原理"><a class="markdownIt-Anchor" href="#互斥锁原理"></a> 互斥锁原理</h3><p>互斥锁本质是一个计数器，由于i<ins>或者</ins>i都不是原子操作，要保证互斥锁的操作为原子操作，大多数体系结构都提供了swap或exchange指令，该指令的作用是把寄存器和内存单元的数据相交换，只有一条指令，首先将0放入寄存器中，然后执行执行swap和内存单元的数据交换，然后判断这个数据是否为1，若为1，则此操作就是加锁操作。加锁后访问临界资源，此时寄存器中的数据为1，访问完成后，再次将数据交换回来，此时内存单元的数据就变为1，这一步叫解锁操作，加锁和解锁都是一步完成的，保证了原子性</p><h1 id="线程的同步"><a class="markdownIt-Anchor" href="#线程的同步"></a> 线程的同步</h1><p>使用互斥锁可以解决线程安全的问题，保证多线程下临界资源数据的安全性，但是仅仅互斥还是会存在一些问题，某个线程获取锁之后，发现数据没有就绪，又立刻释放锁，如果这个线程的优先级很高，那么就可能在释放了锁之后又立刻尝试获取锁，再立刻释放，依次类推，这样虽然并没有发生死锁，但是这个线程空转又占用了锁资源，导致其他线程很难获取到这个锁<br>linux可以通过条件变量和信号量两种方法来实现线程的同步</p><h2 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h2><p>当一个线程互斥的访问某个变量时，若不满足某一条件，则挂起等待，知道条件满足被唤醒</p><h3 id="初始化销毁条件变量"><a class="markdownIt-Anchor" href="#初始化销毁条件变量"></a> 初始化/销毁条件变量</h3><blockquote><p>静态初始化<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER</code><br>动态初始化<code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</code><br>cond: 输出型参数，要初始化的条件变量<br>attr: 条件变量属性一般设置NULL<br>销毁<code>int pthread_cond_destroy(pthread_cond_t *cond)</code><br>成功返回0，失败返回错误码</p></blockquote><h3 id="等待唤醒条件变量"><a class="markdownIt-Anchor" href="#等待唤醒条件变量"></a> 等待/唤醒条件变量</h3><blockquote><p>等待<code>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</code>timedwait限时的阻塞等待<br>唤醒所有等待进程<code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br>唤醒至少一个线程<code>int pthread_cond_signal(pthread_cond_t *cond);</code><br>成功返回0，失败返回错误码</p></blockquote><p>条件变量是为了解决某些情况下互斥锁低效的问题，因此对条件变量的操作，必然要和互斥锁密切相关，pthread_cond_wait的实现分为三个操作：</p><ol><li>pthread_mutex_unlock(&amp;mutex);</li><li>pthread_cond_wait(&amp;cond);</li><li>pthread_mutex_lock(&amp;mutex);<br>若前两个操作中间可以被打断，那么就有可能出现，A线程加锁后断判资源不足，执行完第一步解锁，然后还没来得及执行第二步等待，另一个线程B就抢到锁后加锁补充资源，解锁发送信号，进入等待状态。此时由于A还没执行第二部进入等待状态所以无法收到信号，所以A执行第二步等待的时候B也在等待，这样就造成了死锁。<br>所以pthread_cond_wait设置了两个参数来保证前两步的原子操作</li></ol><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示</h3><p>使用COUNT个执行流打开开关，另外再使用COUNT个执行流关闭开关，开关不能连续打开或者关闭两次。为了防止唤醒同一个等待队列中的角色，所以多个角色要使用多个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 不同角色在不同条件变量队列上等待，防止误唤醒阻塞</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> switch_on;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> switch_off;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_on</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 循环判断防止当前不符合条件被唤醒后直接操作临界资源</span></span><br><span class="line">        <span class="keyword">while</span> (status == <span class="number">1</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;switch_on, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Turn on the switch\n"</span>);</span><br><span class="line">        <span class="comment">// 先解锁可以减少锁冲突的概率，提高性能</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;switch_off);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_off</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;switch_off, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Turn off the switch\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;switch_on);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid_on[COUNT], tid_off[COUNT];</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;switch_on, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;switch_off, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid_on[i], <span class="literal">NULL</span>, thread_on, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread_on error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid_off[i], <span class="literal">NULL</span>, thread_off, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create thread_off error\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        pthread_join(tid_on[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(tid_off[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;switch_on);</span><br><span class="line">    pthread_cond_destroy(&amp;switch_off);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="posix信号量"><a class="markdownIt-Anchor" href="#posix信号量"></a> POSIX信号量</h1><p>POSIX信号量和SystemV信号量作用相同，SystemV为内核中的计数器主要用于进程间，POSIX进程/线程间都可以，信号量本质就是一个计数器和一个pcb等待队列，可通过自身的计数器对资源计数并判断资源是否符合访问条件，符合则可以访问，不符合则阻塞等待，其他进程/线程促使条件满足后，可以唤醒pcb等待队列上的pcb，从而实现同步；也可通过使资源计数器不大于1，保证同一时间只有一个进程/线程可以访问临界资源实现互斥</p><h2 id="初始化销毁信号量"><a class="markdownIt-Anchor" href="#初始化销毁信号量"></a> 初始化/销毁信号量</h2><blockquote><p><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code><br><code>int sem_destroy(sem_t *sem);</code><br>sem: 信号量变量<br>pshared: 0表示线程间共享，非零表示进程间共享，如果用于线程间这个计数器是一个全局变量，如果用于进程间则在申请的共享内存中实现pcb等待队列和计数器<br>value: 信号量初始值<br>成功返回0，失败返回-1，并设置错误码</p></blockquote><h2 id="等待发布信号量"><a class="markdownIt-Anchor" href="#等待发布信号量"></a> 等待/发布信号量</h2><blockquote><p><code>int sem_wait(sem_t *sem);</code> 等待信号量，会将信号量的值减1 trywait非阻塞等待 timedwait限时阻塞<br><code>int sem_post(sem_t *sem);</code> 发布信号量，将信号量的值加1，并唤醒等待进程/线程<br>成功返回0，失败返回-1，并设置错误码</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的互斥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程的互斥&quot;&gt;&lt;/a&gt; 线程的互斥&lt;/h1&gt;&lt;p&gt;由于一个进程中的多个线程共享同一个虚拟地址空间。除了一些私有数据，其余大部分资源都是共享的，为了保证线程安全一次只允许一个线程对
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的创建、终止、等待、分离</title>
    <link href="https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/"/>
    <id>https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-06-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线程都是轻量级进程，内核并不知道用户级线程的存在，该用户级线程的实现是通过用户级线程库POSIX来完成的，链接这些线程函数库时要加上&quot;-lpthread&quot;选项，指定要链接的库名</p><h1 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h1><blockquote><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code><br>thread: 输出型参数返回线程ID（用户态线程ID）<br>attr: 设置线程的属性，attr为NULL表示使用默认属性<br>start_routine: 是个函数地址，线程启动后要执行的函数<br>arg: 传给线程启动函数的参数<br>成功返回0；失败返回错误码<br>传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。pthreads函数出错时不会设置全局变量errno（大部分其他POSIX函数会这样做）而是将错误码通过返回值返回pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，读取返回值要比读取线程内的errno变量的开销小</p></blockquote><p>pthread_t实际是一个unsigned long类型，其本质就是一个进程地址空间上的一个地址，NPTL提供<code>pthread_t pthread_self(void);</code>函数来查看<br>创建一个线程就是创建一个pcb，但是线程中还有一些独有的数据，加载动态库就是在进程地址空间中的共享区，而我们用的NPTL函数本身就是动态库函数，所以线程独有的信息都在共享区，操作系统在共享区开辟了一块空间来存放每个线程独有的数据（栈、线程局部存储信息、线程在用户态的描述）而pthread_t就指向这个空间的地址，也可以使用命令pstack [进程id(线程组id)]查看<br>我们平常使用ps -L 查看到的pid就是线程组id，而LWP就是调度实体的线程id（内核级线程id）也叫轻量级进程id，Linux提供了gettid系统调用来返回其线程id（内核级线程id），可是glibc并没有将该系统调用封装起来，在开放接口来共程序员使用。如果确实需要获得线程ID，可以采用如下方法：<code>#include &lt;sys/syscall.h&gt; pid_t tid; tid = syscall(SYS_gettid);</code></p><h1 id="线程终止"><a class="markdownIt-Anchor" href="#线程终止"></a> 线程终止</h1><ol><li><p>从线程 return，如果是从主线程return，相当于exit，所有线程都结束</p></li><li><p>线程自己调用pthread_exit来终止自己</p></li></ol><blockquote><p><code>void pthread_exit(void *value_ptr);</code><br>value_ptr: 输出型参数，该线程退出时的退出码，注意不要指向一个局部变量，因为当线程的调用函数退出时，局部变量也就销毁了</p></blockquote><ol start="3"><li>一个线程可以调用pthread_cancel终止同一进程中的另一进程</li></ol><blockquote><p><code>int pthread_cancel(pthread_t thread);</code><br>参数传pthread_self()时终止自己，成功返回0，失败返回错误码</p></blockquote><h1 id="进程等待"><a class="markdownIt-Anchor" href="#进程等待"></a> 进程等待</h1><p>当一个线程退出时，如果空间没有被释放，新创建的线程也不会利用退出线程的资源，会发生内存泄漏，因此新线程在退出时主线程要通过等待的方式回收退出线程的资源并获取新线程退出时的状态</p><blockquote><p><code>int pthread_join(pthread_t thread, void **value_ptr);</code><br>value_ptr: 由于线程终止时返回一个指针，这个指针一般指向全局变量或者malloc分配的空间，所以进程等待接收参数的时候需要传入一个一级指针的地址来接收参数，成功返回0；失败返回错误码</p></blockquote><p>注意：该函数是以阻塞的方式进行等待的，thread线程以不同的方式终止，得到的线程终止状态也是不同的：</p><ul><li>线程以return的方式终止，value_ptr指向的空间中保存return返回的值</li><li>线程以pthread_exit的方式终止，value_ptr指向的空间中保存传给pthread_exit的参数</li><li>线程被别的线程调用pthread_cancel的方式终止，value_ptr指向的空间中保存常数PTHREAD_CANCELED，<code>#define PTHREAD_CANCELED (void\*)-1;</code></li><li>如果不关心新线程的退出状态，直接将value_ptr设置为NULL即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry1</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry2</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry3</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread3\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread3 is running~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2, t3;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, ThreadEntry1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, ThreadEntry2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t3, <span class="literal">NULL</span>, ThreadEntry3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret;</span><br><span class="line">    pthread_join(t1, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_join(t2, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_cancel(t3);</span><br><span class="line">    pthread_join(t3, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == PTHREAD_CANCELED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread3 return, return code PTHREAD_CANCELED\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"></p><p>我们说父子进程的执行顺序不一定，但是我们却很难看到子进程先于父进程执行，这里却很容易可以看到线程执行顺序不一定，这是因为每次创建一个进程的代价比较大，所以父进程就有很大的概率去执行，而线程的创建代价比较小，所以很容易看到执行顺序不一定这个结果，但是线程等待是串行的</p><h1 id="线程分离"><a class="markdownIt-Anchor" href="#线程分离"></a> 线程分离</h1><p>在默认情况下创建的线程是joinable的，线程退出后，要对其进行pthread_join操作，否则无法回收资源，造成内存泄漏，如果不关心线程的返回值，那么join就是一个负担，这个时候我们可以告诉操作系统线程退出时，由操作系统自动回收资源</p><blockquote><p><code>int pthread_detach(pthread_t thread);</code><br>也可以是线程自己分离：pthread_detach(pthread_self());一个分离的线程异常退出，整个进程也会异常退出，joinable和detached是两个对立的状态，两者不可能同时存在</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-15T16:00:00.000Z</published>
    <updated>2020-06-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1><p>进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过pcb实现的，所以linux下线程就是一个pcb，一个进程中的线程公用同一个虚拟地址空间，相较与传统pcb更加轻量化，也被称为轻量级进程。操作系统资源分配是直接分配给整个线程组，这个线程组就是进程，所以进程是资源分配的基本单位，而线程是进程实际运作的基本单位，cpu通过调度pcb来实现程序的调度，所以线程是调度的基本单位，ps -L中LWP为轻量级进程id，pid为这个线程组id<br>一个进程中的线程共享：</p><ol><li>同一虚拟地址空间：本质共享同一页表</li><li>文件描述符表：一个线程修改了一个文件，其他的线程访问到的文件也都改变</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL或者自定义的信号处理函数)</li><li>未决信号集：只要进程收到了信号，也就意味着所有线程收到了信号</li><li>当前工作目录、用户id和组id</li></ol><p>由于进程中的各个线程共用同一个虚拟地址空间，为了保证程序的合理性所以各个线程有自己的信息：</p><ol><li>线程ID</li><li>栈：防止调用栈混乱</li><li>一组寄存器：线程的上下文信息</li><li>errno：防止线程的errno被另一个线程覆盖</li><li>信号屏蔽字：防止线程在执行重要操作时被打断</li><li>调度优先级：各线程要被调度，就必须有优先级</li></ol><h1 id="线程的优缺点"><a class="markdownIt-Anchor" href="#线程的优缺点"></a> 线程的优/缺点</h1><p>优点：</p><ul><li>线程的创建与销毁成本更低，创建一个进程，我们需要给他分配虚拟地址空间，这个空间占用了一部分资源。创建一个线程，不需要分配虚拟地址空间，节约资源，增快了效率，销毁也比较快</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多，不需要切换页表，只用切换一小部分数据，效率较高</li><li>由于线程组中线程公用同一虚拟地址空间，所以相比进程线程间通信比较方便，只需知道地址就能访问同一空间</li><li>能充分利用多处理器的可并行数量，比如4核CPU，需要不停歇的进行CPU的运算操作，用四个线程运算操作，CPU占用率可达到400%（Linux下）充分利用了硬件资源，处理CPU密集型程序通常执行流个数为CPU核心数+1，若创建线程很多而CPU资源不够多，则大量进程切换调度成本会提高</li><li>I/O密集型应用，为了提高性能，将I/O操作重叠，多任务并行处理，多磁盘可以实现同时处理，线程可以同时等待不同的I/O操作</li></ul><p>缺点：</p><ul><li>缺乏保护访问控制、健壮性降低，需要考虑线程安全问题，异常以及系统调用exit会直接针对整个进程</li><li>性能损失，若CPU密集型程序线程的数量比可用的处理器多则增加了额外的同步和调度开销</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程与线程&quot;&gt;&lt;/a&gt; 进程与线程&lt;/h1&gt;&lt;p&gt;进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>智能指针模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源</p><h1 id="auot_ptr"><a class="markdownIt-Anchor" href="#auot_ptr"></a> auot_ptr</h1><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~AutoPtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt;&amp; ap)</span><br><span class="line">        : _ptr(ap._ptr) &#123;</span><br><span class="line">        <span class="comment">// 转移资源管理权</span></span><br><span class="line">        ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt;&amp; ap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="comment">// 转移资源管理权</span></span><br><span class="line">            _ptr = ap._ptr;</span><br><span class="line">            ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 像指针一样的操作</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bug：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AutoPtr&lt;T&gt; ap(<span class="keyword">new</span> T);</span><br><span class="line">AutoPtr&lt;T&gt; copy(ap);<span class="comment">// 拷贝后把ap对象的指针赋空了，通过ap对象访问资源时就会出bug（除非每次判断ap._ptr是否不为空）</span></span><br></pre></td></tr></table></figure><p>所以auto_ptr根本用不了</p><h1 id="c11-unique_ptr"><a class="markdownIt-Anchor" href="#c11-unique_ptr"></a> C++11 unique_ptr</h1><p>也叫scoped_ptr(boost库)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UniquePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UniquePtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~UniquePtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr并没有去实现类似scoped_array的unique_array，因为标准库中有vector</span></span><br><span class="line">    <span class="comment">// T&amp; operator[](size_t index) &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="comment">// const T&amp; operator[](size_t index) const &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    UniquePtr(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UniquePtr &amp; <span class="keyword">operator</span>=(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比auto_ptr，简单粗暴的防拷贝，勉强可以使用，但没有从根本解决问题</p><h1 id="c11-shared_ptr"><a class="markdownIt-Anchor" href="#c11-shared_ptr"></a> C++11 shared_ptr</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SharedPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr)</span><br><span class="line">        , _pRefCount(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">        , _pMutex(<span class="keyword">new</span> mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~SharedPtr() &#123; Release(); &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">        : _ptr(sp._ptr)</span><br><span class="line">        , _pRefCount(sp._pRefCount)</span><br><span class="line">        , _pMutex(sp._pMutex) &#123;</span><br><span class="line">        AddRefCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            Release();</span><br><span class="line">            <span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pRefCount = sp._pRefCount;</span><br><span class="line">            _pMutex = sp._pMutex;</span><br><span class="line">            AddRefCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁或者使用加1的原子操作</span></span><br><span class="line">        _pMutex-&gt;lock();</span><br><span class="line">        ++(*_pRefCount);</span><br><span class="line">        _pMutex-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* _pRefCount; <span class="comment">// 引用计数</span></span><br><span class="line">    T* _ptr;         <span class="comment">// 指向管理资源的指针</span></span><br><span class="line">    mutex* _pMutex;  <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="仿函数删除器"><a class="markdownIt-Anchor" href="#仿函数删除器"></a> 仿函数删除器</h1><p>上面代码析构函数是用delete来释放资源的，但是我们可能用以下几种方式申请资源：<br><code>SharedPtr&lt;int&gt; p(new int);</code><br><code>SharedPtr&lt;FILE&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int&gt; mp = ((int*)malloc(sizeof(int)));</code><br>这时候使用delete来释放，可能会出错，这时候就需要自定义删除方式，我们只需对上面代码稍加修改即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义我们自己的删除方式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Delete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Free</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Close</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fclose(p);</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span> = <span class="title">Delete</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他都不变，修改析构函数即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            D()(_ptr); <span class="comment">// 创建匿名对象，并调()重载</span></span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：<br><code>SharedPtr&lt;int&gt; np(new int);</code><br><code>SharedPtr&lt;FILE, Close&lt;FILE&gt;&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int, Free&lt;int&gt;&gt; mp((int*)malloc(sizeof(int)));</code></p><h2 id="shared_ptr的循环引用"><a class="markdownIt-Anchor" href="#shared_ptr的循环引用"></a> shared_ptr的循环引用</h2><p>shared_ptr并非完美，也有小缺陷</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _prev;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node1(<span class="keyword">new</span> ListNode);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node2(<span class="keyword">new</span> ListNode);</span><br><span class="line">    node1-&gt;_next = node2;</span><br><span class="line">    node2-&gt;_prev = node1;</span><br><span class="line">&#125; <span class="comment">// 这里会导致内存泄漏</span></span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"><br>出作用域后node1和node2对象被释放<br><img src="img2.png" alt="img2"><br>但是引用计数不为0，_date不会被释放，造成内存泄漏</p><p>当然,C++11库中也给出了响应的解决方法,就是weak_ptr</p><h2 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h2><p>weak_ptr要和shared_ptr搭配使用，在进行如上的赋值时，并不进行引用计数的加加操作，这也保证了在释放的时候不会因为引用计数不为0而没有正确释放，造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="c11-守卫锁"><a class="markdownIt-Anchor" href="#c11-守卫锁"></a> C++11 守卫锁</h1><p>lock_guard利用RAII思想，通过对象的生命周期控制锁的生命周期构造加锁，析构解锁，防止死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Mutex</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LockGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LockGuard(Mutex&amp; mtx)</span><br><span class="line">        :_mutex(mtx) &#123;</span><br><span class="line">        _mutex.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    ~LockGuard() &#123;</span><br><span class="line">        _mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    LockGuard(<span class="keyword">const</span> LockGuard&lt;Mutex&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 必须使用引用，保证同一个互斥量对象</span></span><br><span class="line">    Mutex&amp; _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="comment">// 进入作用域构造lg对象，加锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        LockGuard&lt;mutex&gt; lg(mtx);</span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出了作用域析构lg对象，解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源&lt;/p&gt;&lt;h1 id=&quot;auot_ptr&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#auot_ptr&quot;&gt;&lt;/a&gt; auot_ptr&lt;/h1&gt;&lt;p&gt;模拟实现：&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://Ranjiahao.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>多态及其原理</title>
    <link href="https://ranjiahao.github.io/2020/06/08/%E5%A4%9A%E6%80%81%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://ranjiahao.github.io/2020/06/08/%E5%A4%9A%E6%80%81%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态的构成条件"><a class="markdownIt-Anchor" href="#多态的构成条件"></a> 多态的构成条件</h1><ol><li>必须通过父类的指针或者引用调用虚函数</li><li>被调用的函数必须是虚函数，且子类必须对父类的虚函数进行重写</li><li>inline、静态成员、构造函数不可为虚函数</li></ol><h1 id="虚函数的重写"><a class="markdownIt-Anchor" href="#虚函数的重写"></a> 虚函数的重写</h1><p>子类中有一个跟父类完全相同的虚函数(返回值类型、函数名字、参数列表完全相同)称子类的虚函数重写了基类的虚函数。（虚函数同样存在于代码段）</p><p>重写父类虚函数时，子类虚函数不加virtual关键字时，也可以构成重写（继承后父类虚函数被继承下来了在子类依旧保持虚函数属性）但不建议这样使用</p><p><strong>两个例外</strong></p><ol><li>协变（父类与子类虚函数返回值类型不同)<br>父类虚函数返回有继承关系的父类对象的指针或者引用，子类虚函数返回有继承关系子类对象的指针或者引用时，称为协变</li><li>析构函数的重写(子类与父类析构函数的名字不同)<br>若父类的析构函数为虚函数，则子类析构函数只要定义，无论是否加virtual，都与父类析构函数构成重写，编译后析构函数的名称统一处理成destructor</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">    Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// Person()</span></span><br><span class="line">    <span class="keyword">delete</span> p2; <span class="comment">// Student() ~Person()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c11-override和final"><a class="markdownIt-Anchor" href="#c11-override和final"></a> C++11 override和final</h1><p>函数名字写错无法构成重载，类似这种错误在编译期间是不会报出的，所以C++11提供了override和final两个关键字，可以帮助用户检测是否重写</p><p>父类中final:修饰虚函数，表示该虚函数不能再被继承<br><code>virtual void Fuc() final {}</code><br>子类中override:检查子类虚函数是否重写了父类某个虚函数，如果没有编译会报错<br><code>virtual void Fuc() override {}</code></p><h1 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h1><p>虚函数后面加上 =0，则此函数为纯虚函数。包含纯虚函数的类为抽象类，不能实例化出对象。只有子类继承后重写纯虚函数，才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承</p><h1 id="多态的原理"><a class="markdownIt-Anchor" href="#多态的原理"></a> 多态的原理</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fuc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span>:</span> <span class="keyword">public</span> AAA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(AAA* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;Fuc3();</span><br><span class="line">    a-&gt;Fuc2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AAA a;</span><br><span class="line">    BBB b;</span><br><span class="line">    Test(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VS下调试我们发现：<br>父类a对象中除了_a成员，还多一个_vfptr的void**类型指针在对象前面（前后跟平台有关）这个指针我们叫做虚函数表指针，一个含有虚函数的类中至少有一个虚函数表指针，虚函数的地址要被放到虚函数表中</p><p>子类b对象中除了_b成员，也多一个_vfptr指针（两个指针不同）<br><img src="img1.png" alt="img1"></p><h1 id="虚函数表"><a class="markdownIt-Anchor" href="#虚函数表"></a> 虚函数表</h1><p>本质是一个存虚函数指针的指针数组（存在于代码段、编译阶段生成），此数组最后面放了一个nullptr</p><p>只有虚函数指针才会放在这个表中（为了实现多态）</p><p>Func3完成了重写，所以b的虚表中存的是覆盖的BBB::Func3（重写是语法层的叫法，覆盖是原理层的叫法）</p><p>子类将父类中的虚表内容拷贝一份到子类虚表中，如果子类重写了基类中某个虚函数，就用子类自己的虚函数指针覆盖虚表中父类的虚函数指针，子类自己新增加的虚函数按其在子类中的声明次序增加到子类虚表的最后</p><h2 id="多继承中的虚函数表"><a class="markdownIt-Anchor" href="#多继承中的虚函数表"></a> 多继承中的虚函数表</h2><p>虚表个数： 直接父类的个数<br>子类新增的虚函数：存放在第一个直接父类的虚表末尾(按声明顺序存放）<br>如：</p><p>Base1: 函数func1(virtual),func2(virtual) 数据b1</p><p>Base2: 函数func1(virtual),func2(virtual) 数据b2</p><p>Derive: 函数func1(virtual),func3(virtual) 数据d1----&gt;内存模型：<br><img src="img2.png" alt="img2"></p><h2 id="为什么达到多态必须父类对象的指针或引用调用虚函数"><a class="markdownIt-Anchor" href="#为什么达到多态必须父类对象的指针或引用调用虚函数"></a> 为什么达到多态必须父类对象的指针或引用调用虚函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    a-&gt;Fuc3();</span><br><span class="line">&#x2F;&#x2F; a中存的是b对象的指针，将a移动到eax中</span><br><span class="line">00CF2138  mov         eax,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; [eax]是取eax值指向的内容，b对象头4个字节（虚表指针）移动到了edx</span><br><span class="line">00CF213B  mov         edx,dword ptr [eax]  </span><br><span class="line">00CF213D  mov         esi,esp  </span><br><span class="line">00CF213F  mov         ecx,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; 由于虚标指针数组第二个是Fuc3函数，通过edx+4找到函数指针，放到eax</span><br><span class="line">00CF2142  mov         eax,dword ptr [edx+4]  </span><br><span class="line">&#x2F;&#x2F; call eax中的函数指针，运行时在对象中找函数地址</span><br><span class="line">00CF2145  call        eax  </span><br><span class="line">00CF2147  cmp         esi,esp  </span><br><span class="line">00CF2149  call        __RTC_CheckEsp (0CF12EEh)  </span><br><span class="line">    a-&gt;Fuc2();</span><br><span class="line">00CF214E  mov         ecx,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; 由于Fuc2不是虚函数，编译时已经从符号表确定了函数地址</span><br><span class="line">00CF2151  call        AAA::Fuc2 (0CF1546h)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BBB b;</span><br><span class="line">    b.Fuc3(); <span class="comment">// 虽然Fuc3是虚函数但是由对象直接调用，不满足多态直接call地址</span></span><br><span class="line">    <span class="comment">// 001D2A4A  lea         ecx,[b]  </span></span><br><span class="line"><span class="comment">// 001D2A4D  call        BBB::Fuc3 (01D1541h)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印虚函数表"><a class="markdownIt-Anchor" href="#打印虚函数表"></a> 打印虚函数表</h2><p>VS监视窗口中看不见Func3和Func4，只能自定义打印虚表函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span>:</span> <span class="keyword">public</span> AAA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc4</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc4()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVTable</span><span class="params">(<span class="keyword">void</span>(**vTable)())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"虚表地址："</span> &lt;&lt; vTable &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vTable[i] != <span class="literal">nullptr</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 可能死循环，因为编译器有时在虚表最后面没有放nullptr，生成-&gt;清理解决方案，编译即可</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 第"</span> &lt;&lt; i &lt;&lt; <span class="string">"个虚函数地址为：0x"</span> &lt;&lt; vTable[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        vTable[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BBB b;</span><br><span class="line">    <span class="comment">// VS下对象模型前四个字节是虚标指针，所以强转成int*在解引用去除前四个字节</span></span><br><span class="line">    <span class="comment">// 再强转成void(**)()类型的函数指针</span></span><br><span class="line">    <span class="keyword">void</span>(**vTableb)() = (<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)&amp;b);</span><br><span class="line">    PrintVTable(vTableb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多继承子类虚函数表访问方法"><a class="markdownIt-Anchor" href="#多继承子类虚函数表访问方法"></a> 多继承子类虚函数表访问方法</h2><p>如：<br>Base1: 函数func1,func2(virtual) 数据b1</p><p>Base2: 函数func1,func2(virtual) 数据b2</p><p>Derive: 函数func1,func3(virtual) 数据d1</p><p><strong>访问Derive中Base2的虚表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">// 取出d的地址，强转成 char* 加上Base1大小个字节</span></span><br><span class="line"><span class="comment">// 强转成 int* 再解引用取出前四个字节，其内容就是虚表指针</span></span><br><span class="line">PrintVTable((<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;d + <span class="keyword">sizeof</span>(Base1))));</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">// 利用切片操作</span></span><br><span class="line">Base2* pd = &amp;d;</span><br><span class="line">PrintVTable((<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)pd));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态的构成条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多态的构成条件&quot;&gt;&lt;/a&gt; 多态的构成条件&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;必须通过父类的指针或者引用调用虚函数&lt;/li&gt;&lt;li&gt;被调用的函数必须是虚函数，且子类必须对父类的虚函数进
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="多态" scheme="https://Ranjiahao.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数" scheme="https://Ranjiahao.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>继承总结</title>
    <link href="https://ranjiahao.github.io/2020/06/07/%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/"/>
    <id>https://ranjiahao.github.io/2020/06/07/%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-06-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>继承机制是代码复用重要的手段，允许在保持原有类特性的基础上进行扩展，产生子类</p><h1 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h1><p>public继承：继承父类中的public和protected成员，访问限定符不变</p><p>private继承：继承父类中的public和protected成员，访问限定符变为private</p><p>protected继承：继承父类中的public和protected成员，访问限定符变为protected</p><p><strong>基类的private成员，也被继承在派生类中，但不可访问</strong><br>class默认继承方式是private，struct默认继承方式是public</p><h1 id="基类和派生类对象赋值转换"><a class="markdownIt-Anchor" href="#基类和派生类对象赋值转换"></a> 基类和派生类对象赋值转换</h1><ul><li>子类对象/地址可以直接赋值给父类的对象/引用/指针，会进行切片操作</li><li>父对象不能赋值给子类对象，但父类指针可以通过强制类型转换赋值给子类指针，但是可能出现越界</li></ul><h1 id="继承中的作用域"><a class="markdownIt-Anchor" href="#继承中的作用域"></a> 继承中的作用域</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">int</span> _no = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _no = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    <span class="comment">// 父类和子类都有独立的作用域</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.Student::_no &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.Person::_no &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 子类成员会屏蔽父类对同名成员的直接访问</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s._no &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="派生类的默认成员函数"><a class="markdownIt-Anchor" href="#派生类的默认成员函数"></a> 派生类的默认成员函数</h1><ul><li><p>构造函数：</p><p>子类构造函数先自动调用父类构造函数初始化父类部分的成员</p><p>如果父类没有默认构造函数，则必须在子类构造函数的初始化列表阶段显示调用</p></li><li><p>拷贝构造函数：</p><p>默认拷贝构造会自动调用父类的拷贝构造</p><p>显式定义子类的拷贝构造，编译器默认调用的父类构造函数</p><p>显式调用父类拷贝构造，会进行切片操作</p></li><li><p>operator=：</p><p>默认生成的赋值运算符会自动调用父类的赋值运算符</p><p>显式定义子类的赋值运算符， 编译器不会自动调用父类的赋值运算符</p></li><li><p>析构函数：</p><p>父类与子类析构构成同名隐藏：编译器底层修改的析构函数的名字，为了支持多态</p><p>子类析构函数会在被调用完成后自动调用父类的析构函数清理基类成员。保证子类对象先清理子类成员再清理父类成员的顺序</p><p>父类析构在任何情况下编译器都会自动调用，不需要显式调用</p></li></ul><h1 id="c11-final"><a class="markdownIt-Anchor" href="#c11-final"></a> C++11 final</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个不可继承的类</span></span><br><span class="line"><span class="comment">// C++98中构造函数私有化，子类中调不到父类的构造函数。无法继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NonInherit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NonInherit() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11中final禁止继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> <span class="title">final</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承与友元-静态"><a class="markdownIt-Anchor" href="#继承与友元-静态"></a> 继承与友元、静态</h1><p>友元关系不能继承，子类友元不能访问子类私有和保护成员</p><p>父类定义static静态成员，则整个继承体系里面只有一个这样的成员</p><h1 id="虚拟继承"><a class="markdownIt-Anchor" href="#虚拟继承"></a> 虚拟继承</h1><p>菱形继承有数据冗余和二义性的问题，所以虚拟继承可以解决数据冗余和二义性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class="line">    D x;</span><br><span class="line">    x._a = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class="line">    x.B::_a = <span class="number">3</span>;</span><br><span class="line">    x.B::_a = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class B: public A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class C: public A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通菱形继承模型</p><p><img src="img1.png" alt="img1"></p><p>虚拟菱形继承模型</p><p><img src="img2.png" alt="img2"></p><h1 id="继承与组合"><a class="markdownIt-Anchor" href="#继承与组合"></a> 继承与组合</h1><ul><li>继承是一种is-a的关系。每个子类对象都是一个父类对象。</li><li>组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。</li></ul><p>继承生成子类的复用被称为白箱复用：在继承方式中，父类的内部细节对子类可见 ，一定程度破坏了父类封装，基类的改变，对子类影响大。子类和父类依赖关系强，耦合度高</p><p>对象组合是另一种复用选择，要求被组合的对象具有良好定义的接口。被称为黑箱复用：对象的内部细节不可见。组合类之间没有很强的依赖关系，耦合度低。</p><p><mark>优先使用对象组合，而不是类继承。</mark></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继承机制是代码复用重要的手段，允许在保持原有类特性的基础上进行扩展，产生子类&lt;/p&gt;&lt;h1 id=&quot;继承方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承方式&quot;&gt;&lt;/a&gt; 继承方式&lt;/h1&gt;&lt;p&gt;public继承：继承父类中的public和
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="继承" scheme="https://Ranjiahao.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>僵尸进程与孤儿进程详解</title>
    <link href="https://ranjiahao.github.io/2020/06/06/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2020/06/06/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h1><p>linux中，正常情况下，子进程和父进程是一个异步过程，父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait系列系统调用取得子进程的终止状态。如果子进程退出，而父进程并没有调用wait获取子进程的状态信息，那么子进程的task_struct结构及少数资源仍然保存在系统中，这个子进程称为僵死进程。之所以保留task_struct，是因为task_struct里面保存了进程的pid、退出码、以及一些统计信息，父进程很可能会关心这些信息。比如$?变量就保存了最近一个退出的前台进程的退出码，这个退出码就来自于僵尸进程的task_struct结构</p><h2 id="观察一个僵尸进程"><a class="markdownIt-Anchor" href="#观察一个僵尸进程"></a> 观察一个僵尸进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* zombie.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">     <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         perror(<span class="string">"fork error"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"parent id:%d\n"</span>, getpid());</span><br><span class="line">         sleep(<span class="number">10</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"child id:%d\n"</span>, getpid());                                                                                       </span><br><span class="line">         sleep(<span class="number">3</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="gif1.gif" alt="gif1"></p><p>打开两个终端一个终端运行程序，另一个终端执行命令<br><code>while :; do clear; ps -aux |grep zombie; sleep 0.5; done</code></p><p>运行后可以看到3秒内子进程和父进程均进入S睡眠状态，三秒后子进程执行exit，这时子进程状态变为Z，再过7秒后，两个进程都退出</p><h2 id="僵尸进程的危害"><a class="markdownIt-Anchor" href="#僵尸进程的危害"></a> 僵尸进程的危害</h2><p>进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（pid、退出状态、运行时间等）直到父进程wait时才释放。如果父进程不调用wait的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的（ulimit -a查看）可能导致系统不能创建新的进程</p><h1 id="孤儿进程"><a class="markdownIt-Anchor" href="#孤儿进程"></a> 孤儿进程</h1><p>正如上文所说，子进程和父进程是一个异步过程，如果父进程退出，子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（1号）所收养，并由init进程对它们完成状态收集工作。这样的子进程叫孤儿进程。每当有一个孤儿进程，内核就把其父进程设置为init，init进程会循环等待它的已经退出的子进程</p><h2 id="观察一个孤儿进程"><a class="markdownIt-Anchor" href="#观察一个孤儿进程"></a> 观察一个孤儿进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* orphan.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent id:%d\n"</span>, getpid());</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child id:%d\n"</span>, getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="gif2.gif" alt="gif2"></p><p>打开两个终端一个终端运行程序，另一个终端执行命令<br><code>while :; do clear; ps aux |grep orphan; sleep 0.5; done</code></p><p>运行后可以看到3秒内子进程和父进程均正常，三秒后父进程执行exit，这时子进程的ppid变为1，再过7秒后，这个进程退出</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>事实上，任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个僵尸进程的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理，所以这么说来孤儿进程并不会有什么危害</p><h1 id="如何解决避免僵尸进程"><a class="markdownIt-Anchor" href="#如何解决避免僵尸进程"></a> 如何解决/避免僵尸进程</h1><p><strong>解决方法</strong>：<br>杀死父进程，僵尸进程会变成僵尸孤儿进程，1号进程会扫描其子进程，把Z状态进程回收。<br>直接发信号（-9等信号）去处理僵尸进程是无效的，因为僵尸进程已经退出了，只保留了task_struct结构体及少数资源</p><p><strong>避免方法</strong>：</p><ol><li>先执行一次fork在创建的子进程中再次fork，然后将第一次fork的进程退出，第二个子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程管理，防止僵尸进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程再创建子进程</span></span><br><span class="line">        id = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fork error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 让第一个子进程退出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first process exit!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程的子进程睡眠30s保证第一个子进程退出，这样子进程的子进程的父亲就是init进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"second process is sleeping~~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) != id) &#123;</span><br><span class="line">        perror(<span class="string">"waite error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"father process exit!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样进程产生子进程的父进程就变成init进程了，就不需要父进程阻塞等待</p><ol start="2"><li>通过信号机制异步回收，最理想处理方式</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id;</span><br><span class="line">    <span class="comment">// 处理僵尸进程</span></span><br><span class="line">    <span class="keyword">while</span> ((id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait child:%d\n"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建捕捉子进程退出信号</span></span><br><span class="line">    signal(SIGCHLD,handler);</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%d exit\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于UNIX 的历史原因还有另外一种办法：父进程调用sigaction将SIGCHLD的处理动作置为SIG_IGN这样fork出来的子进程在终止时会自动清理掉，不会产生僵尸进程，也不会通知父进程。系统默认的忽略动作和用户用sigaction函数自定义的忽略通常是没有区别的，但这是一个特例，Linux可用，但不保证在其它UNIX系统上都可用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;僵尸进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#僵尸进程&quot;&gt;&lt;/a&gt; 僵尸进程&lt;/h1&gt;&lt;p&gt;linux中，正常情况下，子进程和父进程是一个异步过程，父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="僵尸进程" scheme="https://Ranjiahao.github.io/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="https://Ranjiahao.github.io/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程信号</title>
    <link href="https://ranjiahao.github.io/2020/06/03/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
    <id>https://ranjiahao.github.io/2020/06/03/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>信号是一种软件中断，信号在linux中提供了异步处理的方法，将内核和进程联系起来，是操作系统内部交互的机制<br>kill -l指令查看所有信号</p><h1 id="信号产生"><a class="markdownIt-Anchor" href="#信号产生"></a> 信号产生</h1><ul><li><p>键盘输入产生一个硬件中断（电信号）到cpu，被OS获取，解释成信号（软件），发送给目标前台进程<br>ctrl-c: 2号信号(SIGINT)，终止当前运行进程，只能发给前台进程，一个命令后面加个&amp;可以放到后台运行Shell不必等待进程结束<br>ctrl-: 3号信号(SIGQUIT)，终止进程并且产生coredump文件<br>ctrl-z: 20号信号(SIGTSTP)，挂起一个进程<br>ctrl-d: 不是发送信号，而是表示一个特殊的二进制值，表示 EOF</p></li><li><p>通过硬件异常产生信号<br>CPU: 0作为除数时，CPU运算单元会产生异常，产生8号信号（SIGFPE）<br>MMU: 访问内存越界或者非法的时候，MMU发现当前内存不合法，就会通知OS向该进程发送11号信号（SIGSEGV）</p></li><li><p>调用系统函数向进程发送信号<br>系统调用，给某个进程发送某个信号<code>int kill(pid_t pid, int signo);</code><br>库函数<code>int raise(int signo);</code>底层封装kill了<br>库函数<code>void abort(void);</code>使当前进程接收到信号SIGABRT而异常终止</p></li><li><p>软件条件产生信号<br>管道所有读端关闭，写操作会触发13号信号（SIGPIPE）<br><code>unsigned int alarm(unsigned int seconds);</code>seconds秒后，操作系统会发送14号闹钟信号（SIGALRM）</p></li></ul><p>信号递达：实际执行信号的处理动作<br>信号未决：从信号产生到信号递达之间的状态<br>信号阻塞：如果一个信号被阻塞，那它在产生时处于未决状态，不会被递达，只有解除该信号后，才被递达(信号忽略是在递达之后可选的一种处理动作)</p><h1 id="信号处理方式"><a class="markdownIt-Anchor" href="#信号处理方式"></a> 信号处理方式</h1><p>信号有三种处理方式</p><ol><li>忽略某个信号，不做任何处理</li><li>对该信号的处理保留系统的默认值，典型的缺省动作是终止进程</li><li>用户定义处理函数，由信号处理<code>sighandler_t signal(int signum, sighandler_t handler);``typedef void (*sighandler_t)(int);</code></li></ol><p>内核处理过程：</p><p><img src="img1.png" alt="img1"></p><p>sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程</p><h1 id="信号排队"><a class="markdownIt-Anchor" href="#信号排队"></a> 信号排队</h1><p>对于每一个进程，内核会用一个pending位图来标记信号的处理状态。如果一个信号还未被目标进程处理，那么对应位置就被标记为1。内核向进程递送新的信号时，会查看进程对应的pending中，该信号对应的位置是否为1<br>若为1则有挂起的信号，Unix传统的做法，内核将直接丢弃这一信号，不可靠信号(1~31)。而后Linux对此做出了一些改进，内核会为每个进程维护一组队列(queue)，有挂起信号时，就将新来的信号排队(enqueue)，可靠信号(34~64)<br>位图用sigset_t表示，而队列就是一个双向链表，链表头结点包含在进程对应的task_struct中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="阻塞信号"><a class="markdownIt-Anchor" href="#阻塞信号"></a> 阻塞信号</h1><p><img src="img2.png" alt="img2"></p><p>每个信号都有两个标志位分别表示阻塞(block)和未决(pending)还有一个函数指针表示处理动作。信号产生时,内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。图中第一个信号未阻塞也未产生，当它递达时执行默认处理动作。第二个信号信号产生过，但被阻塞，暂时不能递达。在没有解除阻塞之前不能忽略这个信号，第三个信号未产生，一旦产生信号将被阻塞，它的处理动作是用户自定义函数sighandler</p><h1 id="信号集操作函数"><a class="markdownIt-Anchor" href="#信号集操作函数"></a> 信号集操作函数</h1><blockquote><p>int sigemptyset(sigset_t *set); // 初始化set所指向的信号集全0<br>int sigfillset(sigset_t *set); // 初始化set所指向的信号集全1<br>int sigaddset (sigset_t *set, int signo); // 将signo对应位图设置为1<br>int sigdelset(sigset_t *set, int signo); // 将signo对应位图设置为0<br>int sigismember（const sigset_t *set, int signo); // 判断信号集中是否包含信号signo<br>返回值：成功返回0，失败返回-1。sigismember成功返回0或者1</p><p>int sigprocmask(int how, const sigset_t *set, sigset_t *oset);<br>若oset非空，则当前信号屏蔽字通过oset传出，若set是非空,则更改信号屏蔽字<br>how:<br>SIG_BLOCK: 添加到当前信号屏蔽字中的信号，相当于mask = mask|set<br>SIG_UNBLOCK: 从当前信号屏蔽字中解除的信号，相当于mask = mask&amp;~set<br>SIG_SETMASK: 设置当前信号屏蔽字为set，相当于mask = set<br>返回值：成功返回0，失败返回-1<br>int sigpending（sigset_t* set); 读取当前进程的未决信号集，成功返回0，失败返回-1</p></blockquote><ul><li>SIGKILL(9号)和SIGSTOP(19号)不可被阻塞、不可被忽略、不可被自定义</li></ul><p>演示代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印未决信号集函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpending</span><span class="params">(<span class="keyword">sigset_t</span> pending)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 1 ~ 31信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;pending, i)) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置2号信号为屏蔽信号</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, <span class="number">2</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span> pending;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 每秒打印一次未决信号</span></span><br><span class="line">        sigpending(&amp;pending);</span><br><span class="line">        printpending(pending);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">            raise(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6s后解除对2号信号的屏蔽</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0000000000000000000000000000000<br>0000000000000000000000000000000<br>0000000000000000000000000000000<br>0100000000000000000000000000000<br>0100000000000000000000000000000<br>0100000000000000000000000000000</p><p>前三秒没有任何信号产生，3秒后raise向进程发送了2号信号，但是2号信号为阻塞状态，所以信号产生后不会被递达的，6秒后解除了对2号信号的屏蔽，此时2号信号被递达去执行默认处理动作退出</p><h1 id="sigaction"><a class="markdownIt-Anchor" href="#sigaction"></a> sigaction</h1><blockquote><p>int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);<br>读取和修改与指定信号相关联的处理动作<br>若act非空，则根据act修改该信号的处理动作。若oact非空，则通过oact传出该信号原来的处理动作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>(*sa_handler)(<span class="keyword">int</span>); <span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="keyword">void</span>(*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>*);</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask; <span class="comment">//当正在执行信号处理动作时，希望屏蔽的信号。当处理结束后，自动解除屏蔽</span></span><br><span class="line"><span class="keyword">int</span> sa_flags; <span class="comment">// SA_SIGINFO使用sa_sigaction作为信号处理函数</span></span><br><span class="line"><span class="keyword">void</span>(*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="使用coredump"><a class="markdownIt-Anchor" href="#使用coredump"></a> 使用coredump</h1><p>进程异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，事后可以用调试器检查core文件以查清错误原因，PCB中存在此进程允许产生core文件的大小(Resource Limit)，core文件中可能包含用户密码等敏感信息，默认是不产生core文件的，可以用ulimit命令改变Shell进程的Resource Limit，允许core文件最大为1024K: $ ulimit -c 1024子进程的PCB由Shell进程复制而来，所以也具有和Shell进程相同的Resource Limit值gdb调试启动后，可以使用core-file [corefilename]查看信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;信号是一种软件中断，信号在linux中提供了异步处理的方法，将内核和进程联系起来，是操作系统内部交互的机制&lt;br&gt;kill -l指令查看所有信号&lt;/p&gt;&lt;h1 id=&quot;信号产生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#信号产生&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="信号" scheme="https://Ranjiahao.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>内核态与用户态</title>
    <link href="https://ranjiahao.github.io/2020/06/01/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/"/>
    <id>https://ranjiahao.github.io/2020/06/01/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在32位操作系统下，虚拟地址空间为4G，也就是说一个进程的最大的地址空间为4G。操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。对Linux操作系统而言，最高的1G字节由内核使用。低3G字节由各个进程使用</p><p>换句话说，最高1G内核空间是被所有进程共享，剩余3G才归进程自己使用</p><h1 id="区分内核空间与用户空间的意义"><a class="markdownIt-Anchor" href="#区分内核空间与用户空间的意义"></a> 区分内核空间与用户空间的意义</h1><p>CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</p><h1 id="内核态与用户态"><a class="markdownIt-Anchor" href="#内核态与用户态"></a> 内核态与用户态</h1><p>Linux系统只使用了Ring0和Ring3两个运行级别。当进程运行在Ring3级别时被称为运行在用户态，而运行在Ring0级别时被称为运行在内核态。运行在Ring3级别时被称为运行在用户态，运行在Ring0级别时被称为运行在内核态<br>在内核态下，进程运行在内核地址空间中，此时CPU可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问<br>在用户态下，进程运行在用户地址空间中，被执行的代码要受到CPU的检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段中I/O许可位图中规定的可访问端口进行直接访问。</p><p>我们可以将每个处理器在任何指定时间点上的活动概括为下列三者之一：</p><ul><li><p>运行于用户空间，执行用户进程</p></li><li><p>运行于内核空间，处于进程上下文，代表某个特定的进程执行</p></li><li><p>运行于内核空间，处于中断上下文（保证中断服务程序能够在第一时间响应和处理中断请求，然后快速地退出），与任何进程无关，处理某个特定的中断</p></li></ul><p>用户态到内核态的转换概况来说有三种方式分别为系统调用、软中断和硬件中断</p><h1 id="linux系统结构图"><a class="markdownIt-Anchor" href="#linux系统结构图"></a> Linux系统结构图</h1><p>从内核空间和用户空间的角度看整个Linux系统的结构，从下往上依次为：硬件 -&gt; 内核空间 -&gt; 用户空间</p><p><img src="img1.png" alt="img1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在32位操作系统下，虚拟地址空间为4G，也就是说一个进程的最大的地址空间为4G。操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="内核态与用户态" scheme="https://Ranjiahao.github.io/tags/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>动态库静态库与软硬链接</title>
    <link href="https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态库"><a class="markdownIt-Anchor" href="#静态库"></a> 静态库</h1><p>静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可执行文件之后不再依赖静态库。所以速度会较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成静态库</span><br><span class="line">$ gcc -c test1.c test2.c</span><br><span class="line">$ ar -rc libmylib.a test1.o test2.o # ar是gnu归档工具，rc表示(replace and create)</span><br><span class="line">$ ar -tv libmylib.a # 查看静态库中的目录列表 t:列出静态库中的文件 v:verbose 详细信息</span><br></pre></td></tr></table></figure><h1 id="动态库"><a class="markdownIt-Anchor" href="#动态库"></a> 动态库</h1><p>动态库（.so）：程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码，在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制到内存中，动态库可以在多个程序间共享，所以动态链接使得可执行文件更小，节省了磁盘空间。操作系统采用虚拟内存机制允许物理内存中的一份动态库被要用到该库的所有进程共用，节省了内存和磁盘空间，但是，每次使用时，都要去调用动态库，所以速度会相对较慢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 生成动态库</span><br><span class="line">$ gcc -c -fPIC test1.c test2.c # -fPIX产生位置无关码</span><br><span class="line">$ gcc -shared test1.o test2.o -o libmylib.so # -sharde表示生成共享库格式</span><br></pre></td></tr></table></figure><h1 id="使用库"><a class="markdownIt-Anchor" href="#使用库"></a> 使用库</h1><p><code>$ gcc main.c -I ./include -L. -lmylib</code><br>-L: 指定库路径（默认是从usr/lib 或 usr/local/lib中寻找库文件）<br>-l: 指定库名（去掉lib以及版本号）<br>-I: 指定头文件搜索路径<br>可以将路径添加到环境变量LIBRARY_PATH中代替-L<br>运行动态库：由于动态链接在运行时需要动态库，所以要么拷贝.so文件到系统共享库路径下；要么添加路径到环境变量LD_LIBRARY_PATH中；或者在目录/etc/ld.so.conf.d/中创建mylib.conf，并且在其中填写存放动态库的路径，保存退出后，使用ldconfig命令更新/ld.so.conf.d目录<br>gcc默认动态链接，如果想使用第三方静态库，不能使用-static选项，因为-static选项是生成静态链接可执行程序，所有库都使用静态库，我们只希望这个第三方库使用静态库而不是所有，因此我们将第三方库拷贝到指定目录下然后使用-L选项指定路径，链接的就是静态库</p><h1 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h1><p>创建方式 ln srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln tmp tmp.hard</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode相同，而链接数从1变成了2<br>删除文件时干了两件事情：1.在目录中将对应的记录删除 2.将硬连接数-1，如果为0，则将对应<br>的磁盘释放</p><h1 id="软链接"><a class="markdownIt-Anchor" href="#软链接"></a> 软链接</h1><p>创建方式 ln -s srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln -s tmp tmp.soft</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode不相同，而tmp.soft的文件大小为被链接文件所给路径的长度</p><h1 id="链接的访问"><a class="markdownIt-Anchor" href="#链接的访问"></a> 链接的访问</h1><p><img src="img1.png" alt="img1"></p><p>硬链接hard link本质上和file没区别，与源文件file共用一个inode节点，通过inode来访问数据，而软链接soft link本质上是一个独立的文件，有自己的inode节点和自己的data block其中保存着file的路径，通过路径访问源文件</p><p>所以删除源文件，软链接文件失效；硬链接只是链接数-1，删除了目录文件data block中保存的目录项。由于软链接通过路径访问，硬链接通过inode访问，所以软链接可以跨分区，而硬链接不可跨分区，目录本身也是跨分区的所以不能设置硬链接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#静态库&quot;&gt;&lt;/a&gt; 静态库&lt;/h1&gt;&lt;p&gt;静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="动态库静态库" scheme="https://Ranjiahao.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="软硬链接" scheme="https://Ranjiahao.github.io/tags/%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
</feed>
