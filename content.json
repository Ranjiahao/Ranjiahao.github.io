{"meta":{"title":"Ran","subtitle":"","description":"","author":"Ran","url":"https://Ranjiahao.github.io","root":"/"},"pages":[],"posts":[{"title":"文件系统","slug":"文件系统","date":"2020-05-16T16:00:00.000Z","updated":"2020-05-16T16:00:00.000Z","comments":true,"path":"2020/05/17/文件系统/","link":"","permalink":"https://ranjiahao.github.io/2020/05/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"机械硬盘的物理存储机制一个硬盘有多张盘片叠成，不同盘片有编号每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位 磁盘分区硬盘分区本质是硬盘这个物理概念转换成区这个逻辑概念，为下一步格式化做准备。第一扇区有硬盘主引导记录及分区表， MBR扇区由引导代码(446bytes)、MBR分区表(64bytes)、MBR结束标志(2bytes)3部分构成，一共占用512bytes。MBR放有最基本的引导加载程序，是系统开机启动的关键环节，而分区表则跟分区有关，它记录了硬盘分区的相关信息，分区表仅有64bytes，最多只能记彔四块分区（分区其实就是对分区表进行设置），也可以设置成主分区+逻辑分区，这时也是最多4个分区号码，但是变成了4 = 3 + 1其中4是主分区和扩展分区加起来最多4个，3是主分区，1是扩展分区，占用了一个主分区号，从5开始都是逻辑分区。扩展分区的磁盘总量等于一个逻辑分区的磁盘总量。本质是利用额外的扇区来记录更多的分区信息。扩展分区不同于主分区，它本身并没有内容，它是为进一步逻辑分区提供空间的，只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区最好单独分一个swap区，当有数据被存放在物理内存里面，但是这些数据又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap置换空间当中，而将速度较快的物理内存空间释放出来给真正需要的程序使用 ext2文件系统Boot Block: 这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的MBR， 也就是这样才能实现多重引导的功能Block group: ext2文件系统会根据分区的大小划分为数个Block GroupSuper Block: 存放文件系统本身的结构信息，一般大小为1024bytes。记录的信息主要有: bolck 和 inode的总量，未使用的block和inode的数量，是否被挂载，一个block(1k|2k|4k mke2fs -b可以设置)，和inode(128bytes)的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了Group Descriptor Table: 块组描述符，描述块组属性信息，这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段分别介于哪一个block号码之间Block Bitmp: 记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用inode Bitmap: 每个bit表示一个inode是否空闲可用inode Table: 存放文件属性 如文件大小/权限/所有者，数据地址，最近修改时间等(ls -i可查看)Date blocks：存放文件内容创建一个新文件主要有以下几个操作：存储属性，内核通过inode Bitmap找到一个空闲的inode节点存储数据，内核通过Block Bitmap找到了n个空闲块，将内核缓冲区的数据复制到块中记录分配情况，内核在inode Table记录块列表等信息添加文件名到目录，内核将入口（inode，filename等信息）添加到目录文件的block中，文件名和inode之间的对应关系将文件名和文件的内容及属性连接起来所以文件名的记录是在目录的block当中，「新增/删除/更名文件名」与目录的w权限有关stat file_name命令可查看这些信息 inode直接/间接区inode要记录的资料非常多，却只有128bytes，因为inode记录block 号码的区域定义为12个直接，一个间接，一个双间接与一个三间接记录区直接记录：里面有12个直接指向block号码的对照，这12条记录就能够直接取得block号码间接记录：再拿一个block来当作记录block号码的记录区，如果文件太大时，就会使用间接的block来记录号码。同理，如果文件持续长大，那么就会利用所谓的双间接，第一个block仅再指出下一个记录号码的block在哪里，实际记录的在第二个block当中。依此类推，三间接就是利用第三层block来记录号码12个直接指向： 12 * 1K = 12K间接： 256 * 1K = 256K，block号码的记录占4bytes，因此1K的大小能够记录256笔记录双间接： 256 * 256k = 64M，第一层block会指定256个间接三间接：256 * 64M = 16G，第一层block会指定256个双间接 vfs在一个区被格式化为一个文件系统之后，它就可以被Linux操作系统使用了，只是这个时候Linux操作系统还找不到它，所以我们还需要把这个文件系统注册进Linux操作系统的文件体系里，这个操作就叫挂载，把对不同文件系统的访问交给了VFS（虚拟文件系统），VFS能访问和管理各种不同的文件系，每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"https://ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"系统文件IO","slug":"系统文件IO","date":"2020-05-15T16:00:00.000Z","updated":"2020-05-15T16:00:00.000Z","comments":true,"path":"2020/05/16/系统文件IO/","link":"","permalink":"https://ranjiahao.github.io/2020/05/16/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/","excerpt":"","text":"文件描述符文件描述符就是从0开始的整数，打开文件时，操作系统在内存中要创建相应的数据结构file来描述目标文件，而进程执行系统文件IO，必须让进程和文件关联起来。所以每个进程都有一个指针files, 指向一张表files_struct，表中包涵一个指针数组，每个元素都是一个指向打开文件的指针，本质上，文件描述符就是数组的下标 open/close#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);pathname: 要打开或创建的目标文件flags: 一个或者多个常量进行或运算，构成flagsO_RDONLY: 只读打开，O_WRONLY: 只写打开，O_RDWR: 读，写打开。这三个常量，必须指定一个且只能指定一个O_CREAT: 若文件不存在，则创建。需要使用mode选项，来指明新文件的访问权限O_APPEND: 追加写打开O_TRUNC: 打开文件截断为0mode: 文件访问权限，如，0664，这里真实权限为mode &amp; ~umask，umask(0)设置权限掩码返回值: 成功返回文件描述符，失败返回-1并设置errno close#include &lt;unistd.h&gt;int close(int fd);fd: 文件描述符返回值: 成功返回0，失败返回-1并设置errno write/read#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count);fd: 文件描述符buf: 写入到文件描述符的指定的缓冲区/从文件描述符fd将字节数读入的缓冲区count: 写入到文件描述符的字节数/从文件描述符读入的字节数返回值: 成功返回写入/读入字节数，失败返回-1并设置errno lseek#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);fd: 文件描述符offset: 偏移量whence:SEEK_SET: 文件偏移量将被设置为offsetSEEK_CUR: 文件偏移量将被设置为当前文件偏移量加上offset，offset可正可负SEEK_END: 文件偏移量将被设置为文件长度加上offset，offset可正可负返回值: 成功返回新的偏移量，失败返回-1并设置errno 重定向 文件描述符分配原则123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main() &#123; close(1); int fd = open(\"myfile\", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH); if (fd &lt; 0) &#123; perror(\"open\"); return -1; &#125; printf(\"fd: %d\\n\", fd); fflush(stdout); // '\\n'只能针对标准输出文件刷新缓冲区 close(fd); return 0;&#125;运行后我们发现本来应该输出到显示器上的内容却输出到了myfile当中，其中fd=1，所以文件描述符的分配原则为最小未使用原则 dup2系统调用#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);让newfd下标对应的指针也指向oldfd下标对应的指针所指向的文件1234567891011121314int main() &#123; int fd = open(\"myfile\", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH); if (fd &lt; 0) &#123; perror(\"open\"); return -1; &#125; dup2(fd, 1); char arr[] = \"hehe\\n\"; write(fd, arr, strlen(arr)); printf(\"fd: %d\\n\", fd); fflush(stdout); // '\\n'只能针对标准输出文件刷新缓冲区 close(fd); return 0;&#125;运行结束后文件myfile中hehefd: 3 缓冲区一般C库函数写入文件时是全缓冲的，而写入显示器是行缓冲1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main() &#123; const char* str1 = \"printf\\n\"; const char* str2 = \"fwrite\\n\"; const char* str3 = \"write\\n\"; printf(\"%s\", str1); fwrite(str2, strlen(str2), 1, stdout); write(1, str3, strlen(str3)); fork(); return 0;&#125;所以运行./a.out发现输出printffwritewrite但是运行./a.out &gt; file，则file文件中printf和fwrite被打印了两次，write还是一次这是因为’\\n’刷新缓冲区的作用只对标准输出有用，而对于普通文件来说数据的缓冲方式由行缓冲变成了全缓冲，而我们放在缓冲区中的数据，就不会被立即刷新，fork的时候，子进程会连缓冲区中数据一起拷贝，write没有变化，说明它没有用户级缓冲C库当中的FILE结构体内(/usr/include/libio.h)包含了用户态的缓冲区定义，以及文件描述符，本质上都是通过文件描述符来访问的","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"文件IO","slug":"文件IO","permalink":"https://ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6IO/"}]},{"title":"SystemV消息队列","slug":"SystemV消息队列","date":"2020-05-12T16:00:00.000Z","updated":"2020-05-12T16:00:00.000Z","comments":true,"path":"2020/05/13/SystemV消息队列/","link":"","permalink":"https://ranjiahao.github.io/2020/05/13/SystemV%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"消息队列是一种以链表式结构组织的数据，存放在内核中，是三个IPC对象类型中最具数据操作性的数据传送方式，可以根据数据类型来检索消息，有同步互斥机制，面向数据报，全双工通信我们可以通过命令查看/删除系统中已有的消息队列ipcs -q/ipcrm -q [msqid]相关操作（系统调用）： 消息队列创建/打开int msgget(key_t key, int msgflg);第一个参数key：给这个消息队列分配的密钥，同创建共享内存一样，系统返回对应共享内存的标识符，失败返回-1，并设置errno第二个参数msgflg: IPC_CREAT如果不存在就创建，IPC_EXCL如果已经存在则返回失败，位或权限位：可以设置消息队列的访问权限每创建一个消息队列，就会在用户空间组织这样的一个数据结构，用来设置或返回消息队列的信息1234567891011struct msqid_ds &#123; struct ipc_perm msg_perm; struct msg *msg_first; // 消息队列第一个节点 struct msg *msg_last; // 消息队列最后一个节点 unsigned short msg_cbytes; // 当前队列字节数据 unsigned short msg_qnum; // 队列中的消息数 unsigned short msg_qbytes; // 队列中最大字节数 ... // 时间属性 // 最近接收和发送消息的进程pid&#125;; 添加消息到消息队列中int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);msgid:msgget函数返回的消息队列标识符msgp:指向准备发送的消息，是一个用户自定义的结构体msgsz:消息⻓度，不含消息类型，最大长度MSGMAXmsgflg:IPC_NOWAIT队列满非阻塞，返回EAGAIN错误，0阻塞12345msgp的格式：struct msgbuf &#123; long mtype; // 必须大于0 char mtext[1]; // 消息的长度，实际是一柔性数组，在实际使用时有用户自主指定大小&#125;将数据添加到队列尾，并且更新msg_last 从消息队列中接收消息ssize_t msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg);msgid: msgget函数返回的消息队列标识符msgp: 指针指向准备接收的消息msgsz: 是msgp指向的消息⻓度，不含消息类型msgtype: 它可以实现接收优先级的简单形式若 = 0 - 读取消息队列中最早的消息，以先进先出的方式读取消息若 &gt; 0 - 读取消息队列类型为msgtyp最早的消息若 &lt; 0 - 读取消息队列中，消息类型小于或等于msgtyp绝对值的消息中最小消息类型的最早消息msgflg: IPC_NOWAIT设置非阻塞，MSG_NOERROR表示消息大小超过msgsz时被截断，MSG_EXCEPT表示接收类型不等于msgtyp的第一条消息成功返回实际放到msgp⾥去的字符个数，失败返回-1，并设置errno 控制消息队列int msgctl(int msqid,int cmd,struct msqid_ds* buf);msgid: msgget函数返回的消息队列标识符cmd:IPC_RMID删除消息队列， IPC_STAT IPC_SETcmd: IPC_RMID删除消息队列、IPC_STAT获取消息队列的当前关联值、IPC_SET根据buf设置消息队列关联值buf: 保存着消息队列的模式状态和访问权限的数据结构，输入输出型参数成功返回0；失败返回-1，并设置errno 从内核看本质内核维护着一个消息队列的全局数据结构ipc_ids，其中有一个指针指向一个数组。每当创建一个IPC对象内核就会创建一个ipc_perm，并且将它的地址放到结构体ipc_id中，这个数组就是这个结构体ipc_id组成的数组，数组最大的个数就是MSGMNI，所以说消息队列随内核持续，直到内核重新自举或者显示删除该对象为止。类似还有信号量、共享内存 代码实现server和client的交互https://github.com/Ranjiahao/Linux/tree/master/ipc/MessageQueue","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"ipc","slug":"ipc","permalink":"https://ranjiahao.github.io/tags/ipc/"}]},{"title":"SystemV信号量","slug":"SystemV信号量","date":"2020-05-11T16:00:00.000Z","updated":"2020-05-11T16:00:00.000Z","comments":true,"path":"2020/05/12/SystemV信号量/","link":"","permalink":"https://ranjiahao.github.io/2020/05/12/SystemV%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"为了防止出现因多个进程同时访问一个共享资源引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。信号量就可以提供这样的一种访问机制，确保多个线程在对共享内存这样的共享资源同时读写时，使之实现同步与互斥，也就是说信号量用来调协进程对公共资源的访问的信号量本质上是一个计数器，也是临界资源，进程对其访问都是原子操作，信号量记录着临界资源的个数信号量可以使用ipcs -s查看使用ipcrm -s [semid]删除 原理信号量只能进行等待和发送信号两种操作，即P(sv)和V(sv)P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程并将其PCB放入队列中V(sv)：如果等待队列中有其他进程因等待sv而被挂起，就让一个恢复运行，如果没有进程因等待sv而挂起，就给它加1所以一个信号量不仅包含临界资源的数目，还必须维护一个队列实际应用中信号量是不能单独定义的，而是定义一个信号量集，其中包含一组信号量，同一信号集中的信号量使用同一个引用ID，每个信号量集有一个与之对应的结构体，其中记录着各种信息1234567struct semid_ds &#123; struct ipc_perm sem_perm; struct sem *sem_base; // 指向sem结构数组，数组中每一个元素对应一个信号量 unsigned short sem_nsems; // 信号量的个数 ... // 时间相关描述&#125;;其中struct sem才是信号量的描述结构体：123456struct sem &#123; unsigned short semval; // 信号量的值 pid_t semid; // 上一次进行操作的进程号 unsigned short semncnt; // 等待可利用资源出现的进程数 unsigned short semzcnt; // 等待全部资源可被独占的进程数&#125;系统中的限制：SEMVMX最大的信号值SEMMNI系统允许的最大信号量集个数SEMMNS系统允许的最大信号量个数SEMMSL每个信号集中最大的信号量个数 创建/打开信号集int semget(key_t key, int nsems, int semflg);参数key和semflg用法和共享内存相同nsems: 信号量集中创建的信号量数量，如果创建信号集，sem_nsems将被设置为nsems；如果打开一个已存在的信号集，此参数就被忽略如果调用成功，则返回信号量集合标识符，否则返回-1，并设置error 操作信号量集（原子操作）int semop(int semid, struct sembuf *sops, unsigned nsops);semid: semget返回的信号量集标识符sops: 为sembuf结构数组指针，每一个元素表示一个操作，这个函数是一个原子操作，一旦执行就将执行数组中所有的操作nsops: 为数组中元素的个数12345struct sembuf &#123; unsigned short sem_num; // 表示信号量集中某一信号量序号(0~ipc_perm.sem_nsems) short sem_op; // 所执行的操作，如-1表示P操作消耗一个临界资源， 1表示V操作释放了一个临界资源 short sem_flg; // 0表示没资源时阻塞等待，IPC_NOWAIT非阻塞，SEM_UNDO（将已申请的信号量还原为初识状态，即刚开始获得这个信号量时的状态）&#125; 控制信号量集int semctl(int semid, int semnum, int cmd, ...);semid: semget返回的信号集标识符semnum: 信号集中信号量的序号cmd: 将要采取的动作根据cmd参数具体内容，IPC_RMID删除信号量，可能有第四个参数，是一个联合体，当cmd为GET时返回对应值成功返回0，失败返回-1，设置errno123456union semun &#123; int val; // 用于SETVAL/GETVAL命令 struct semid_ds *buf; // 用于IPC_STAT/IPC_SET命令，输入/输出型参数表示存放信号量集数据结构缓冲区 unsigned short array; struct seminfo* _buf;&#125; 操作演示子进程循环输出A和A到显示器上这2个A中间不可被打断父进程循环输出B和B到显示器上这2个B中间不可被打断https://github.com/Ranjiahao/Linux/tree/master/ipc/Semaphore","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"ipc","slug":"ipc","permalink":"https://ranjiahao.github.io/tags/ipc/"}]},{"title":"SystemV共享内存","slug":"SystemV共享内存","date":"2020-05-06T16:00:00.000Z","updated":"2020-05-06T16:00:00.000Z","comments":true,"path":"2020/05/07/SystemV共享内存/","link":"","permalink":"https://ranjiahao.github.io/2020/05/07/SystemV%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"共享内存就是将同一块物理内存映射到不同进程虚拟内存的共享区域，实现两个进程间通信。一旦这样的内存映射到进程地址空间的共享区，这些进程间数据传递不再涉及到内核，不再通过执行进入内核的系统调用来传递彼此的数据，所以说共享内存是最快的IPC形式我们可以通过命令查看/删除系统中已有的共享内存ipcs -m/ipcrm -m [shmid]相关操作（系统调用）： 创建共享内存int shmget(key_t key, size_t size, int shmflg);key:进程对共享内存的访问都是间接的，需要提供一个参数key（非0整数，可为ftok() 的返回值，也可以用自己的宏）来告诉操作系统需要哪个共享内存，然后系统返回对应共享内存的标识符，失败返回-1，并设置errnosize:共享内存大小，PAGE_SIZE页面大小(4096)的整数倍，因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍shmflg:由九个权限标志构成，用法和创建文件时使用的mode模式标志是一样的IPC_CREAT：如果不存在就创建IPC_EXCL： 如果已经存在则返回失败位或权限位：共享内存位或权限位后可以设置共享内存的访问权限，格式和 open() 函数的 mode_t 一样，但可执行权限未使用共享内存数据结构12345678910111213struct shmid_ds &#123; struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no. of current attaches */ unsigned short shm_unused; /* compatibility */ void *shm_unused2; /* ditto - used by DIPC */ void *shm_unused3; /* unused */&#125;; 建立映射关系void *shmat(int shmid, const void *shmaddr, int shmflg);shmid: 共享内存标识（shmget返回值）shmaddr: 映射地址，通常为空，让系统来选择共享内存的地址；若不为NULL且shmflg无SHM_RND标记，若设置SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍shmflg:SHM_RDONLY:只读0:共享内存具有可读可写权限返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1，并设置errno 解除映射int shmdt(const void *shmaddr);shmaddr: 由shmat所返回的指针成功返回0；失败返回-1，并设置errno 控制共享内存int shmctl(int shmid, int cmd, struct shmid_ds *buf);shmid:由shmget返回的共享内存标识码cmd:IPC_RMID删除共享内存、IPC_STAT获取共享内存的当前关联值、IPC_SET根据buf设置共享内存关联值。注意：共享内存删除不会直接删除，而是判断映射连接数是否为0，为0直接删除否则拒绝后续其他进程的映射连接，为0时自动删除buf:保存着共享内存的模式状态和访问权限的数据结构，输入输出型参数成功返回0；失败返回-1共享内存并未提供同步机制，一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，比如信号量 关于函数ftokshmget函数中的第一个参数key相当于共享内存的钥匙，可以通过它能访问唯一的内存区域。由于key和内存是一一对应的，所以我们不难想到用这块内存的inod节点来生成密钥，这就有了ftok函数key_t ftok(const char *pathname, int proj_id);pathname就时你指定的文件名(该文件必须是存在而且可以访问的)，proj_id是子序号，虽然为int，但是只有8个比特被使用(0-255)成功返回key值，失败返回-1生成规则：返回的整数IPC键由proj_id的低序8位，struct stat中st_dev成员的低序8位，st_ino的低序16位组合而成注意事项：pathname指定的目录（文件）不能在程序运行期间删除或创建。因为文件每次创建时由系统赋予的索引节点可能不一样。这样一来，通过同一个pathname与proj_id就不能保证生成同一个IPC键 代码实现server和client的交互https://github.com/Ranjiahao/Linux/tree/master/ipc/SharedMemory","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"ipc","slug":"ipc","permalink":"https://ranjiahao.github.io/tags/ipc/"}]},{"title":"管道","slug":"管道","date":"2020-05-05T16:00:00.000Z","updated":"2020-05-05T16:00:00.000Z","comments":true,"path":"2020/05/06/管道/","link":"","permalink":"https://ranjiahao.github.io/2020/05/06/%E7%AE%A1%E9%81%93/","excerpt":"","text":"每个进程各自有不同的用户地址空间，都是独立运行，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程把数据从用户空间拷到内核缓冲区，另一个进程再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信我们常用 ‘|’ 符号来用一个命令来处理另一个命令的显示结果cat test.c | less这个过程本质上是创建cat进程传入参数test.c然后这个进程从用户态切换到内核态，将数据拷贝到内核中的缓冲区中，然后less进程切换到内核态取走缓冲区中的数据，返回用户态并处理数据。这个内核中的缓冲区就叫管道管道的生命周期随进程，进程结束以后，相应的管道也会自动释放。有同步互斥机制、面向字节流的通信、半双工通信 匿名管道系统调用int pipe(int pipefd[2]);fd为输出型参数，传入一个空数组，返回文件描述符数组，fd[0]表示读端fd[1]表示写端，成功返回0，失败返回错误代码-112345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;string.h&gt;int main() &#123; int fd[2]; int ret = pipe(fd); if (ret &lt; 0) &#123; perror(\"creat pipe error\"); return 1; &#125; pid_t id = fork(); if (id &lt; 0) &#123; perror(\"fork error\"); return 1; &#125; else if (id == 0) &#123; // 子进程写数据，关闭读端 close(fd[0]); while (1) &#123; char mesg[] = \"I am child\"; write(fd[1], mesg, strlen(mesg)); printf(\"child write:%s\\n\", mesg); sleep(1); &#125; close(fd[1]); &#125; else &#123; // 父进程读数据，关闭写端 close(fd[1]); while (1) &#123; char mesg[1024]; read(fd[0], mesg, 1023); printf(\"father read:%s\\n\", mesg); &#125; waitpid(id, NULL, 0); close(fd[0]); &#125; return 0;&#125;父进程创建fd[2]数组，子进程fork后，fork了fd中的文件描述符，因此他们可以共同访问内核中的缓冲区（管道），也就是说这种方式仅适用与具有亲缘关系的进程 命名管道由于匿名管道只可用于具亲缘关系的进程间通信，所以我们要实现非亲缘进程间的通信就需要给这个内核中的缓冲区起个名字，使进程可以通过管道名字访问到这个内核中的缓冲区，进而实现进程间通信可以通过mkfifo命令直接创建管道文件(此文件本质还是内核中的缓冲区)mkfifo filename或者通过库函数int mkfifo(const char *filename,mode_t mode);第一个参数为所要创建管道的全路径名，第二个参数为创建管道的权限，这里需要注意的是，该值会受到umask值的影响，所以最好先将umask的值设置为000打开规则：open打开的时候可以通过参数O_NONBLOCK设置非阻塞若只读打开：阻塞直到有相应进程为写而打开该FIFOO_NONBLOCK: 若没有进程为写而打开该FIFO，则立即返回成功若只写打开：阻塞直到有相应进程为读而打开该FIFOO_NONBLOCK: 若没有进程为读而打开该FIFO，则立刻返回失败，错误码为ENXIO演示代码：1234567891011121314151617181920212223242526272829303132// fifo_write.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; const char *file = \"./tmp.fifo\"; umask(0); int ret = mkfifo(file, 0664); if (ret &lt; 0) &#123; // 如果文件不是因为已经存在而报错，则退出 if (errno != EEXIST) &#123; perror(\"mkfifo error\"); return -1; &#125; &#125; int fd = open(file, O_WRONLY); if (fd &lt; 0) &#123; perror(\"open error\"); return -1; &#125; while(1) &#123; char buf[1024] = &#123;0&#125;; scanf(\"%s\", buf); write(fd, buf, strlen(buf)); &#125; close(fd); return 0;&#125;1234567891011121314151617181920212223242526272829303132333435363738// fifo_read.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; const char *file = \"./tmp.fifo\"; umask(0); int ret = mkfifo(file, 0664); if (ret &lt; 0) &#123; // 如果文件不是因为已经存在而报错，则退出 if (errno != EEXIST) &#123; perror(\"mkfifo error\"); return -1; &#125; &#125; int fd = open(file, O_RDONLY); if (fd &lt; 0) &#123; perror(\"open error\"); return -1; &#125; while(1) &#123; char buf[1024] = &#123;0&#125;; int ret = read(fd, buf, 1023); if (ret &lt; 0) &#123; perror(\"read error\"); return -1; &#125; else if (ret == 0) &#123; printf(\"write closed\\n\"); return -1; &#125; printf(\"buf:[%s]\\n\", buf); &#125; close(fd); return 0;&#125; 管道读写规则如果管道所有的写端都关闭，那么read循环读取完数据后返回0如果写端没全部关闭，但是又不写入数据，则读端一直阻塞等待，等写端写入数据后读取如果管道所有的读端都关闭，执行write时会产生SIGPIPE信号，导致write进程退出，进程异常终止如果读端没全部关闭，但是缓冲区已经满了，则写端一直阻塞等待，等有空间在写入若设置O_NONBLOCK则当管道满时或没有数据可读时返回-1，设置errno值为EAGAIN当要写入的数据量不大于PIPE_BUF时（ulimit -a查看），linux将保证写入的原子性那么系统分配的管道大小是多少呢？我们可以通过命令cat /proc/sys/kernel/msgmax查看 从内核看管道进程向管道中写数据本质上就是创建一块内核空间并且将这个空间的inode信息放入f_inode中，将f_op设置为对这块内存的操作（读写等）然后将若干信息组织起来形成file结构体，并且将这个结构体的指针添加到进程的文件描述符数组中，这是进程就可以操作这个块内核空间了，另一个进程若想进行通信，就要使用相同的f_inode而f_op可以不同 利用管道实现minishellhttps://github.com/Ranjiahao/Linux/tree/master/MiniShell","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"ipc","slug":"ipc","permalink":"https://ranjiahao.github.io/tags/ipc/"}]},{"title":"进程程序替换","slug":"进程程序替换","date":"2020-05-02T16:00:00.000Z","updated":"2020-05-02T16:00:00.000Z","comments":true,"path":"2020/05/03/进程程序替换/","link":"","permalink":"https://ranjiahao.github.io/2020/05/03/%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2/","excerpt":"","text":"当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行系统调用：int execve(const char* path, char* const argv[], char* const envp[]);库函数：int execl(const char* path, const char* arg, ...);int execlp(const char* file, const char* arg, ...);int execle(const char* path, const char* arg, ...,char* const envp[]);int execv(const char* path, char* const argv[]);int execvp(const char* file, char* const argv[]);int execvpe(const char* file, char* const argv[], char* const envp[]);规律：exec必选v和l必须选其一l(list) : 表示参数采用列表v(vector) : 参数用数组e、p可选可不选p(path) : 有p自动搜索环境变量PATHe(env) : 表示自己维护环境变量如果调用成功则加载新的程序从启动代码开始执行，不返回如果调用出错则返回-112345678char* const argv[] = &#123;\"ls\", \"-l\", NULL&#125;;char *const envp[] = &#123;\"PATH=/bin:/usr/bin\", \"TERM=console\", NULL&#125;;// l和vexecl(\"/bin/ls\", \"ls\", \"-l\", NULL);execv(\"/bin/ls\", argv);// p和eexeclp(\"ls\", \"ls\", \"-l\", NULL);execve(\"/bin/ls\", argv, envp);这些库函数在调用时候，如果参数采用列表格式首先将参数替换成数组形式，然后如果有相对路径就在底层替换成绝对路径，然后根据自己维护的环境变量或者shell的环境变量组织envp，而后调execve接口我们发现函数和进程之间有些许相似性：c语言中，一个函数和一个函数可以通过return/call来通信，这类似与进程间的exit/exec&amp;fork，进程可以fork/exec，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来返回值。调用它的进程可以通过wait来获取exit的返回值","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"进程终止与wait参数status","slug":"进程终止与wait参数status","date":"2020-05-01T16:00:00.000Z","updated":"2020-05-01T16:00:00.000Z","comments":true,"path":"2020/05/02/进程终止与wait参数status/","link":"","permalink":"https://ranjiahao.github.io/2020/05/02/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E4%B8%8Ewait%E5%8F%82%E6%95%B0status/","excerpt":"","text":"常见进程退出方法exit或_exit退出_exit系统调用函数：void _exit(int status);参数status定义了进程的终止状态，父进程通过wait获取该值。虽然status是int，但是仅有低8位可以被父进程所用，实际上就是子进程的返回值。exit库函数：void exit(int status);和_exit唯一的区别是退出前执行用户通过atexit或on_exit定义的清理函数然后刷新缓存关闭所有打开的流，最后调用_exit函数退出return退出，和exit一样，exec/exit针对进程间通信，就像call/return针对函数间通信信号终止 常见进程等待方法wait系统调用函数（阻塞）pid_t wait(int* status);status为输出型参数，NULL表示不关心子进程状态返回值：成功返回被等待进程的pid，失败返回-1waitpid系统调用函数pid_ t waitpid(pid_t pid, int* status, int options);参数pid若为-1则等待任意一个进程，若&gt;0则等待特定的进程参数options若为0则阻塞，若为WNOHANG则非阻塞 wait参数statustatus不仅仅是一个int类型参数，可以看作是一个位图只研究其低16位：我们可以通过status &amp; 0x7f来判断异常信号是否为0；若为0，则正常退出，然后可以通过(status &gt;&gt; 8) &amp; 0xff来获取子进程返回值。sys/wait.h中提供了一些宏来简化这些操作：123456789if (WIFEXITED(status)) &#123; // 正常退出：((status) &amp; 0x7f) == 0 // 打印退出码：(status &gt;&gt; 8) &amp; 0xff printf(\"child return: %d\\n\", WEXITSTATUS(status));&#125; else if (WIFSIGNALED(status)) &#123; // 异常退出：((signed char) (((status) &amp; 0x7f) + 1) &gt;&gt; 1) &gt; 0 // 打印异常信号值：(status) &amp; 0x7f printf(\"child signal: %d\\n\", WTERMSIG(status));&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"fork、vfork、clone、system、popen","slug":"fork、vfork、clone、system、popen","date":"2020-04-30T16:00:00.000Z","updated":"2020-04-30T16:00:00.000Z","comments":true,"path":"2020/05/01/fork、vfork、clone、system、popen/","link":"","permalink":"https://ranjiahao.github.io/2020/05/01/fork%E3%80%81vfork%E3%80%81clone%E3%80%81system%E3%80%81popen/","excerpt":"","text":"fork系统调用：pid_t fork(void);子进程返回0，父进程返回子进程pid出错返回-1，子进程不会被创建，会设置errno错误原因可能是：系统中有太多的进程，实际用户的进程数超过了限制，命令ulimit -a中max user processes可查看用户最大能创建的进程数fork后，就有两个二进制代码相同的进程，都运行到相同的地方，由调度器决定谁先执行。子进程是父进程的一份拷贝，代码共享，数据独有代码共享：共享代码段，父子进程的指令双方都能看到数据独有：数据段、堆、栈 fork都做了那些事？进程调用fork，由用户态切换到内核态分配新的内存块和内核数据结构给子进程将父进程部分数据结构内容拷贝至子进程添加子进程到系统进程列表当中fork返回，开始调度器调度 写实拷贝通常，父子代码共享，父子再不写入时，数据也是共享的，子进程复制了父进程的task_struct，系统堆栈空间和页面表任意一方写入时，便在物理空间中创建一份副本进行修改，并且映射到相同的虚拟地址空间中也就是说：父进程和子进程共享物理页帧而不是复制页帧。只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的。当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的 vfork系统调用pid_t vfork(void);调用方法和返回值和fork相同说起fork就不得不提类似的vfork，它直接共享了父进程的虚拟空间、物理空间，所以如果子进程（轻量级进程）修改数据则父进程会收到影响。也就是说子进程不可以return或者exit。但是可以_exit退出子进程会导致父进程挂起，除非子进程exit或者execve才会唤起父进程vfork存在的意义是为了快速创建进程，并且通过程序替换来运行其他程序，因为共享地址空间可以减少拷贝时间。但是自从fork实现写实拷贝后，此接口就几乎被淘汰了 clone系统调用：int clone(int (*fn)(void*), void* child_stack, int flags, void* arg);fn 是需要执行的函数指针，即 clone 出来的子进程需要执行的函数内容。child_stack 就明显是给子进程分配的系统堆栈空间的位置。（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值）flags 用于描述子进程需要从父进程中继承哪些部分的内容，因此通过这个值可以控制产生进程、线程、甚至非父子关系而是兄弟关系的进程等等，功能强大（可以说是一个轻量级进程的系统调用）arg就是传给子进程的参数12345678910111213int Test() &#123; printf(\"pid:%d\\n\", getpid()); return 0;&#125;int main() &#123; void* stack = malloc(8192); // clone()第二个参数指定的是栈空间，栈是反向增长， // 所以这里传入申请的空间的尾部 int pid = clone(&amp;Test, (char*)stack+8192, CLONE_PARENT, 0); printf(\"Father pid:%d, child pid:%d\\n\", getpid(), pid); return 0;&#125; system库函数int system(const char *command);system()执行通过创建子进程执行/bin/sh -c命令指定的命令，并在命令完成后返回,在执行命令的时候,SIGCHLD将被阻塞，SIGINT和SIGQUIT将被忽略。command:命令参数是指向包含shell命令行的以null结尾的字符串的指针。这个命令被传递给/bin/sh使用。返回值:fork()失败,返回-1exec()失败,返回值相当于执行了exit(127)参数command为NULL时返回1system在执行期间调用进程会一直等待shell命令执行完成(waitpid等待子进程结束)才返回 popen/pclose库函数：FILE *popen(const char *command, const char *type);int pclose(FILE *stream);popen会调用fork产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令，参数type可用r代表读取，w代表写入。依照此type的值，popen会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可以利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中，若成功则返回文件指针，否则返回NULL,错误原因存在于errno中测试代码：123456789101112// test.cc#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; FILE* fd = popen(\"./cin\", \"w\"); fprintf(fd, \"hehe\"); sleep(1); // 保证popen打开的进程先退出 pclose(fd); return 0;&#125;123456789// cin.cc#include &lt;iostream&gt;int main() &#123; std::string s; std::cin &gt;&gt; s; std::cout &lt;&lt; s &lt;&lt; std::endl; return 0;&#125;g++ test.cc -o testg++ cin.cc -o cin然后执行./cin./test一秒后输出hehe这个一个异步执行的过程：test进程调用popen后fork一个子进程调用exec函数去执行command，然后cin进程启动阻塞到cin&gt;&gt;阶段，同时popen返回管道的描述符，fprintf将数据写入管道中，此时cin就被唤醒，打印数据信息如果不加sleep函数，可能父进程在子进程还没打印的时候先退出，就会变成孤儿进程，因此可能在标头之后打印。 do_fork内核函数：do_fork(unsigned long clone_flag, unsigned long usp, structpt_regs)fork、vfork、clone最底层涉及到的都是 do_fork() 这个调用，只是传入参数不同，clone 可以认为就是个 do_fork() 的API外衣其中clone_flag为：标志含义CLONE_PARENT创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”CLONE_FS子进程与父进程共享相同的文件系统，包括root、当前目录、umaskCLONE_FILES子进程与父进程共享相同的文件描述符（file descriptor）表CLONE_NEWNS在新的namespace启动子进程，namespace描述了进程的文件hierarchyCLONE_SIGHAND子进程与父进程共享相同的信号处理（signal handler）表CLONE_PTRACE若父进程被trace，子进程也被traceCLONE_VFORK父进程被挂起，直至子进程释放虚拟内存资源CLONE_VM子进程与父进程运行于相同的内存空间CLONE_PID子进程在创建时PID与父进程一致CLONE_THREADLinux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群任何一位被置1了则表明创建的子进程和父进程共享该位对应的资源vfork中clone_flag = CLONE_VFORK | CLONE_VM |SIGCHLD这表示子进程和父进程共享地址空间、共享相同的信号处理表，同时do_fork会检查CLONE_VFORK，如果该位被置1了，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁fork中clone_flag=SIGCHLD 两道有意思的面试题判断创建几个进程：12345int main() &#123; if ((fork() &amp;&amp; fork()) || fork()) &#123; fork(); &#125;&#125;答案为8个，可以通过pstree命令查看：分析：主进程从左到右，子进程从上到下执行。判断输出*的个数：123456int main() &#123; for (int i = 0; i &lt; 2; ++i) &#123; fork(); printf(\"*\\n\"); &#125;&#125;输出6个*123456int main() &#123; for (int i = 0; i &lt; 2; ++i) &#123; fork(); printf(\"*\"); &#125;&#125;输出8个*，注意没有\\n来刷新缓冲区，则子进程会拷贝父进程缓冲区中的数据","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"fork","slug":"fork","permalink":"https://ranjiahao.github.io/tags/fork/"}]},{"title":"main函数的三个参数","slug":"main函数的三个参数","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-16T16:00:00.000Z","comments":true,"path":"2020/04/17/main函数的三个参数/","link":"","permalink":"https://ranjiahao.github.io/2020/04/17/main%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/","excerpt":"","text":"C程序总是从main函数开始执行的，main函数的原型是：int main(int argc, char* argv[], char* env[]) argc与argvargc表示传入main函数的参数个数argv[]表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个123456// main.cint main(int argc,char *argv[]) &#123; for (int i=0; i &lt; argc; i++) &#123; printf(\"argv[%d]=[%s]\\n\",i,argv[i]); &#125;&#125;编译这段程序gcc main.c -o main生成可执行程序main./main运行：输出结果为argv[0]=[./main]./main -a abc运行：输出结果为argv[0]=[./main]argv[1]=[-a]argv[2]=[abc]可以总结出以下几点：argv[0] 指向程序运行的全路径名 argv[1] 指向在DOS命令行中执行程序名后的第一个字符串 argv[2] 指向执行程序名后的第二个字符串…argv[argc]为NULL env每个进程都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以NULL结尾的环境字符串，env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value 为ENVVAR的对应值环境变量通常具有全局特性，系统设置更加方便(切换用户会还原) 常见的环境变量PATH: 命令的搜索路径HOME: 用户家目录SHELL: 当前Shell通常是/bin/bash 环境变量相关命令echo $(NAME)可以查看指定环境变量export (val)声明一个新的环境变量env显示所有环境变量unset (NAME)清除环境变量set显示本地定义的shell变量和环境变量 通过代码查看环境变量由于环境变量具有继承特性，我们可以创建进程来继承shell的环境变量并且打印出来通过第三个参数获得123456int main(int argc, char *argv[], char *env[]) &#123; for(int i = 0; env[i] != NULL; ++i) &#123; printf(\"%s\\n\", env[i]); &#125; return 0;&#125;通过libc中定义的全局变量environ获取1234567int main(int argc, char *argv[]) &#123; extern char **environ; for(int i = 0; environ[i]; ++i) &#123; printf(\"%s\\n\", environ[i]); &#125; return 0;&#125;通过系统调用接口获取或设置环境变量getenv 和putenv 也是定义在stdlib.h 中，函数原型如下：char *getenv(const char *name);int putenv(char *str); ./main执行和main执行有些指令可以直接执行，不需要带路径，而我们写的可执行程序必须要加上路径，这是由于默认的搜索路径为PATH，我们只需将PATH修改即可：PATH=$PATH:./但是需要注意的是不要覆盖PATH防止类似ls的命令用不了 是否应该使用第三个参数envISO C/ISO C++ ,POSIX 标准都不支持main三个参数的定义形式，VC和GNU编译器都扩展了main函数的定义，所以目前可以这样使用。如果要编写更加可移植的程序，应该使用全局环境变量environ来代替env的作用，如果要访问特定的环境变量，应该使用getenv和putenv函数","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://ranjiahao.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"进程基础","slug":"进程基础","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-15T16:00:00.000Z","comments":true,"path":"2020/04/16/进程基础/","link":"","permalink":"https://ranjiahao.github.io/2020/04/16/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"进程是程序执行时的一个实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，是当前状态和相关系统资源描述的活动单元 进程与可执行程序的区别可执行程序是指令和数据的集合，作为一种数据资料长期存在，是一个静态概念。而进程是可执行程序的一次执行过程，是有生命期，是暂时的，是一个动态概念。所以同一个可执行程序可以对应多个进程 进程标识方法 PCB进程信息被放在一个叫做进程控制块的数据结构，linux下就是task_struct结构体，其中主要内容有：标识符：PID标识和PPID等状态：任务状态，退出代码，退出信号等优先级：相对于其他进程的优先级程序计数器：程序中即将被执行的下一条指令的地址内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针上下文数据：进程执行时处理器的寄存器中的数据I／O状态信息：包括显示的IO请求，分配给进程的IO设备和被进程使用的文件列表记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等其他信息 PID与PPID标识和区分进程的ID，是在当前linux系统中唯一的非负整数。进程运行时PID由操作系统随机分配，同一个程序运行两次会产生两个进程，也就有两个不同的PID每个进程除了一定有PID还会有PPID(1号进程除外)通过PPID可以找到父进程的信息PID为1的进程是由内核创建的init进程，其他子进程都是由它衍生出来，所有进程都来自于一个进程，所以Linux的进程模型也叫做进程树查看方式：可以通过/proc系统文件夹查看通过top或者ps -ef命令来查看通过系统调用函数getpid()getppid() 进程状态R运行状态：并不意味着进程一定在运行中，同一时刻可能有多个进程处于此状态，这些进程的task_struct结构被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）它表明进程要么是在运行中，要么在运行队列里。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行S可中断睡眠状态：意味着进程在等待某时间的发生（如，等待资源），这些进程的task_struct结构被放入对应事件的等待队列中，当这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒D不可中断的睡眠状态：指进程不响应异步信号，因此无法用kill杀掉，除非reboot，通常此状态是在等待IO，比如磁盘IO，网络IO，其他外设IOT暂停状态、t跟踪状态：ctrl+z可以通过发送SIGSTOP信号，暂停状态，这个被暂停的进程可以通过发送SIGCONT信号让进程继续运行。跟踪状态是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于跟踪状态，跟踪状态的进程不能响应sigcont信号而被唤醒，只能等到调试进程通过ptrace系统调用执行X死亡状态：这个状态只是一个返回状态，你不会在任务列表里看到这个状态Z僵尸进程：当子进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码 进程优先级cpu资源分配的先后顺序，就是指进程的优先级。由于linux是多任务环境的，所以配置优先级可以改善系统性能。还可以把进程运行到指定的CPU上，把不重要的进程安排到某个CPU，可大大改善系统整体性能 PRI与NI命令ps -l可查看进程的PRI与NI，PRI为进程的优先级，越小优先级别越高；NI为优先级修正数值；所以PRI(new)=PRI(old)+NI，所以，调整进程优先级，Linux下，就是调整进程NI值。NI其取值范围是-20至19，一共40个级别，PRI默认为80 更改NI进入top后按“r”–&gt;输入进程PID–&gt;输入nice值renice -n (ni_val) -p (pid)nice -n (ni_val) ./exe —在运行的时候直接设置","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ranjiahao.github.io/categories/Linux/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"排序总结","slug":"排序总结","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-07T16:00:00.000Z","comments":true,"path":"2020/04/08/排序总结/","link":"","permalink":"https://ranjiahao.github.io/2020/04/08/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"名称平均时间复杂度额外空间复杂度in-place稳定性冒泡排序O(n2)O(1)true稳定选择排序O(n2)O(1)true不稳定插入排序O(n2)O(1)true稳定归并排序O(n * log n)O(n)false稳定快速排序O(n * log n)O(log n)true不稳定希尔排序O(n1.3)O(1)true不稳定堆排序O(n * log n)O(1)true不稳定计数排序O(max(n,范围))O(范围)false稳定基数排序O(p(n+b))O(n+b)false稳定桶排序O(n + n(log n - log m))O(m+n)false依赖于桶内排序冒泡排序：n比较小时考虑采用、实现简单但速度慢、每次只移动相邻两个元素选择排序：n比较小时考虑采用、实现简单但速度慢、移动次数较少但不稳定、数据不敏感插入排序：n比较小时考虑采用、实现简单但速度慢、由于元素移动代价小于元素交换代价所以速度略优于冒泡排序、n越小越有序效率越高归并排序：n比较大时考虑采用、数据不敏感、需要O(n)额外空间快速排序：n比较大时考虑采用、速度快元素移动少但不稳定、序列越乱，效率越高希尔排序：在中小型数组中效率特别快、比较是其中最主要的操作、不稳定堆排序：适合处理海量数据、不稳定、数据不敏感计数排序：当数据范围比较小时速度非常快基数排序：适合多关键字排序桶排序：当范围已经知道，而且空间不是很重要的情况下考虑采用桶排序","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"基排序","slug":"基排序","date":"2020-04-06T16:00:00.000Z","updated":"2020-04-06T16:00:00.000Z","comments":true,"path":"2020/04/07/基排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/07/%E5%9F%BA%E6%8E%92%E5%BA%8F/","excerpt":"","text":"基于桶排序来实现。通过键值的部分信息，将要排序的元素分配至某些“桶”中，以此达到排序的作用。基数排序的方式可以采用LSD或MSD，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始时间复杂度：O(p(n+b))其中：分配为O(n)、收集为O(b)、p为收集分配趟数空间复杂度：O(n+b)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 假设元素最多有MaxDigit个关键字，基数全是同样的Radix#define MaxDigit 4#define Radix 10// 默认次位D=1, 主位D&lt;=MaxDigitint GetDigit(int X, int D) &#123; int d; for (int i = 1; i &lt;= D; i++) &#123; d = X % Radix; X /= Radix; &#125; return d;&#125;// 基数排序 - 次位优先void LSDRadixSort(int array[], int size) &#123; vector&lt;list&lt;int&gt;&gt; arr(Radix); // 将原始序列存入链表list list&lt;int&gt; list; for (int i = 0; i &lt; size; i++) &#123; list.push_back(array[i]); &#125; // 开始排序 for (int D = 1; D &lt;= MaxDigit; D++) &#123; // 分配 for (auto&amp; i : list) &#123; int Di = GetDigit(i, D); arr[Di].push_back(i); &#125; // 收集 list.clear(); for (auto&amp; l : arr) &#123; list.insert(list.end(), l.begin(), l.end()); l.clear(); &#125; &#125; // 将list倒入array[] for (int i = 0; i &lt; size; i++) &#123; array[i] = *list.begin(); list.pop_front(); &#125;&#125;// 核心递归函数：对array[L]...array[R]的第D位数进行排序void MSD(int array[], int L, int R, int D) &#123; if (D == 0) &#123; return; &#125; vector&lt;list&lt;int&gt;&gt; arr(Radix); // 将原始序列存入链表list list&lt;int&gt; list; for (int i = L; i &lt;= R; i++) &#123; list.push_back(array[i]); &#125; // 分配 for (auto&amp; i : list) &#123; int Di = GetDigit(i, D); arr[Di].push_back(i); &#125; // 收集 int left = L; int right = L; for (auto&amp; l : arr) &#123; for (auto&amp; i : l) &#123; array[right++] = i; &#125; // 递归对该桶数据排序，位数减1 MSD(array, left, right - 1, D - 1); left = right; &#125;&#125;// 基数排序 - 主位优先void MSDRadixSort(int array[], int size) &#123; MSD(array, 0, size - 1, MaxDigit);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"桶排序","slug":"桶排序","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-05T16:00:00.000Z","comments":true,"path":"2020/04/06/桶排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/06/%E6%A1%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"将数组分到有限数量的桶子里，每个桶子再个别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序时间复杂度：最好：对于n个待排数据，m个桶，当n=m时，极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(n)最坏：当m=1时，即极限情况下只有一个桶时。桶排序的最坏效率达到O(n * log n)平均：n + n + n/m * log(n/m ) * m + n = 3n + n(log n - log m) = O(n + n(log n - log m))空间复杂度：O(m + n)12345678910111213141516171819202122232425262728293031323334void bucketSort(double array[], int size) &#123; // 求数组最大值和最小值，并算出差值d double max = array[0]; double min = array[0]; for (int i = 1; i &lt; size; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; double d = max - min; // 一般创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定 // OR 桶数量等于原始数列的元素数量+1，除了第一个桶只包含数列最小值，最后一个桶只包含数列最大值，中间各个桶的区间按照比例确定 int bucketNum = size; vector&lt;list&lt;double&gt;&gt; bucketArr(bucketNum); // 遍历数组，将每个元素放入桶中 for (int i = 0; i &lt; size; i++) &#123; int num = (int)((array[i] - min) * (bucketNum - 1) / d); bucketArr[num].push_back(array[i]); &#125; // 对每个桶内部进行排序 for (int i = 0; i &lt; bucketArr.size(); i++) &#123; bucketArr[i].sort(); &#125; // 放入数组 int i = 0; for (auto&amp; bucket : bucketArr) &#123; for (auto&amp; d : bucket) &#123; array[i++] = d; &#125; &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"计数排序","slug":"计数排序","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-04T16:00:00.000Z","comments":true,"path":"2020/04/05/计数排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/05/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上时间复杂度：O(max(n,范围))空间复杂度：O(范围)稳定性：稳定优点：计数排序在数据范围集中时，效率很高缺点：当数列元素不是整数或最大最小值差距过大时，并不适用计数排序 初步实现12345678910111213141516171819202122232425262728293031void CountSort(int array[], int size) &#123; // 找出最大数和最小数，确定序列的范围 int max = array[0]; int min = array[0]; for (int i = 0; i &lt; size; ++i) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // rang为序列的范围，开辟额外数组，初始化全为0 int rang = max - min + 1; int* countArr = (int*)malloc(sizeof(int) * rang); for (int i = 0; i &lt; rang; ++i) &#123; countArr[i] = 0; &#125; // 进行计数 for (int i = 0; i &lt; size; ++i) &#123; countArr[array[i] - min]++; &#125; // 将序列拷贝回原序列 int j = 0; for (int i = 0; i &lt; rang; ++i) &#123; while (countArr[i]--) &#123; array[j++] = i + min; &#125; &#125; free(countArr);&#125; 优化从功能上看，这段代码只是简单地按照统计数组的下标输出了元素值，并没有真正给原始数列进行排序。如果放在现实业务里，比如给学生的考试分数排序，遇到相同的分数就会分不清谁是谁。我们需要稍微改变之前的逻辑，对统计数组做一下变形1234567891011121314151617181920212223242526272829303132void CountSort(int sortArr[],int array[], int size) &#123; // 找出最大数和最小数，确定序列的范围 int max = array[0]; int min = array[0]; for (int i = 0; i &lt; size; ++i) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // rang为序列的范围，开辟额外数组，初始化全为0 int rang = max - min + 1; int* countArr = (int*)malloc(sizeof(int) * rang); for (int i = 0; i &lt; rang; ++i) &#123; countArr[i] = 0; &#125; // 进行计数 for (int i = 0; i &lt; size; ++i) &#123; countArr[array[i] - min]++; &#125; // 对所有的计数累加 for (int i = 1; i &lt; rang; i++) &#123; countArr[i] += countArr[i - 1]; &#125; // 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组 for (int i = size - 1; i &gt;= 0; --i) &#123; sortArr[--countArr[array[i] - min]] = array[i]; &#125; free(countArr);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-04-03T16:00:00.000Z","updated":"2020-04-03T16:00:00.000Z","comments":true,"path":"2020/04/04/归并排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。经常被使用的是二路归并算法，即将两个已经排序的序列合并成一个序列的操作时间复杂度：O(n * log n) 数据不敏感空间复杂度：O(n)稳定性：稳定时间复杂度计算过程：T[n]=2T[n/2]+n=22T[n/22]+2n=23T[n/23]+3n=...=2mT[1]+mnT[n]=2T[n/2]+n=2^2T[n/2^2]+2n=2^3T[n/2^3]+3n=...=2^mT[1]+mnT[n]=2T[n/2]+n=22T[n/22]+2n=23T[n/23]+3n=...=2mT[1]+mn此时n=2mm=log nn=2^m \\qquad m=log\\,nn=2mm=logn得T[n]=nT[1]+n log nT[n]=nT[1]+n\\;log\\,nT[n]=nT[1]+nlogn所以归并排序时间复杂度为O(n * log n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void Merge(int array[], int low, int mid, int high, int extra[]) &#123; // [low, high) int i = low; // [low, mid) int j = mid; // [mid, high) int k = low; // extra[low, high) while (i &lt; mid &amp;&amp; j &lt; high) &#123; if (array[i] &lt;= array[j]) &#123; // =保证了稳定性 extra[k++] = array[i++]; &#125; else &#123; extra[k++] = array[j++]; &#125; &#125; while (i &lt; mid) &#123; extra[k++] = array[i++]; &#125; while (j &lt; high) &#123; extra[k++] = array[j++]; &#125; for (int x = low; x &lt; high; x++) &#123; array[x] = extra[x]; &#125;&#125;void MergeSortInner(int array[], int low, int high, int extra[]) &#123; if (high - low &lt;= 1) &#123; // size &lt;= 1 return; &#125; // 1. 平均切割 int mid = low + (high - low) / 2; // 2. 分治处理左右两个小区间 MergeSortInner(array, low, mid, extra); // [low, mid) MergeSortInner(array, mid, high, extra); // [mid, high) // 3. 合并两个有序数组 Merge(array, low, mid, high, extra);&#125;// 递归实现void MergeSort(int array[], int size) &#123; int* extra = (int*)malloc(sizeof(int) * size); MergeSortInner(array, 0, size, extra); free(extra);&#125;// 非递归实现void MergeSortNoR(int array[], int size) &#123; int* extra = (int*)malloc(sizeof(int) * size); // 左右两个小区间的长度都是i for (int i = 1; i &lt; size; i = i * 2) &#123; for (int j = 0; j &lt; size; j = j + 2 * i) &#123; // 根据i和j, 确定low, mid, high int low = j; int mid = low + i; if (mid &gt;= size) &#123; // 没有右边的小区间，不需要合并 continue; &#125; int high = mid + i; if (high &gt; size) &#123; high = size; &#125; Merge(array, low, mid, high, extra); &#125; &#125; free(extra);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"交换排序","slug":"交换排序","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-02T16:00:00.000Z","comments":true,"path":"2020/04/03/交换排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/03/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾时间复杂度：最好：正序 比较次数n 移动次数0最坏：反序 比较次数n2 移动次数n2平均：O(n2)空间复杂度：O(1)稳定性：稳定12345678910111213141516void BubbleSort(int array[], int size) &#123; for (int i = 0; i &lt; size; i++) &#123; int isSorted = 1; // 有序 [size - i, size - 1] // 无序 [0, size - 1 - i] for (int j = 0; j &lt; size - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array[j], array[j + 1]); isSorted = 0; &#125; &#125; if (isSorted) &#123; break; &#125; &#125;&#125; 优化我们可以在每一轮排序的最后，记录下最后一次元素交换的位置，那个位置也就是无序数列的边界，再往后就是有序区了1234567891011121314void BubbleSort(int array[], int size) &#123; for (int sortBorder = size; sortBorder &gt; 1;) &#123; int lastExchangeIndex = 0; // 无序 [0, sortBorder - 1] // 有序 [sortBorder, size - 1] for (int j = 0; j &lt; sortBorder - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array[j], array[j + 1]); lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex + 1; &#125;&#125; 快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列每一层的Partition：时间复杂度 O(n)空间复杂度 O(1)快速排序时间复杂度：最好：T(n)=2T(n/2)+O(n)=&gt;T(n)=O(n log n)T(n)=2T(n/2)+O(n)=&gt;T(n)=O(n\\;log\\,n)T(n)=2T(n/2)+O(n)=&gt;T(n)=O(nlogn)最坏：T(n)=T(n−1)+O(n)=&gt;T(n)=O(n2)T(n)=T(n-1)+O(n)=&gt;T(n)=O(n^2)T(n)=T(n−1)+O(n)=&gt;T(n)=O(n2)平均：T(n)=1n∑k=1n(T(n−k)+T(k−1))+n=2n∑k=1nT(k)+n=&gt;T(n)=O(n log n)T(n)=\\frac1{n}\\sum_{k=1}^n(T(n-k)+T(k-1))+n=\\frac2{n}\\sum_{k=1}^nT(k)+n=&gt;T(n)=O(n\\;log\\,n)T(n)=n1​∑k=1n​(T(n−k)+T(k−1))+n=n2​∑k=1n​T(k)+n=&gt;T(n)=O(nlogn)快速排序空间复杂度：空间消耗在于递归调用的栈帧消耗，最终消耗的情况是二叉树的高度，二叉树的高度在log(n) ~ n变化最好：O(log n)最坏：O(n)平均：O(log n)稳定性：不稳定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Hoverint Partition_1(int array[], int left, int right) &#123; int begin = left; // [left, begin] 保证 &lt;= pivot int end = right - 1; // [end, right] 保证 &gt;= pivot int pivot = array[right]; // 基准值 while (begin &lt; end) &#123; while (begin &lt; end &amp;&amp; array[begin] &lt;= pivot) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; array[end] &gt;= pivot) &#123; end--; &#125; swap(array[begin], array[end]); &#125; // 把基准值和begin所在的下标交换，和第一个比pivot大的数交换 swap(array[begin], array[right]); return begin;&#125;// 挖坑int Partition_2(int array[], int left, int right) &#123; int begin = left; // [left, begin] 保证 &lt;= pivot int end = right; // [end, right] 保证 &gt;= pivot int pivot = array[right]; // 基准值 while (begin &lt; end) &#123; while (begin &lt; end &amp;&amp; array[begin] &lt;= pivot) &#123; begin++; &#125; array[end] = array[begin]; while (begin &lt; end &amp;&amp; array[end] &gt;= pivot) &#123; end--; &#125; array[begin] = array[end]; &#125; array[begin] = pivot; return begin;&#125;// 前后下标int Partition_3(int array[], int left, int right) &#123; int d = left; for (int i = left; i &lt; right; i++) &#123; if (array[i] &lt; array[right]) &#123; swap(array[i], array[d]); d++; &#125; &#125; swap(array[d], array[right]); return d;&#125;void QuickSortInner(int array[], int left, int right) &#123; if (left &gt;= right) &#123; // size &lt;= 1 return; &#125; // 1. 确定基准值 // 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标 int d = Partition_1(array, left, right); // [left, right] 的区间被分成三部分 // [left, d - 1] &lt;= pivot // [d] == pivot // [d + 1, right] &gt;= pivot // 3. 分治处理所有两个小区间 QuickSortInner(array, left, d - 1); QuickSortInner(array, d + 1, right);&#125;void QuickSort(int array[], int size) &#123; QuickSortInner(array, 0, size - 1);&#125;void QuickSortNoR(int array[], int size) &#123; // 保存要排序区间的左右边界 std::stack&lt;int&gt; stack; stack.push(size - 1); // right stack.push(0); // left while (!stack.empty()) &#123; int left = stack.top(); stack.pop(); int right = stack.top(); stack.pop(); if (left &gt;= right) &#123; continue; &#125; int d = Partition_1(array, left, right); // [d + 1, right] stack.push(right); stack.push(d + 1); // [left, d - 1] stack.push(d - 1); stack.push(left); &#125;&#125; 优化上面的版本我们选择array[right]作为基准值，这其实是一种很不聪明的取法，当初始序列一开始就是有序的，则快速排序时间复杂度为T(n)=T(n−1)+O(n)=O(n2)T(n)=T(n-1)+O(n)=O(n^2)T(n)=T(n−1)+O(n)=O(n2)所以pivot最好用三数取中法来选取Partition函数中，如果有元素正好等于pivot，最好停下来做交换，虽然这样做了很多无谓的交换，但是最后i和j会停在比较中间的位置，主元也会被换在在比较中间的位置，这样做每一次递归的时候，原始序列基本被等分成两个等长的序列这样时间复杂度为O(n * log n)；如果不停下来交换而继续移动指针，这样其中一个指针是不动的，导致主元被放在一个端点，这样就成了O(n2)复杂度的算法了对于大规模数据我们用递归，而对于递归的数据规模充分的小的时候则停止递归，直接调用简单排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define CUTOFF 7 // 数组长度阈值int Median3(int array[], int left, int right) &#123; int center = (left + right) / 2; if (array[left] &gt; array[center]) &#123; swap(array[left], array[center]); &#125; if (array[left] &gt; array[right]) &#123; swap(array[left], array[right]); &#125; if (array[center] &gt; array[right]) &#123; swap(array[center], array[right]); &#125; // 此时A[left] &lt;= A[center] &lt;= A[right] swap(array[center], array[right - 1]); // 将基准pivot藏到右边 // 只需要考虑A[left + 1] … A[right - 2] return array[right - 1]; // 返回基准Pivot&#125;int Partition(int array[], int left, int right) &#123; int pivot = Median3(array, left, right); // 基准值 // 只需要考虑A[left + 1] … A[right - 2] int begin = left + 1; // [left, begin] 保证 &lt;= pivot int end = right - 2; // [end, right] 保证 &gt;= pivot while (begin &lt; end) &#123; while (begin &lt; end &amp;&amp; array[begin] &lt; pivot) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; array[end] &gt; pivot) &#123; end--; &#125; swap(array[begin], array[end]); &#125; // 把基准值和begin所在的下标交换，和第一个比pivot大的数交换 swap(array[begin], array[right]); return begin;&#125;void QuickSortInner(int array[], int left, int right) &#123; if ((right - left) &gt; CUTOFF) &#123; // 调用快速排序 // 1. 确定基准值 // 2. 遍历区间，进行切割，直到小的全在左，大的全在右，并且返回最终基准值所在的下标 int d = Partition_1(array, left, right); // [left, right] 的区间被分成三部分 // [left, d - 1] &lt;= pivot // [d] == pivot // [d + 1, right] &gt;= pivot // 3. 分治处理所有两个小区间 QuickSortInner(array, left, d - 1); QuickSortInner(array, d + 1, right); &#125; else &#123; InsertSort(array + left, right - left + 1); &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"选择排序","slug":"选择排序","date":"2020-04-01T16:00:00.000Z","updated":"2020-04-01T16:00:00.000Z","comments":true,"path":"2020/04/02/选择排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"直接选择排序每一次从待排序的数据元素中选出最小（和最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完时间复杂度：O(n2) 数据不敏感比较次数n2移动次数正序为0，反序为n空间复杂度：O(1)稳定性：不稳定123456789101112131415161718192021222324252627282930313233343536373839404142434445void SelectSort(int array[], int size) &#123; for (int i = 0; i &lt; size; i++) &#123; // 无序 [0, size - 1 - i] // 有序 [size - i, size - 1] int maxIdx = 0; // 要查找整个无序区间的最大值的下标 for (int j = 1; j &lt;= size - 1 - i; j++) &#123; if (array[j] &gt;= array[maxIdx]) &#123; maxIdx = j; &#125; &#125; // maxIdx 记录着无序区间部分最大的数的下标 // 和无序区间的最后一个位置的数进行交换 swap(array[maxIdx], array[size - 1 - i]); &#125;&#125;void SelectSortOP(int array[], int size) &#123; int begin = 0; int end = size - 1; // 有序 [0, begin - 1] 最小的数 // 有序 [end + 1, size - 1] 最大的数 // 无序 [begin, end] while (begin &lt;= end) &#123; int min = begin; int max = begin; for (int i = begin; i &lt;= end; i++) &#123; if (array[i] &gt; array[max]) &#123; max = i; &#125; if (array[i] &lt; array[min]) &#123; min = i; &#125; &#125; // 最小的数放到无序区间的最开始 // 最大的数放到无序区间的最末尾 swap(array[min], array[begin]); if (max == begin) &#123; max = min; &#125; swap(array[max], array[end]); begin++; end--; &#125;&#125; 堆排序从最大（小）堆顶不断取走堆顶元素放到有序序列中，直到堆的元素被全部取完时间复杂度：O(n * log n) 数据不敏感空间复杂度：O(1)稳定性：不稳定123456789101112131415161718192021222324252627282930313233343536void Heapify(int array[], int size, int index) &#123; int left = 2 * index + 1; int right = 2 * index + 2; if (left &gt;= size) &#123; return; &#125; int max = left; if (right &lt; size &amp;&amp; array[right] &gt; array[left]) &#123; max = right; &#125; if (array[index] &gt;= array[max]) &#123; return; &#125; swap(array[max], array[index]); Heapify(array, size, max);&#125;void CreateHeap(int array[], int size) &#123; // 从最后一个非叶子结点，一直到 0，不断的向下调整 for (int i = (size - 2) / 2; i &gt;= 0; i--) &#123; Heapify(array, size, i); &#125;&#125;void HeapSort(int array[], int size) &#123; // 建大堆 CreateHeap(array, size); // n // 无序 [0, size - 1 - i] // 有序 [size - i, size - 1] for (int i = 0; i &lt; size; i++) &#123; // n * log n // 交换最大的数和无序区间的最后一个数 swap(array[0], array[size - 1 - i]); // 堆的性质被破坏了，要调整的是剩余无序部分的长度 size - 1 - i Heapify(array, size - 1 - i, 0); // log n &#125;&#125;建堆时间复杂度：对满二叉树而言，第i层(根为第0层)有2i个节点由于建堆过程自底向上，以交换作为主要操作，因此第i层任意节点在最不利情况下，需要经过(n−i)次交换操作才能完成以该节点为堆根节点的建堆过程T(n)=20(n−0)+21(n−1)+...+2n(n−n)=∑i=0n(2i(n−i))T(n)=2^0(n−0)+2^1(n−1)+...+2^n(n−n)=\\sum_{i=0}^n{(2^i(n-i))}T(n)=20(n−0)+21(n−1)+...+2n(n−n)=∑i=0n​(2i(n−i))2T(n)=21(n−0)+22(n−1)+2n+1(n−n)=∑i=1n+1(2i(n−i))2T(n)=2^1(n-0)+2^2(n-1)+2^{n+1}(n-n)=\\sum_{i=1}^{n+1}{(2^i(n-i))}2T(n)=21(n−0)+22(n−1)+2n+1(n−n)=∑i=1n+1​(2i(n−i))2T(n)−T(n)=2n+1−2−n2T(n)-T(n)=2^{n+1}-2-n2T(n)−T(n)=2n+1−2−n总节点数1+2+4+...+2n=2n+1−11+2+4+...+2^n=2^{n+1}−11+2+4+...+2n=2n+1−1忽略减1取N＝2n+1N＝2^{n+1}N＝2n+1T(N)=2n+1−2−n=N(1−log NN−2N)≈NT(N)=2^{n+1}−2−n=N(1−\\frac{log\\,N}{N}−\\frac2N)≈NT(N)=2n+1−2−n=N(1−NlogN​−N2​)≈N堆排序时间复杂度：调整堆顶n-1次，总共比较次数2(log(n−1)+log(n−2)+...+log2)&lt;2n(logn)2(log(n-1)+log(n-2)+...+log2)&lt;2n(log n)2(log(n−1)+log(n−2)+...+log2)&lt;2n(logn)因此，堆排序时间复杂度为O(n * log n)","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"插入排序","slug":"插入排序","date":"2020-03-31T16:00:00.000Z","updated":"2020-03-31T16:00:00.000Z","comments":true,"path":"2020/04/01/插入排序/","link":"","permalink":"https://ranjiahao.github.io/2020/04/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"直接插入排序把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列时间复杂度：最好：正序 比较次数n 移动次数0最坏：反序 比较次数n2 移动次数n2平均：O(n2)空间复杂度：O(1)稳定性：稳定利用二分查找实现插入排序最好：正序 比较次数n * log n 移动次数0最坏：反序 比较次数n * log n 移动次数n2平均：O(n2)数据越少、越接近有序排序性能越好12345678910111213141516171819202122232425262728293031323334353637void InsertSort(int array[], int size) &#123; for (int i = 1; i &lt; size; i++) &#123; int key = array[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; key; j--) &#123; array[j + 1] = array[j]; &#125; array[j + 1] = key; &#125;&#125;// 利用二分查找实现插入排序void InsertSortBS(int array[], int size) &#123; for (int i = 1; i &lt; size; i++) &#123; // 有序 [0, i - 1] // 无序 [i, size - 1] int left = 0; int right = i - 1; // [left, right] while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (array[mid] == array[i]) &#123; left = mid + 1; &#125; else if (array[mid] &lt; array[i]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; // left 是要插入的位置的下标 int key = array[i]; for (int k = i; k &gt; left; k--) &#123; array[k] = array[k - 1]; &#125; array[left] = key; &#125;&#125; 希尔排序由于插入排序数据越少、越接近有序排序性能越好，希尔排序就是利用插入排序的这两个特点实现的，希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止时间复杂度：最好：O(n)最坏：O(n2)平均：O(1.3)希尔排序的时间复杂度与增量的选取有关，Hibbard增量序列O(n5/4)，Sedgewick增量序列O(n7/6)空间复杂度：O(1)稳定性：不稳定1234567891011121314151617181920212223void InsertSortWithGap(int array[], int size, int gap) &#123; for (int i = gap; i &lt; size; i++) &#123; int key = array[i]; int j; for (j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; key; j -= gap) &#123; array[j + gap] = array[j]; &#125; array[j + gap] = key; &#125;&#125;void ShellSort(int array[], int size) &#123; int gap = size; while (1) &#123; // 原始增量序列 gap /= 2; // gap = gap / 3 + 1; InsertSortWithGap(array, size, gap); if (gap == 1) &#123; break; &#125; &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://ranjiahao.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"deque原理以及stack、queue、priority_queue模拟实现","slug":"deque原理以及stack、queue、priority_queue模拟实现","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-30T16:00:00.000Z","comments":true,"path":"2020/03/31/deque原理以及stack、queue、priority_queue模拟实现/","link":"","permalink":"https://ranjiahao.github.io/2020/03/31/deque%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Astack%E3%80%81queue%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"容器适配器是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素stack底层可以用vector、deque、list默认使用dequequeue若使用vector来封装效率太低，所以底层可以用deque、list默认使用dequepriority_queue底层可以用vector和deque默认使用vectordeque:与vector比较，头插效率高，不需要搬移元素，扩容时，也不需要搬移大量的元素与list比较，空间利用率比较高，并且支持随机访问deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下stack和queue不需要遍历，只需要在固定的一端或者两端进行操作，stack中元素增长时，deque比vector的效率高（扩容时不需要搬移大量数据），queue中的元素增长时，deque不仅效率高，而且内存使用率高deque采用指针数组map作为主控。每个元素指向另一段连续线性空间，称为缓冲区。缓冲区是deque的储存空间主体，如果map数组就再申请一块更大的连续空间供map数组使用，将原有数据（很多指针）拷贝到新的map数组中，然后释放旧的空间deque的迭代器定义了四个指针，first和last指向缓冲区的首尾，cur指向当前遍历节点，node指向中控器中当前缓冲区是一个二级指针图中begin()和end()分别返回start迭代器和finish迭代器迭代器++时，cur往后走一位，当cur==last时，通过node访问下一个缓冲区的first并对cur重新赋值迭代器–时，先判断cur是否为first，若为first则通过node访问上一个缓冲区的last，否则返回–cur随机访问底层调用operator+，operator+再调用operator+=因此效率不高模拟实现stack，queue，priority_queue:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102template &lt;class T, class Con = std::deque&lt;T&gt;&gt;class Stack &#123;public: Stack() &#123;&#125; bool empty() const &#123; return _c.empty(); &#125; size_t size() const &#123; return _c.size(); &#125; T&amp; top() &#123; return _c.back(); &#125; const T&amp; top() const &#123; return _c.back(); &#125; void push(const T&amp; x) &#123; _c.push_back(x); &#125; void pop() &#123; _c.pop_back(); &#125;private: Con _c;&#125;;template &lt;class T, class Con = std::deque&lt;T&gt;&gt;class Queue &#123;public: Queue() &#123;&#125; bool empty() const &#123; return _c.empty(); &#125; size_t size() const &#123; return _c.size(); &#125; T&amp; front() &#123; return _c.front(); &#125; const T&amp; front() const &#123; return _c.front(); &#125; T&amp; back() &#123; return _c.back(); &#125; const T&amp; back() const &#123; return _c.back(); &#125; void push(const T&amp; x) &#123; _c.push_back(x); &#125; void pop() &#123; _c.pop_front(); &#125;private: Con _c;&#125;;template &lt;class T, class Con = std::vector&lt;T&gt;, class Compare = std::less&lt;T&gt;&gt;class Priority_Queue &#123;public: Priority_Queue() &#123;&#125; template &lt;class Iterator&gt; Priority_Queue(Iterator first, Iterator last) : c(first, last) &#123; // 将c中的元素调整成堆的结构 for (int i = (c.size() - 2) / 2; i &gt;= 0; i--) &#123; AdjustDown(i); &#125; &#125; bool empty() const &#123; return c.empty(); &#125; size_t size() const &#123; return c.size(); &#125; // 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性 const T&amp; top() const &#123; return c.front(); &#125; void push(const T&amp; data) &#123; c.push_back(data); AdjustUP(c.size() - 1); &#125; void pop() &#123; if (!empty()) &#123; std::swap(c.front(), c.back()); c.pop_back(); AdjustDown(0); &#125; &#125;private: // 向上调整 void AdjustUP(int i) &#123; int parent = ((i - 1) / 2); while (i &amp;&amp; Compare()(c[parent], c[i])) &#123; std::swap(c[i], c[parent]); i = parent; parent = ((i - 1) / 2); &#125; &#125; // 向下调整 void AdjustDown(int parent) &#123; int child = parent * 2 + 1; while (child &lt; c.size()) &#123; // 找以parent为根的较大（默认less比较规则）的孩子 if (child + 1 &lt; c.size() &amp;&amp; Compare()(c[child], c[child + 1])) &#123; child += 1; &#125; // 检测双亲是否满足情况 if (Compare()(c[parent], c[child])) &#123; std::swap(c[child], c[parent]); parent = child; child = parent * 2 + 1; continue; &#125; return; &#125; &#125;private: Con c;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"stl","slug":"stl","permalink":"https://ranjiahao.github.io/tags/stl/"}]},{"title":"list模拟实现","slug":"list模拟实现","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-29T16:00:00.000Z","comments":true,"path":"2020/03/30/list模拟实现/","link":"","permalink":"https://ranjiahao.github.io/2020/03/30/list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;assert.h&gt;#include &lt;initializer_list&gt;template &lt;typename T&gt;struct ListNode &#123; ListNode(const T&amp; val = T()) : _prev(nullptr) , _next(nullptr) , _data(val) &#123;&#125; ListNode&lt;T&gt;* _prev; ListNode&lt;T&gt;* _next; T _data;&#125;;// 三个模板参数可以兼容普通迭代器和const迭代器template &lt;typename T, typename Ptr, typename Ref&gt;struct _ListIterator &#123; typedef ListNode&lt;T&gt; Node; typedef _ListIterator&lt;T, Ptr, Ref&gt; Self; _ListIterator(Node* node = nullptr) : _node(node) &#123;&#125; Ref operator*() &#123; return _node-&gt;_data; &#125; Ptr operator-&gt;() &#123; return &amp;(_node-&gt;_data); &#125; // ++iterator Self&amp; operator++() &#123; _node = _node-&gt;_next; return *this; &#125; // iterator++ Self operator++(int) &#123; Self tmp(*this); _node = _node-&gt;_next; return tmp; &#125; // --iterator Self&amp; operator--() &#123; _node = _node-&gt;_prev; return *this; &#125; // iterator-- Self operator--(int) &#123; Self tmp(*this); _node = _node-&gt;_prev; return tmp; &#125; bool operator!=(const Self&amp; it) &#123; return _node != it._node; &#125; bool operator==(const Self&amp; it) &#123; return _node == it._node; &#125; Node* _node;&#125;;template &lt;typename T&gt;class List &#123;public: typedef ListNode&lt;T&gt; Node; typedef _ListIterator&lt;T, T*, T&amp;&gt; iterator; typedef _ListIterator&lt;T, const T*, const T&amp;&gt; const_iterator; List() : _head(new Node) &#123; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125; List(size_t n, const T&amp; val = T()) : List() &#123; while (n--) &#123; push_back(val); &#125; &#125; List(const List&lt;T&gt;&amp; lst) : List() &#123; for (const auto&amp; e : lst) &#123; push_back(e); &#125; &#125; List(List&lt;T&gt;&amp;&amp; lst) : List() &#123; std::swap(_head, lst._head); &#125; List(const std::initializer_list&lt;T&gt;&amp; lst) : List() &#123; for (const auto&amp; e : lst) &#123; push_back(e); &#125; &#125; List&lt;T&gt;&amp; operator=(List&lt;T&gt; lst) &#123; std::swap(_head, lst._head); return *this; &#125; ~List() &#123; if (_head) &#123; clear(); delete _head; _head = nullptr; &#125; &#125; iterator begin() &#123; return iterator(_head-&gt;_next); &#125; iterator end() &#123; return iterator(_head); &#125; const_iterator begin() const &#123; return const_iterator(_head-&gt;_next); &#125; const_iterator end() const &#123; return const_iterator(_head); &#125; bool empty() const &#123; return size() == 0; &#125; size_t size() const &#123; Node* cur = _head-&gt;_next; int size = 0; while (cur != _head) &#123; ++size; cur = cur-&gt;_next; &#125; return size; &#125; void push_front(const T&amp; val) &#123; insert(begin(), val); &#125; void pop_front() &#123; erase(begin()); &#125; void push_back(const T&amp; val) &#123; insert(end(), val); &#125; void pop_back() &#123; erase(--end()); &#125; iterator insert(iterator pos, const T&amp; val) &#123; Node* cur = pos._node; Node* prev = cur-&gt;_prev; Node* newNode = new Node(val); newNode-&gt;_next = cur; newNode-&gt;_prev = prev; cur-&gt;_prev = newNode; prev-&gt;_next = newNode; return --pos; &#125; // 删除：迭代器会失效，返回下一个元素的位置 iterator erase(iterator pos) &#123; assert(pos != end()); Node* cur = pos._node; Node* prev = cur-&gt;_prev; Node* next = cur-&gt;_next; prev-&gt;_next = next; next-&gt;_prev = prev; delete cur; cur = nullptr; pos = iterator(next); return pos; &#125; void swap(List&amp; lst) &#123; std::swap(_head, lst._head); &#125; void clear() &#123; if (_head) &#123; Node* cur = _head-&gt;_next; while (cur != _head) &#123; Node* next = cur-&gt;_next; delete cur; cur = next; &#125; _head-&gt;_next = _head; _head-&gt;_prev = _head; &#125; &#125;private: Node* _head;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"stl","slug":"stl","permalink":"https://ranjiahao.github.io/tags/stl/"}]},{"title":"vector模拟实现","slug":"vector模拟实现","date":"2020-03-17T16:00:00.000Z","updated":"2020-03-17T16:00:00.000Z","comments":true,"path":"2020/03/18/vector模拟实现/","link":"","permalink":"https://ranjiahao.github.io/2020/03/18/vector%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;initializer_list&gt;#include &lt;assert.h&gt;template &lt;typename T&gt;class Vector &#123;public: typedef T* iterator; typedef const T* const_iterator; Vector(); Vector(size_t n, const T&amp; value = T()); Vector(const Vector&lt;T&gt;&amp; v); Vector(Vector&lt;T&gt;&amp;&amp; v); Vector(const std::initializer_list&lt;T&gt;&amp; lst); ~Vector(); Vector&lt;T&gt;&amp; operator=(Vector&lt;T&gt; v); iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; size_t size() const; void resize(size_t n, const T&amp; val = T()); size_t capacity() const; bool empty() const; void reserve(size_t n); T&amp; operator[](size_t pos); const T&amp; operator[](size_t pos) const; void push_back(const T&amp; val); void pop_back(); iterator insert(iterator pos, const T&amp; val); iterator erase(iterator pos); void swap(Vector&lt;T&gt;&amp; v); void clear();private: T* _start = nullptr; T* _finish = nullptr; T* _endOfStorage = nullptr;&#125;;template &lt;typename T&gt;Vector&lt;T&gt;::Vector() : _start(nullptr) , _finish(nullptr) , _endOfStorage(nullptr) &#123;&#125;template &lt;typename T&gt;Vector&lt;T&gt;::Vector(size_t n, const T&amp; value) : Vector() &#123; reserve(n); while (n--) &#123; push_back(value); &#125;&#125;template &lt;typename T&gt;Vector&lt;T&gt;::Vector(const Vector&lt;T&gt;&amp; v) : _start(new T[v.capacity()]) , _finish(_start + v.size()) , _endOfStorage(_start + v.capacity()) &#123; for (size_t i = 0; i &lt; v.size(); i++) &#123; _start[i] = v[i]; &#125;&#125;template&lt;typename T&gt;Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; v) : Vector() &#123; swap(v);&#125;template&lt;typename T&gt;Vector&lt;T&gt;::Vector(const std::initializer_list&lt;T&gt;&amp; lst) : _start(new T[lst.size()]) , _finish(_start) , _endOfStorage(_start + lst.size()) &#123; for (const auto&amp; e : lst) &#123; *_finish = e; ++_finish; &#125;&#125;template &lt;typename T&gt;Vector&lt;T&gt;::~Vector() &#123; if (_start) &#123; delete[] _start; _start = _finish = _endOfStorage = nullptr; &#125;&#125;template &lt;typename T&gt;Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(Vector&lt;T&gt; v) &#123; swap(v); return *this;&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::iterator Vector&lt;T&gt;::begin() &#123; return _start;&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::const_iterator Vector&lt;T&gt;::begin() const &#123; return _start;&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::iterator Vector&lt;T&gt;::end() &#123; return _finish;&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::const_iterator Vector&lt;T&gt;::end() const &#123; return _finish;&#125;template &lt;typename T&gt;size_t Vector&lt;T&gt;::size() const &#123; return _finish - _start;&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::resize(size_t n, const T&amp; val) &#123; if (n &lt;= size()) &#123; _finish = _start + n; &#125; else &#123; if (n &gt; capacity()) &#123; reserve(n); &#125; while (_finish &lt; _start + n) &#123; *_finish++ = val; &#125; &#125;&#125;template &lt;typename T&gt;size_t Vector&lt;T&gt;::capacity() const &#123; return _endOfStorage - _start;&#125;template&lt;typename T&gt;bool Vector&lt;T&gt;::empty() const &#123; return size() == 0;&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::reserve(size_t n) &#123; size_t size = this-&gt;size(); if (n &gt; capacity()) &#123; T* tmp = new T[n]; if (_start) &#123; for (size_t i = 0; i &lt; this-&gt;size(); i++) &#123; tmp[i] = _start[i]; &#125; &#125; _start = tmp; _finish = _start + size; _endOfStorage = _start + n; &#125;&#125;template &lt;typename T&gt;T&amp; Vector&lt;T&gt;::operator[](size_t pos) &#123; assert(pos &lt; size()); return _start[pos];&#125;template &lt;typename T&gt;const T&amp; Vector&lt;T&gt;::operator[](size_t pos) const &#123; assert(pos &lt; size()); return _start[pos];&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(const T&amp; val) &#123; insert(end(), val);&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::pop_back() &#123; assert(!empty()); erase(end() - 1);&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::iterator Vector&lt;T&gt;::insert(iterator pos, const T&amp; val) &#123; assert(pos &gt;= begin() &amp;&amp; pos &lt;= end()); size_t len = pos - _start; if (_finish == _endOfStorage) &#123; // 实际会根据一定算法开辟空间 size_t newC = capacity() == 0 ? 1 : 2 * capacity(); reserve(newC); &#125; // 更新迭代器，增容导致迭代器失效 pos = _start + len; iterator end = _finish; while (end &gt; pos) &#123; *end = *(end - 1); --end; &#125; *pos = val; ++_finish; return pos;&#125;template &lt;typename T&gt;typename Vector&lt;T&gt;::iterator Vector&lt;T&gt;::erase(iterator pos) &#123; assert(pos &lt; _finish &amp;&amp; pos &gt;= _start); iterator begin = pos + 1; while (begin &lt; _finish) &#123; *(begin - 1) = *begin; ++begin; &#125; --_finish; // 删除导致迭代器失效，返回下一个元素的位置 return pos;&#125;template &lt;typename T&gt;void Vector&lt;T&gt;::swap(Vector&lt;T&gt;&amp; v) &#123; std::swap(_start, v._start); std::swap(_finish, v._finish); std::swap(_endOfStorage, v._endOfStorage);&#125;template&lt;typename T&gt;void Vector&lt;T&gt;::clear() &#123; _finish = _start;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"stl","slug":"stl","permalink":"https://ranjiahao.github.io/tags/stl/"}]},{"title":"string模拟实现","slug":"string模拟实现","date":"2020-03-15T16:00:00.000Z","updated":"2020-03-15T16:00:00.000Z","comments":true,"path":"2020/03/16/string模拟实现/","link":"","permalink":"https://ranjiahao.github.io/2020/03/16/string%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268// string.h#include &lt;iostream&gt;#include &lt;assert.h&gt; class String &#123;public: friend std::istream&amp; operator&gt;&gt;(std::istream&amp; _cin, String&amp; s); friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; _cout, const String&amp; s); typedef char* Iterator; typedef const char* const_Iterator; String(const String&amp; s); String(const char* str = \"\"); String(String&amp;&amp; s); ~String(); String&amp; operator=(String s); Iterator begin(); const_Iterator begin() const; Iterator end(); const_Iterator end() const; size_t size() const; void resize(size_t n, char c = '\\0'); size_t capacity() const; void reserve(size_t n); void clear(); bool empty() const; char&amp; operator[](size_t pos); const char&amp; operator[](size_t pos) const; String&amp; operator+=(const String&amp; s); String&amp; operator+=(const char* str); String&amp; operator+=(char c); String&amp; insert(size_t pos, const char* str); String&amp; insert(size_t pos, size_t n, const char c); String&amp; erase(size_t pos, size_t n); void swap(String&amp; s); char* c_str() const; size_t find(const char* str, size_t pos = 0) const; size_t find_first_of(char c, size_t pos = 0) const; static size_t npos;private: size_t _size; size_t _capacity; char* _str;&#125;;// string.cc#include \"string.h\"std::istream&amp; operator&gt;&gt;(std::istream&amp; _cin, String&amp; s) &#123; for (char c = _cin.get(); !isspace(c); _cin.get(c)) &#123; s += c; &#125; return _cin;&#125;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; _cout, const String&amp; s) &#123; _cout &lt;&lt; s._str; return _cout;&#125;String::String(const String&amp; s) : _size(0) , _capacity(0) , _str(nullptr) &#123; String tmp(s._str); swap(tmp);&#125;String::String(const char* str) : _size(strlen(str)) , _capacity(_size) , _str(new char[_capacity + 1]) &#123; strcpy(_str, str);&#125;String::String(String&amp;&amp; s) : String() &#123; swap(s);&#125;String::~String() &#123; if (_str) &#123; delete[] _str; _str = nullptr; _size = 0; _capacity = 0; &#125;&#125;String&amp; String::operator=(String s) &#123; swap(s); return *this;&#125;String::Iterator String::begin() &#123; return _str;&#125;String::const_Iterator String::begin() const &#123; return _str;&#125;String::Iterator String::end() &#123; return _str + _size;&#125;String::const_Iterator String::end() const &#123; return _str + _size;&#125;size_t String::size() const &#123; return _size;&#125;void String::resize(size_t n, char c) &#123; if (n &lt; _size) &#123; _size = n; _str[_size] = '\\0'; &#125; else &#123; if (n &gt; _capacity) &#123; reserve(n); &#125; for (size_t i = _size; i &lt; n; i++) &#123; _str[i] = c; &#125; _size = n; _str[_size] = '\\0'; &#125;&#125;size_t String::capacity() const &#123; return _capacity;&#125;void String::reserve(size_t n) &#123; if (n &gt; _capacity) &#123; char* tmp = new char[n + 1]; // 实际会根据一定算法开辟空间 if (_str) &#123; strcpy(tmp, _str); delete[] _str; &#125; _str = tmp; _capacity = n; &#125;&#125;void String::clear() &#123; _size = 0; _str[_size] = '\\0';&#125;bool String::empty() const &#123; return _size == 0;&#125;char&amp; String::operator[](size_t pos) &#123; assert(pos &lt;= _size); return _str[pos];&#125;const char&amp; String::operator[](size_t pos) const &#123; assert(pos &lt;= _size); return _str[pos];&#125;String&amp; String::operator+=(const String&amp; s) &#123; insert(_size, s._str); return *this;&#125;String&amp; String::operator+=(const char* str) &#123; insert(_size, str); return *this;&#125;String&amp; String::operator+=(char c) &#123; insert(_size, 1, c);&#125;String&amp; String::insert(size_t pos, const char* str) &#123; assert(pos &lt;= _size); int len = strlen(str); if (_size + len &gt; _capacity) &#123; reserve(_size + len); &#125; size_t end = _size + len; while (end &gt; pos + len - 1) &#123; _str[end] = _str[end - len]; --end; &#125; while (*str) &#123; _str[pos++] = *str++; &#125; _size += len; return *this;&#125;String&amp; String::insert(size_t pos, size_t n, const char c) &#123; assert(pos &lt;= _size); if (_size + n &gt; _capacity) &#123; reserve(_size + n); &#125; size_t end = _size + n; while (end &gt; pos + n - 1) &#123; _str[end] = _str[end - n]; --end; &#125; for (size_t i = 0; i &lt; n; ++i) &#123; _str[pos++] = c; &#125; _size += n; return *this;&#125;String&amp; String::erase(size_t pos, size_t n) &#123; assert(pos &lt; _size); if (n &gt;= _size - pos) &#123; _size = pos; _str[_size] = '\\0'; &#125; else &#123; size_t begin = pos + n; while (begin &lt;= _size) &#123; _str[pos++] = _str[begin]; ++begin; &#125; _size -= n; &#125; return *this;&#125;void String::swap(String&amp; s) &#123; std::swap(_str, s._str); std::swap(_size, s._size); std::swap(_capacity, s._capacity);&#125;char* String::c_str() const &#123; return _str;&#125;size_t String::find(const char* str, size_t pos) const &#123; char* ret = strstr(_str + pos, str); if (ret != NULL) &#123; return ret - _str; &#125; else &#123; return npos; &#125;&#125;size_t String::find_first_of(char c, size_t pos) const &#123; for (size_t i = pos; i &lt; _size; i++) &#123; if (_str[i] == c) &#123; return i; &#125; &#125; return npos;&#125;size_t String::npos = -1;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"stl","slug":"stl","permalink":"https://ranjiahao.github.io/tags/stl/"}]},{"title":"模板总结","slug":"模板总结","date":"2020-03-12T16:00:00.000Z","updated":"2020-03-12T16:00:00.000Z","comments":true,"path":"2020/03/13/模板总结/","link":"","permalink":"https://ranjiahao.github.io/2020/03/13/%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/","excerpt":"","text":"定义template开始，后跟一个模板参数列表（在模板定义中，模板参数列表不能为空）typename是用来定义模板参数关键字（C++98之后），也可以 使用class(切记：不能使用struct代替class) 实例化隐式实例化：让编译器根据实参推演模板参数的实际类型，编译器一般不会进行类型转换操作，形参和实参类型必须完全匹配显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型。如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错 非类型模板参数用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用浮点数、类对象以及字符串不可作为非类型模板参数非类型的模板参数必须在编译期就能确认结果 模板参数的匹配原则对于非模板函数和同名函数模板，如果其他条件都相同，在隐式实例化时会优先调用非模板函数，不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板。模板函数不允许自动类型转换，但普通函数可以进行自动类型转换 函数模板特化1234567891011121314// 必须要先有一个基础的函数模板template&lt;class T&gt;bool IsEqual(T&amp; left, T&amp; right) &#123; return left == right;&#125;// 关键字template后面接一对空的尖括号&lt;&gt;，函数名后跟一对尖括号，尖括号中指定需要特化的类型template&lt;&gt;bool IsEqual&lt;char*&gt;(char*&amp; left, char*&amp; right) &#123; // 函数形参表必须和模板函数的基础参数类型相同 if (strcmp(left, right) == 0) return true; return false;&#125;一般情况下为了实现简单通常都是将函数直接给出 类模板类模板中函数放在类外进行定义时，需要加模板参数列表类模板实例化需要在类模板名字后跟&lt;&gt;，实例化的类型放在&lt;&gt;中，类模板名字不是真正的类，而实例化的结果才是真正的类 类模板特化1234567891011121314template&lt;typename T1, typename T2&gt;class Data &#123;&#125;;// 全特化template&lt;&gt;class Data&lt;int, char&gt; &#123;&#125;;// 部分特化template&lt;typename T1&gt;class Data&lt;T1, int&gt; &#123;&#125;;// 限制特化template&lt;typename T1, typename T2&gt;class Data&lt;T1*, T2*&gt; &#123;&#125;; 类型萃取实现Copy函数，使其可以拷贝任意类型单使用memcpy，可以拷贝内置类型，如果涉及到深拷贝(比如string)，就会出错单使用循环赋值，效率很低通过增加bool参数判断是否内置类型，就可将两种拷贝的优势结合。但用户需要根据所拷贝元素的类型传递第三个参数，那出错的可能性就增加所以需要通过类型萃取来判断是否内置类型，但需要将所有类型遍历一遍，每次比较都是字符串的比较，效率比较低12345678910111213141516171819bool IsPODType(const char* strType) &#123; const char* arrType[] = &#123; \"char\", \"short\", \"int\", \"long\", \"long long\", \"float\",\"double\", \"long double\" &#125;; for (size_t i = 0; i &lt; sizeof(arrType) / sizeof(arrType[0]); ++i) &#123; if (strcmp(strType, arrType[i]) == 0) return true; &#125; return false;&#125;template&lt;class T&gt;void Copy(T* dst, const T* src, size_t size) &#123; if (IsPODType(typeid(T).name())) // RTTI memcpy(dst, src, sizeof(T)*size); else &#123; for (size_t i = 0; i &lt; size; ++i) dst[i] = src[i]; &#125;&#125;类型萃取一般写法：123456789101112131415161718192021222324252627282930313233343536// 内置类型struct TrueType &#123; static bool Get() &#123; return true; &#125;&#125;;// 代表自定义类型struct FalseType &#123; static bool Get() &#123; return false; &#125;&#125;;template&lt;class T&gt;struct TypeTraits &#123; typedef FalseType IsPODType;&#125;;template&lt;&gt;struct TypeTraits&lt;char&gt; &#123; typedef TrueType IsPODType;&#125;;template&lt;&gt;struct TypeTraits&lt;int&gt; &#123; typedef TrueType IsPODType;&#125;;// ... 将所有内置类型都特化template&lt;class T&gt;void Copy(T* dst, const T* src, size_t size) &#123; if (TypeTraits&lt;T&gt;::IsPODType::Get()) // RTTI memcpy(dst, src, sizeof(T) * size); else &#123; for (size_t i = 0; i &lt; size; ++i) dst[i] = src[i]; &#125;&#125;stl中写法：123456789101112131415161718192021222324252627282930313233343536struct TrueType &#123;&#125;;struct FalseType &#123;&#125;;template &lt;class T&gt;struct TypeTraits &#123; typedef FalseType IsPodType;&#125;;template&lt;&gt;struct TypeTraits&lt;char&gt; &#123; typedef TrueType IsPODType;&#125;; template&lt;&gt;struct TypeTraits&lt;int&gt; &#123; typedef TrueType IsPODType;&#125;;// ... 将所有内置类型都特化，包括有符号和无符号，比如：对于int类型，必须特化三个，int、signed int、unsigned int template &lt;class T&gt;void _Copy(T* dst, T* src, size_t size, TrueType) &#123; memcpy(dst, src, sizeof(T)* size);&#125; template &lt;class T&gt;void _Copy(T* dst, T* src, size_t size, FalseType) &#123; for (size_t i = 0; i &lt; size; ++i) &#123; dst[i] = src[i]; &#125;&#125;template &lt;class T&gt;void Copy(T* dst, T* src, size_t size) &#123; _Copy(dst, src, size, TypeTraits&lt;T&gt;::IsPodType()); // RTTI&#125; 模板分离编译如果将模板的声明放在.h文件中，将其定义放在其他.cpp中，在main.cpp中实例化就会出现链接错误因为头文件不参与编译，编译器对工程中的多个源文件单独编译，然后将多个obj文件链接在定义的.cpp文件中编译器找不到对模板的实例化，不会生成对应的函数所以在main.cpp中call找不到对应函数的地址有两种方法可以解决：将声明和定义放到一个文件 “xxx.hpp” 里面或者xxx.h其实也是可以的模板定义的位置显式实例化，这种方法不推荐使用 总结模板复用了代码，更快迭代开发，增强了代码的灵活性，但是会导致代码膨胀问题，编译时间变长，出现模板编译错误时，不易定位错误","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://ranjiahao.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"类型萃取","slug":"类型萃取","permalink":"https://ranjiahao.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96/"}]},{"title":"C++引用详解","slug":"C++引用详解","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-07T16:00:00.000Z","comments":true,"path":"2020/03/08/C++引用详解/","link":"","permalink":"https://ranjiahao.github.io/2020/03/08/C++%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"引用变量引用是已定义的变量的别名，它和它引用的变量共用同一块内存空间其主要用途是用作函数的形参，通过这种用法使用原始数据而不是副本引用在定义时必须初始化一个变量可以有多个引用引用一旦引用一个实体，再不能引用其他实体 临时变量如果引用参数是const，则编译器将在下面两种情况下生成临时变量：1234567int main() &#123; const int&amp; a = 1 + 3; // 1. 实参类型正确，但不是左值 // int&amp; a = 1 + 3; 错误 const int&amp; b = 3.14; // 2. 实参类型不正确，但可以转换成正确类型 // int&amp; b = 3.14; 错误 return 0;&#125;这两种情况下编译器都生成一个临时匿名变量，这些临时变量出了作用域后自动消失为什么常量引用这种行为可以，其他情况不行？从编译器的角度来看，不难发现，如果不加const显然就有可能对变量进行修改，如果此时引用了临时变量，就无法对原来的变量进行修改，所以编译器默认只能用const的引用来指向临时变量 引用和指针语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间；底层实现上实际是有空间的，因为引用是按照指针方式来实现的int a = 0; int&amp; ra = a; ra = 1;int a = 0; int* pa = &amp;a; *a = 1;这两段代码的反汇编是一模一样的 C++11右值引用C++11中，右值分为纯右值和将亡值临时变量，常量、一些运算表达式(1+3)等叫纯右值声明周期将要结束的对象叫将亡值右值引用只能指向右值，使用&amp;&amp;声明，定义时必须初始化左值引用可以引用左值，也可以引用右值12345// 纯右值int&amp;&amp; a = 3 + 1;int&amp;&amp; b = 3.14 + 3;cout &lt;&lt; a &lt;&lt; endl; // 4cout &lt;&lt; b &lt;&lt; endl; // 6123456789// 演示将亡值String GetString(char* pStr) &#123; String strTemp(pStr); return strTemp;&#125;void test() &#123; String s1(GetString(\"hehe\"));&#125;编译器用调用GetString，创造一个匿名对象strTemp，返回的临时对像（可能会优化成直接返回）若String类中未写右值引用版本拷贝构造，则默认使用左值引用版本重新拷贝一份资源给s1，然后释放临时对象。这样就造成不必要的拷贝在string类中加入以下函数即可优化上述步骤：12345678String(String&amp;&amp; s) : _str(s._str) , _size(s._size) , _capacity(s._capacity) &#123; s._str = nullptr; s._size = 0; s._capacity = 0;&#125; 默认移动构造/赋值编译器隐式生成一个(如果没有用到则不会生成)移动构造函数，如果声明了移动构造或拷贝构造或移动赋值，则编译器不会生成默认版本。编译器生成的默认移动构造函数是浅拷贝同理，编译器默认生成移动赋值，如果声明了移动赋值或赋值运算符重载或移动构造，则编译器不会生成默认版本注意：在C++11中，拷贝构造/移动构造/赋值/移动赋值函数必须提供，或者同时不提供，程序才能保证类同时具有拷贝和移动语义 move()将一个左值强制转化为右值引用，搭配移动构造使用，可以达到类似对象数据转移的效果如果将移动构造函数声明为常右值引用或者返回右值的函数声明为常量，都会导致移动语义无法实现 完美转发函数模板在向其他函数传递自身形参时，如果相应实参是左值，它就应该被转发为左值；如果相应实参是右值，它就应该被转发为右值。C++11通过forward函数实现：123456789101112131415161718void Fun(int&amp; x) &#123; cout &lt;&lt; \"lvalue ref\" &lt;&lt; endl; &#125;void Fun(int&amp;&amp; x) &#123; cout &lt;&lt; \"rvalue ref\" &lt;&lt; endl; &#125;void Fun(const int&amp; x) &#123; cout &lt;&lt; \"const lvalue ref\" &lt;&lt; endl; &#125;void Fun(const int&amp;&amp; x) &#123; cout &lt;&lt; \"const rvalue ref\" &lt;&lt; endl; &#125;template&lt;typename T&gt;void PerfectForward(T&amp;&amp; t) &#123; Fun(std::forward&lt;T&gt;(t)); &#125;int main() &#123; PerfectForward(10); // rvalue ref int a; PerfectForward(a); // lvalue ref PerfectForward(std::move(a)); // rvalue ref const int b = 1; PerfectForward(b); // const lvalue ref PerfectForward(std::move(b)); // const rvalue ref return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"右值引用","slug":"右值引用","permalink":"https://ranjiahao.github.io/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"name":"完美转发","slug":"完美转发","permalink":"https://ranjiahao.github.io/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"}]},{"title":"C++11 lambda表达式","slug":"lambda表达式","date":"2020-03-05T16:00:00.000Z","updated":"2020-03-05T16:00:00.000Z","comments":true,"path":"2020/03/06/lambda表达式/","link":"","permalink":"https://ranjiahao.github.io/2020/03/06/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"C++11 lambda表达式如果想要对一个数据集合中的元素进行排序，可以使用std::sort方法但在想要自定义比较规则时必须提供仿函数对象C++11 中lambda表达式可以简化这个过程：1234567891011121314151617181920212223242526272829class AAA &#123;public: AAA(int a, int b) &#123; _a = a; _b = b; &#125; int _a; int _b;&#125;;class Greater &#123;public: bool operator()(const AAA&amp; a, const AAA&amp; b) &#123; return a._a &gt; b._a; &#125;&#125;;int main() &#123; vector&lt;AAA&gt; v&#123; &#123;1, 3&#125;, &#123;6, 7&#125; , &#123;4, 1&#125; &#125;; // 必须提供仿函数的比较方法 sort(v.begin(), v.end(), Greater()); sort(v.begin(), v.end(), [](AAA&amp; a, AAA&amp; b)-&gt;bool &#123; return a._a &gt; b._a; &#125;); for (auto&amp; e : v) cout &lt;&lt; e._a &lt;&lt; \" \"; return 0;&#125;lambda表达式是一个匿名函数，可借助auto将其赋值给一个变量，然后调用 表达式格式[捕捉列表] (参数列表) mutable -&gt; 返回值类型 { 函数体 }[]捕捉列表获取父作用域的变量，供函数使用，编译器根据[]来判断接下来的代码是否为lambda函数[a, b]: 以值的形式获取父作用域的变量a,b[=]: 以值的形式获取父作用域的所有变量, 变量的属性都为const(包括this)[=, a]: 错误写法，捕捉a重复[=, &amp;a]: 正确写法，除了a，其他以值的形式获取父作用域变量， a以引用的形式获取[&amp;] : 以引用的形式获取父作用域的所有变量，(包括this)[this]: 获取成员变量的this指针，只能在成员函数内部使用()参数列表如果不需要参数传递，则可以连同()一起省略mutable可选，删除捕捉列表中以值的形式获取的变量的const属性，使用该修饰符时，参数列表不可省略(即使参数为空)-&gt;返回值类型用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导{}函数体在函数体内，可以使用参数外，以及所有捕获到的变量。使用注意事项在块作用域以外的lambda函数捕捉列表必须为空在块作用域中的lambda函数仅能捕捉父作用域中局部变量1234567891011void (*PF)();int main() &#123; auto f1 = []&#123;cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125;; auto f2 = []&#123;cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125;; //f1 = f2; // 编译失败---&gt;提示找不到operator=() lambda表达式之间不能相互赋值 // 允许使用一个lambda表达式拷贝构造一个新的副本 auto f3(f2); // 可以将lambda表达式赋值给相同类型的函数指针 PF = f2; return 0;&#125;lambda底层通过汇编我们可以清楚的看到，编译器会自动生成一个类，在其中重载了operator() C++11 autoC++11中，auto声明的变量可以由编译器在编译时期推导而得，可以与lambda表达式，或范围for搭配使用使用auto时必须进行初始化，编译阶段需根据初始化表达式来推导auto的实际类型auto是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;声明多个变量时，变量必须类型相同，否则会报错，编译器只对第一个进行推导，然后用推导出来的类型定义其他变量auto不能作为函数的参数，不能直接用来声明数组，不能定义类的非静态成员变量实例化模板时不能使用auto作为模板参数 C++11 decltype根据表达式的实际类型推演出定义变量时所用的类型12345678910111213void Fuc(int i) &#123;&#125;int main() &#123; int a = 10; int b = 20; // 用decltype推演a+b的实际类型，作为定义c的类型 decltype(a+b) c; // 如果没有带参数，推导函数的类型 cout &lt;&lt; typeid(decltype(Fuc)).name() &lt;&lt; endl; // 如果带参数列表，推导的是函数返回值的类型，此处只推演，不会执行函数 cout &lt;&lt; typeid(decltype(Fuc(0))).name() &lt;&lt; endl; return 0;&#125; C++11 基于范围的for循环for循环迭代的范围必须是确定的，对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end方法，begin和end就是for循环迭代的范围1234567void Test(int arr[]) &#123; for(auto&amp; e : arr) // arr为指针，编译器并不知道数组的范围所以报错 cout &lt;&lt; e &lt;&lt; endl; int array[] = &#123; 1, 2, 3, 4, 5 &#125;; for(auto&amp; e : array) cout &lt;&lt; e &lt;&lt; \" \"; // ok&#125;迭代的对象要实现++和==的操作","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://ranjiahao.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"auto","slug":"auto","permalink":"https://ranjiahao.github.io/tags/auto/"},{"name":"decltype","slug":"decltype","permalink":"https://ranjiahao.github.io/tags/decltype/"},{"name":"范围for","slug":"范围for","permalink":"https://ranjiahao.github.io/tags/%E8%8C%83%E5%9B%B4for/"}]},{"title":"设计一个类，只能在栈/堆上创建对象","slug":"设计一个只能在栈或堆上创建对象的类","date":"2020-03-02T16:00:00.000Z","updated":"2020-03-02T16:00:00.000Z","comments":true,"path":"2020/03/03/设计一个只能在栈或堆上创建对象的类/","link":"","permalink":"https://ranjiahao.github.io/2020/03/03/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E6%88%96%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB/","excerpt":"","text":"设计一个类，只能在栈/堆上创建对象123456789101112131415161718192021222324252627282930313233343536373839class HeapOnly &#123;public: static HeapOnly* CreateObject() &#123; return new HeapOnly; &#125;private: // 将构造函数私有化 HeapOnly() &#123;&#125; // 防拷贝 HeapOnly(const HeapOnly&amp;); // 防拷贝C++11写法 // HeapOnly(const HeapOnly&amp;) = delete;&#125;;class HeapOnly &#123;public: HeapOnly() &#123;&#125; void Destory() &#123; delete this; &#125;private: // 如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存 ~HeapOnly() &#123;&#125;&#125;;class StackOnly &#123;public: static StackOnly CreateObject() &#123; return StackOnly(); &#125;private: StackOnly() &#123;&#125;&#125;;class StackOnly &#123;public: StackOnly() &#123;&#125;private: void* operator new(size_t size); void operator delete(void* p);&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[]},{"title":"实现date类","slug":"实现date类","date":"2020-02-29T16:00:00.000Z","updated":"2020-02-29T16:00:00.000Z","comments":true,"path":"2020/03/01/实现date类/","link":"","permalink":"https://ranjiahao.github.io/2020/03/01/%E5%AE%9E%E7%8E%B0date%E7%B1%BB/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210// date.h#pragma once#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;using std::istream;using std::ostream;class Date &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);public: inline int GetMonthDay(int year, int month) const &#123; static int monthArray[13] = &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;; if ((month == 2) &amp;&amp; ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))) &#123; return 29; &#125; return monthArray[month]; &#125; Date(int year = 1900, int month = 1, int day = 1); int operator-(const Date&amp;d) const; Date&amp; operator++(); // 前置++ Date operator++(int); // 后置++ Date&amp; operator--(); // 前置-- Date operator--(int); // 后置-- Date operator+(int day) const; Date operator-(int day) const; Date&amp; operator+=(int day); Date&amp; operator-=(int day); bool operator&gt;(const Date&amp; d) const; bool operator&gt;=(const Date&amp; d) const; bool operator&lt;(const Date&amp; d) const; bool operator&lt;=(const Date&amp; d) const; bool operator==(const Date&amp; d) const; bool operator!=(const Date&amp; d) const;private: int _year; int _month; int _day;&#125;;// date.cpp#include \"Date.h\"Date::Date(int year, int month, int day) &#123; if (year &gt;= 1900 &amp;&amp; month &gt; 0 &amp;&amp; month &lt; 13 &amp;&amp; day &gt; 0 &amp;&amp; day &lt;= GetMonthDay(year, month)) &#123; _year = year; _month = month; _day = day; &#125; else &#123; cout &lt;&lt; \"Input illegal,reset to default value\" &lt;&lt; endl; _year = 1900; _month = 1; _day = 1; &#125;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d) &#123; _cout &lt;&lt; d._year &lt;&lt; \"-\" &lt;&lt; d._month &lt;&lt; \"-\" &lt;&lt; d._day &lt;&lt; endl; return _cout;&#125;istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d) &#123; int year; int month; int day; _cin &gt;&gt; year; _cin &gt;&gt; month; _cin &gt;&gt; day; // new(&amp;d)Date(year, month, day); d = Date(year, month, day); return _cin;&#125;int Date::operator-(const Date&amp; d) const &#123; Date maxdate(*this); Date mindate(d); int flag = 1; if (*this &lt; d) &#123; maxdate = d; mindate = *this; flag = -1; &#125; int days = 0; while (mindate != maxdate) &#123; ++mindate; ++days; &#125; return days * flag;&#125;// ++d 前置++Date&amp; Date::operator++() &#123; *this += 1; return *this;&#125;// d++ 后置++Date Date::operator++(int) &#123; Date ret(*this); *this += 1; return ret;&#125;// --d 前置--Date&amp; Date::operator--() &#123; *this -= 1; return *this;&#125;// d-- 后置--Date Date::operator--(int) &#123; Date tmp(*this); *this -= 1; return tmp;&#125;Date Date::operator+(int day) const &#123; Date ret = *this; ret += day; return ret;&#125;Date Date::operator-(int day) const &#123; Date ret(*this); ret -= day; return ret;&#125;Date&amp; Date::operator+=(int day) &#123; if (day &lt; 0) &#123; return *this -= -day; &#125; _day += day; while (_day &gt; GetMonthDay(_year, _month)) &#123; _day -= GetMonthDay(_year, _month); _month++; if (_month == 13) &#123; ++_year; _month = 1; &#125; &#125; return *this;&#125;Date&amp; Date::operator-=(int day) &#123; if (day &lt; 0) &#123; return *this += -day; &#125; _day -= day; while (_day &lt;= 0) &#123; --_month; if (_month == 0) &#123; _month = 12; --_year; &#125; _day += GetMonthDay(_year, _month); &#125; return *this;&#125;bool Date::operator&gt;(const Date&amp; d) const &#123; if (_year &gt; d._year) &#123; return true; &#125; else if (_year == d._year) &#123; if (_month &gt; d._month) &#123; return true; &#125; else if (_month == d._month) &#123; if (_day &gt; d._day) &#123; return true; &#125; &#125; &#125; return false;&#125;bool Date::operator&gt;=(const Date&amp; d) const &#123; return *this &gt; d || *this == d;&#125;bool Date::operator&lt;(const Date&amp; d) const &#123; return !(*this &gt;= d);&#125;bool Date::operator&lt;=(const Date&amp; d) const &#123; return !(*this &gt; d);&#125;bool Date::operator==(const Date&amp; d) const &#123; return _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day == d._day;&#125;bool Date::operator!=(const Date&amp; d) const &#123; return !(*this == d);&#125;int main() &#123; Date date; cin &gt;&gt; date; cout &lt;&lt; date &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"date类","slug":"date类","permalink":"https://ranjiahao.github.io/tags/date%E7%B1%BB/"}]},{"title":"C++类型转换","slug":"C++类型转化","date":"2020-01-15T16:00:00.000Z","updated":"2020-01-15T16:00:00.000Z","comments":true,"path":"2020/01/16/C++类型转化/","link":"","permalink":"https://ranjiahao.github.io/2020/01/16/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/","excerpt":"","text":"static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关的类型进行转换double d = 3.14;int a = static_cast&lt;int&gt;(d); reinterpret_cast为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型12345678910typedef void (* FUNC)();void fuc(int i) &#123; cout &lt;&lt; \"void fuc(int i);\" &lt;&lt; endl;&#125;int main() &#123; // reinterpret_cast可以编译器以FUNC的定义方式去看待DoSomething函数 FUNC f = reinterpret_cast&lt;FUNC&gt;(fuc); f(); return 0;&#125; const_cast删除变量的const属性12345const int a = 1;int* p = const_cast&lt;int*&gt;(&amp;a);*p = 3;cout &lt;&lt; a &lt;&lt; endl; // 1cout &lt;&lt; *p &lt;&lt; endl; // 3 dynamic_cast只能用于含有虚函数的类，dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回012345678910111213141516171819202122class A &#123;public: virtual void f() &#123;&#125;&#125;; class B: public A &#123;&#125;; void fuc(A* pa) &#123; // dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回 B* pb1 = static_cast&lt;B*&gt;(pa); B* pb2 = dynamic_cast&lt;B*&gt;(pa); cout &lt;&lt; \"pb1:\" &lt;&lt; pb1 &lt;&lt; endl; cout &lt;&lt; \"pb2:\" &lt;&lt; pb2 &lt;&lt; endl;&#125; int main() &#123; A a; B b; fuc(&amp;a); // dynamic_cast 出错返回0 fuc(&amp;b); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://ranjiahao.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"类的六个默认成员函数","slug":"类的六个默认成员函数","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-06T16:00:00.000Z","comments":true,"path":"2020/01/07/类的六个默认成员函数/","link":"","permalink":"https://ranjiahao.github.io/2020/01/07/%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","excerpt":"","text":"构造函数构造函数是一个特殊的成员函数，名字与类名相同，无返回值，可以重载，创建对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次，其主要任务是初始化对象 使用构造函数C++提供了显式调用和隐式调用两种使用构造函数来初始化对象的方式注意：如果通过隐式调用默认构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明1234567891011121314151617class S &#123;public: S(int a = 1, string s = \"sss\") &#123; _a = a; _s = s; &#125;private: int _a; string _s;&#125;;int main() &#123; S s1 = S(3, \"Ran\"); // 显示调用 S s2(3, \"ran\"); // 隐式调用 S s3; // S s3();为函数声明 return 0;&#125; 默认构造函数无参的构造函数和全缺省的构造函数都称为默认构造函数，并且只能有一个若未显式定义构造函数，则编译器会自动生成一个无参的默认构造函数，主要作用是调用自定类型成员的默认构造，一旦用户显式定义编译器将不再生成 初始化列表构造函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，在初始化列表中,而构造函数体内可以多次赋值声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关12345678910111213141516171819202122232425class A &#123;public: A(int a) : _a(a) &#123; &#125;private: int _a;&#125;;class B &#123;public: // 冒号开始，以逗号分隔的数据成员列表， // 每个成员变量后面跟一个放在括号中的初始值或表达式 B(int a, int ref) : _aobj(a) , _ref(ref) , _n(10) &#123; &#125;private: /* 引用成员变量、const成员变量、类类型成员（该类没有默认构造函数） 必须放在初始化列表位置进行初始化 */ A _aobj; // 没有默认构造函数 int&amp; _ref; // 引用 const int _n; // const&#125;; 单参构造1234567891011121314class S &#123;public: S(int s = 1) &#123; _s = s; &#125;private: int _s;&#125;; int main() &#123; S obj; obj = 1999; // 实际编译器会构造一个无名对象，最后用无名对象给obj进行赋值 return 0;&#125;上述代码可读性不是很好，用explicit修饰构造函数，将会禁止单参构造函数的隐式转换123explicit S(int s = 1) &#123; _s = s;&#125; C++11 成员初始化C++11支持非静态成员变量在声明时进行初始化赋值，但是要注意这里不是初始化，这里是给声明的成员变量缺省值。即，如果初始化列表和声明的时候都有初始化参数，会优先使用初始化列表初始化 C++11 委派构造函数通过委派其他构造函数，使多构造函数的类编写更容易1234567891011121314151617181920212223242526272829// 委派构造函数将构造的任务委派给目标构造函数class Info &#123;public: // 目标构造函数 Info() : _a(0) , _c('a') &#123; InitRSet(); &#125; // 委派构造函数 Info(int a) : Info() &#123; _a = a; &#125; // 委派构造函数 Info(char c) : Info() &#123; _c = c; &#125;private: void InitRSet() &#123; //初始化其他变量 &#125; int _a; char _c; // ...&#125;;构造函数不能同时“委派”和使用初始化列表 拷贝构造函数本质是构造函数的一个重载形式，参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用若未显示定义，编译器自动生成默认拷贝构造函数，默认的拷贝构造函数为浅拷贝若显示定义拷贝构造，则编译器不会生成默认构造函数（拷贝构造是构造函数的重载） 析构函数无参数无返回值，一个对象只有一个析构函数若未显式定义，系统会自动生成默认的析构函数，对象在销毁时会自动调用析构函数，并对自定类型成员调用它的析构函数，完成类的一些资源清理工作如果是在栈上创建多个对象，则最后创建的对象最先被删除，最先创建的对象最后被删除注意：申请空间时候必须自己写析构函数12345678910111213141516171819202122class S &#123;public: S(int a = 1, string s = \"sss\") &#123; _a = a; _s = s; &#125; ~S() &#123; cout &lt;&lt; \"~S()\" &lt;&lt; endl; &#125;private: int _a; string _s;&#125;;int main() &#123; &#123; // 如果没有大括号，代码块将为整个main()， // 仅当main()执行完毕调析构，在窗口环境中可能无法看到~S() S s = S(); &#125; return 0;&#125;输出结果 ~S()某些编译器可能输出两个 ~S()C++标准允许编译器使用两种方式来执行S s = S();第一种等价于S s;创建一个对象，执行一次析构第二种会创造一个匿名临时对象，然后将匿名对象复制到s中，创建两个对象，执行两次析构所以尽量使用S s;这种隐式构造，通常效率更高 运算符重载运算符重载是一种形式的C++多态不能通过连接其他符号来创建新的操作符：比如operator@重载操作符必须有一个类类型或者枚举类型的用户定义参数，防止用户为内置类型重载运算符。必须遵守语法规则，如，不可将%重载成一个操作数。.* :: sizeof ?: . typeid const_cast dynamic_cast reinterpret_cast static_cast 不可重载一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的浅拷贝如果需要自己写赋值运算符重载，需要检查是否自己给自己赋值1234567891011121314151617181920212223// 运算符重载演示class S &#123;public: S(int a = 1, string s = \"sss\") &#123; _a = a; _s = s; &#125; S&amp; operator+(S&amp; s) &#123; _a += s._a; return *this; &#125;private: int _a; string _s;&#125;; int main() &#123; S a, b, c; a = a + b + c; // a = a.operator+(b).operator+(c); 和上面代码等价 return 0;&#125; 取地址及const取地址操作符重载将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改const对象不能调用非const成员函数const成员函数内不能调用其它的非const成员函数取地址及const取地址操作符重载一般不用重新定义，编译器默认会生成Type* operator&amp;() { return this; }const Type* operator&amp;() const { return this; } 内联函数编译时，编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率，但是占用更多内存。当执行函数代码时间比处理函数调用机制时间长时，则节省的时间比例不高，不必声明为内联。当函数代码少，并且函数经常被调用，声明为内联可以提升程序运行效率inline对于编译器而言只是一个建议，编译器会自动优化，如果函数体内有循环/递归等，编译器优化时会忽略掉内联inline在类外定义时，只需在类实现部分中使用inline限定符，必须在每个使用它们的文件中都定义，防止链接错误，因为inline被展开，就没有函数地址了，链接就会找不到。所以直接将定义放在头文件中最简单由于宏定义的缺点，在C++中我们可以采用内联函数和const替换宏的函数和常量定义","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"构造函数","slug":"构造函数","permalink":"https://ranjiahao.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"析构函数","slug":"析构函数","permalink":"https://ranjiahao.github.io/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://ranjiahao.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"name":"内联函数","slug":"内联函数","permalink":"https://ranjiahao.github.io/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"}]},{"title":"类和对象","slug":"类和对象","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-02T16:00:00.000Z","comments":true,"path":"2019/12/03/类和对象/","link":"","permalink":"https://ranjiahao.github.io/2019/12/03/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"C语言中结构体中只能定义变量，C++中结构体内不仅可以定义变量，也可以定义函数，C++中更喜欢用class来代替。区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式是private 定义方式声明、定义全放类中。成员函数如果在类中定义，编译器可能会将其当成内联函数处理声明放在.h文件中，定义放在.cpp文件中（推荐使用） 类的访问限定符及封装C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用，本质是一种管理public修饰的成员在类外可以直接被访问，protected和private修饰的成员在类外不能直接被访问访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别 类对象模型对象中只保存成员变量，成员函数存放在公共的代码段一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐注意空类的大小，编译器给了空类一个字节来唯一标识这个类 this指针C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象，函数体中所有成员变量的操作，都是通过该指针去访问。用户不需要来传递，编译器自动完成this指针类型：类类型* constthis指针是成员函数第一个隐含的指针形参，是对象调用成员函数时，将对象地址作为实参传递给this形参，一般情况由编译器通过ecx寄存器自动传递，不可显示写出，对象中不存储this指针this指针可以为空，但是不可访问成员变量1234567891011121314class S &#123;public: void Print() &#123; cout &lt;&lt; \"Print()\" &lt;&lt; endl; &#125; int a;&#125;;int main() &#123; S* ptr = nullptr; ptr-&gt;Print(); // 正确，只访问了公共代码段 cout &lt;&lt; ptr-&gt;a &lt;&lt; endl; // 错误，不可访问成员变量 return 0;&#125; 对象数组123456S stuff1[4]; // 调用默认构造S stuff2[4] = &#123; S(0,\"aaa\"), S(), S(2,\"ccc\"),&#125;; // stuff2[1] stuff2[3] 调用默认构造最好总是提供一个默认的构造函数。如果没有，则必须确保为数组中的每个对象提供一个初始化项 C++11 列表初始化C++11扩大了列表初始化的使用范围，使其可用于所有的内置类型和用户自定义的类型，需要提供与构造函数的参数列表匹配的内容，使用时，可添加等号(=)，也可不添加 内置类型的列表初始化123456789101112// 内置类型变量int x&#123; 1 + 1 &#125;;// 数组int arr[]&#123; 1, 2, 3, 4, 5 &#125;;// 动态数组，在C++98中不支持int* arr = new int[3]&#123; 1, 2, 3 &#125;;// 标准容器vector&lt;int&gt; v&#123; 1, 2, 3, 4, 5 &#125;;map&lt;int, int&gt; m&#123; &#123;1, 1&#125;, &#123;2, 2,&#125;, &#123;3, 3&#125;, &#123;4, 4&#125; &#125;; 自定义类型的列表初始化123456789101112S s1&#123;&#125;;S s2; // s1 s2等价S s3&#123; 3,\"ran\" &#125;; // S s3 = &#123; 3, \"ran\"&#125;,可添加等号(=)，也可不添加S s4(3, \"ran\"); // s3 s4等价// 直接初始化S stuff[4]&#123; S(0,\"aaa\"), S(), S(2,\"ccc\"),&#125;; 容器类型的列表初始化实现vector类想要支持列表初始化，需给该类添加一个带有initializer_list类型参数的构造函数，否则Vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6 };就会报错，编译器以为要创建6个对象： Vector&lt;int&gt; v[6]{ 1, 2, 3, 4, 5, 6 };改进如下：12345678910111213141516171819202122232425262728293031#include &lt;initializer_list&gt;template &lt;class T&gt;class Vector&#123;public: // ... Vector(const std::initializer_list&lt;T&gt;&amp; lst) : _start(new T[lst.size()]) , _endOfStorage(_start + lst.size()) , _finish(_start) &#123; for (const auto&amp; e : lst) &#123; *_finish = e; ++_finish; &#125; &#125; Vector&lt;T&gt;&amp; operator=(std::initializer_list&lt;T&gt; lst) &#123; delete[] _start; _start = new T[lst.size()]; _endOfStorage = _start + lst.size(); _finish = _start; for (auto&amp; e : lst) &#123; *_finish = e; ++_finish; &#125; return *this; &#125;private: T* _start = nullptr; T* _finish = nullptr; T* _endOfStorage = nullptr;&#125;Vector&lt;int&gt; v{ 1, 2, 3, 4, 5, 6 };创建一个对象，并将成员初始化。initializer_list是系统自定义的类模板，该类模板中主要有三个方法：begin()、end()迭代器以及获取区间中元素个数的方法size() C++11 默认函数控制显式缺省函数：C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本删除默认函数：在函数声明加上=delete，编译器不生成对应函数的默认版本与=default不同，=delete必须出现在函数第一次声明的时候 const成员函数const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改加上const修饰后，隐式的将 类类型* const this 变成 const 类类型* const this非const对象/成员函数可以调用任何成员函数const对象/成员函数只可以调用const成员函数 mutable1234567891011struct personInfo &#123; mutable int age=18; // 即使结构变量或类为const，其某个成员也可以被修改 int expr = 2;&#125;; int main() &#123; personInfo const p1; cout &lt;&lt; p1.age &lt;&lt; endl; p1.age = 20; cout &lt;&lt; p1.age &lt;&lt; endl;&#125; static成员static可以声明成员函数和成员变量静态成员为所有类对象所共享，不属于某个具体的实例，静态成员变量必须在类外定义，定义时不添加static关键字类静态成员即可用类名::静态成员或者对象.静态成员来访问没有隐藏的this指针，不能访问任何非静态成员 友元类方法和友元只是表达类接口的两种不同机制。但友元会增加耦合度，破坏了封装，所以友元不宜多用 友元函数友元函数可访问类的私有成员，但不是类的成员函数，不能使用成员运算符来调用定义在类外部，可以在类定义的任何地方声明，不受类访问限定符限制当友元函数代码很短时，可以在声明时同时定义，可成为内联函数一个函数可以是多个类的友元函数友元函数不能用const修饰代替友元函数的办法：12345678910111213141516171819202122class S &#123;public: S&amp; operator+(int n) &#123; _a += n; return *this; &#125;private: int _a; string _s;&#125;;// 这样就可以避免突破封装了S&amp; operator+(int n, S&amp; s) &#123; return s + n;&#125;int main() &#123; S obj; obj = obj + 1; // obj = obj.operator+(1); obj = 1 + obj; // 调用S&amp; operator+(int n, S&amp; s) return 0;&#125; 友元类友元类的所有成员函数都可以是另一个类的友元函数单向，不可传递123456789101112131415161718192021222324class AAA; // 类的不完全声明class BBB &#123;friend class AAA;public: BBB() :_b(3) &#123;&#125;private: int _b;&#125;;class AAA &#123;public: void Test() &#123; // 可以访问私有成员 cout &lt;&lt; _obj._b &lt;&lt; endl; &#125;private: BBB _obj;&#125;;int main() &#123; AAA a; a.Test(); // 3 return 0;&#125; 内部类内部类是一个独立的类，它不属于外部类，可以看作外部类的友元类，外部类对内部类没有任何优越的访问权限可以定义在外部类的任何地方sizeof(外部类)=外部类，和内部类没有任何关系注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名123456789101112131415161718192021222324class AAA &#123;public: class aaa &#123; public: void Test() &#123; cout &lt;&lt; k &lt;&lt; endl; // 3 cout &lt;&lt; RED &lt;&lt; endl; // 0 cout &lt;&lt; GREEN &lt;&lt; endl; // 1 &#125; &#125;; static int k; enum Color &#123; RED, GREEN &#125;;&#125;;int AAA::k = 3;int main() &#123; AAA::aaa a; a.Test(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"C++11列表初始化","slug":"C-11列表初始化","permalink":"https://ranjiahao.github.io/tags/C-11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"友元","slug":"友元","permalink":"https://ranjiahao.github.io/tags/%E5%8F%8B%E5%85%83/"},{"name":"内部类","slug":"内部类","permalink":"https://ranjiahao.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"}]},{"title":"函数重载及原理详解","slug":"函数重载及原理详解","date":"2019-11-30T16:00:00.000Z","updated":"2019-11-30T16:00:00.000Z","comments":true,"path":"2019/12/01/函数重载及原理详解/","link":"","permalink":"https://ranjiahao.github.io/2019/12/01/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"默认参数半缺省参数必须从右往左依次来给出，不能间隔着给缺省参数不能在函数声明和定义中同时出现缺省值必须是常量或者全局变量 函数重载C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表参数个数 或 类型 或 顺序必须不同，可以通过函数重载实现编译时多态 注意事项由于函数传参为值拷贝，所以在没有最合适的匹配函数时，会生成临时变量来匹配对应实参123456void Fuc(int a) &#123;&#125;int main() &#123; Fuc(3.14); // 生成临时变量3 return 0;&#125;当没有最合适匹配，但能匹配的函数不唯一时，编译器会报错1234567void Fuc(long a) &#123;&#125;void Fuc(int a) &#123;&#125;int main() &#123; Fuc(3.14); // 此时编译器并不知道调用哪个fuc函数，会出错 return 0;&#125;所以匹配成功的前提是：能匹配的函数唯一确定。或者有多个能匹配，但只有一个最合适匹配如：1234567void Fuc(const double a) &#123;&#125;;void Fuc(double a) &#123;&#125;;int main() &#123; Fuc(3.14); // 匹配时，不区分const，有两个最合适匹配，会出错 return 0;&#125;1234567void Fuc(const int a) &#123;&#125;void Fuc(double a) &#123;&#125;int main() &#123; Fuc(3.14); // 两个函数都能匹配，但是第二个函数最匹配 return 0;&#125; 重载引用/指针参数12345678910void Fuc(int* a) &#123;&#125;void Fuc(const int* a) &#123;&#125;int main() &#123; const int a = 3; int b = 1; Fuc(&amp;a); // 只有第二个最匹配，调用Fuc(const int* a) Fuc(&amp;b); // 两个都匹配，但第一个最匹配，调用void Fuc(int* a) return 0;&#125;12345678910111213void Fuc(double&amp; a) &#123;&#125;void Fuc(const double&amp; a) &#123;&#125;void Fuc(double &amp;&amp; a) &#123;&#125;int main() &#123; double a = 3.14; int b = 3; Fuc(a); // 可以匹配前两个，但是第二个最匹配，调用Fuc(double&amp; a) Fuc(b); // 只能匹配第二个，调用Fuc(const double&amp; a) Fuc(3.14 + 1); // 可以和二三匹配，但是和第三个最匹配，调用Fuc(double &amp;&amp; a) Fuc(3.14); // vs下调用Fuc(double &amp;&amp; a) linux下会报错，应避免这样用 return 0;&#125; 原理拿这段代码来说1234567void Print(int a, double b, char c) &#123;&#125;void Print(int* a, double* b, char* c) &#123;&#125;int main() &#123; Print(3, 3.14, 'a'); return 0;&#125;在linux下执行命令objdump -d a.out |less反汇编。仅展示部分：123456789101112131415161718192021222324252627282930313233000000000040062d &lt;_Z5Printidc&gt;: 40062d: 55 push %rbp 40062e: 48 89 e5 mov %rsp,%rbp 400631: 89 7d fc mov %edi,-0x4(%rbp) 400634: f2 0f 11 45 f0 movsd %xmm0,-0x10(%rbp) 400639: 89 f0 mov %esi,%eax 40063b: 88 45 f8 mov %al,-0x8(%rbp) 40063e: 5d pop %rbp 40063f: c3 retq 0000000000400640 &lt;_Z5PrintPiPdPc&gt;: 400640: 55 push %rbp 400641: 48 89 e5 mov %rsp,%rbp 400644: 48 89 7d f8 mov %rdi,-0x8(%rbp) 400648: 48 89 75 f0 mov %rsi,-0x10(%rbp) 40064c: 48 89 55 e8 mov %rdx,-0x18(%rbp) 400650: 5d pop %rbp 400651: c3 retq 0000000000400652 &lt;main&gt;: 400652: 55 push %rbp 400653: 48 89 e5 mov %rsp,%rbp 400656: 48 83 ec 08 sub $0x8,%rsp 40065a: 48 b8 1f 85 eb 51 b8 movabs $0x40091eb851eb851f,%rax 400661: 1e 09 40 400664: be 61 00 00 00 mov $0x61,%esi 400669: 48 89 45 f8 mov %rax,-0x8(%rbp) 40066d: f2 0f 10 45 f8 movsd -0x8(%rbp),%xmm0 400672: bf 03 00 00 00 mov $0x3,%edi 400677: e8 b1 ff ff ff callq 40062d &lt;_Z5Printidc&gt; 40067c: b8 00 00 00 00 mov $0x0,%eax 400681: c9 leaveq 400682: c3 retqPrint(int a, double b, char c)的函数签名变为&lt;_Z5Printidc&gt;Print(int* a, double* b, char* c)的函数签名变为&lt;_Z5PrintPiPdPc&gt;验证其他代码后，可以发现大概是int-&gt;i，long-&gt;l，char-&gt;c，string-&gt;Ss…基本上都是用首字母代表编译器实际在底层使用被重新修饰过的一个比较复杂的名字，被重新修饰后的名字中包含了：函数的名字以及参数类型。这就是为什么函数重载中几个同名函数要求其参数列表不同的原因。linux 下函数名修饰规则：_Z + 名称空间 + 函数字符个数 + 函数名 + 类型首字符有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译123456extern\"C\" void Print(int a, double b, char c) &#123;&#125;int main() &#123; Print(3, 3.14, 'a'); return 0;&#125;在linux下执行命令objdump -d a.out |less反汇编。仅展示部分：123456789000000000040062d &lt;Print&gt;: 40062d: 55 push %rbp 40062e: 48 89 e5 mov %rsp,%rbp 400631: 89 7d fc mov %edi,-0x4(%rbp) 400634: f2 0f 11 45 f0 movsd %xmm0,-0x10(%rbp) 400639: 89 f0 mov %esi,%eax 40063b: 88 45 f8 mov %al,-0x8(%rbp) 40063e: 5d pop %rbp 40063f: c3 retq由于C语言只是单纯的函数名。因此当工程中存在相同函数名的函数时，就会产生冲突","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"函数重载","slug":"函数重载","permalink":"https://ranjiahao.github.io/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"},{"name":"默认参数","slug":"默认参数","permalink":"https://ranjiahao.github.io/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"}]},{"title":"命名空间与链接性","slug":"命名空间与链接性","date":"2019-10-06T16:00:00.000Z","updated":"2019-10-06T16:00:00.000Z","comments":true,"path":"2019/10/07/命名空间与链接性/","link":"","permalink":"https://ranjiahao.github.io/2019/10/07/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E9%93%BE%E6%8E%A5%E6%80%A7/","excerpt":"","text":"C++中，名称可以是变量、函数、结构、枚举、类、以及类和结构的成员。使用名称空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染 传统C++名称空间 声明区域声明区域是可以在其中进行声明的区域。例如，全局变量的声明区域为其声明所在的文件；自动变量的声明区域为其声明所在的代码块 潜在作用域和作用域变量的潜在作用域从声明点开始，到其声明区域的结尾潜在作用域比声明区域小，因为变量必须定义后才能使用变量并非在其潜在作用域都是可见的，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。变量对程序可见的范围被称为作用域12345678#include &lt;iostream&gt;int a = 1;int main() &#123; int a = 3; std::cout &lt;&lt; ::a &lt;&lt; std::endl; // 1 std::cout &lt;&lt; a &lt;&lt; std::endl; // 3 return 0;&#125;例如全局变量a的潜在作用域是第2行第8行；作用域是第2行第3行定义同名局部变量后构成同名变量隐藏，但通过::a可以访问 新的名称空间特性通过定义一种新的声明区域来创建命名的名称空间可以是全局的，也可以嵌套定义，但不能位于代码块中。默认情况下链接性为外部同一个工程中允许存在多个相同名称的命名空间编译器最后会合成同一个命名空间中 使用方法加命名空间名称及作用域限定符使用using将命名空间中成员引入（using声明）使用using namespace命名空间名称引入（using编译指令）using声明如果发生名称冲突会报错，而using编译指令会构成同名隐藏，局部版本将隐藏名称空间版本using编译指令可传递可以给名称空间创建别名，列如，namespace STD = std可以通过这种技术简化对嵌套名称的使用优先使用::或using声明 匿名名称空间潜在作用域和全局变量相似，其特性提供了链接性为内部的静态变量的替代品例如全局静态变量static int counts;可以这样代替namespace { int counts; }使用在已命名的名称空间中声明的变量代替外部全局变量、静态全局变量12345namespace &#123; char c; int i; double d;&#125;编译器在内部会为这个命名空间生成一个唯一的名字，而且还会为这个匿名的命名空间生成一条using指令。所以上面的代码在效果上等同于：123456namespace __UNIQUE_NAME_ &#123; char c; int i; double d;&#125;using namespace __UNIQUE_NAME_; 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// spaceA.h#pragma oncenamespace SpaceA &#123; class TestA &#123; public: TestA(); ~TestA(); void print(); &#125;;&#125;// spaceA.cpp#include &lt;iostream&gt;#include \"spaceA.h\"SpaceA::TestA::TestA() &#123;&#125;SpaceA::TestA::~TestA() &#123;&#125;void SpaceA::TestA::print() &#123; std::cout &lt;&lt; \"SpaceA::TestA::print()\" &lt;&lt; std::endl;&#125;// spaceB.h#pragma once// 使用前声明一下namespace SpaceA &#123; class TestA;&#125;namespace SpaceB &#123; extern int i; const int ci = 2; extern const int eci; class TestB &#123; public: TestB(); ~TestB(); void printB(); private: SpaceA::TestA* a; // 类的定义为内部链接，不能直接定义，除非写出类的完整声明，此处采用指针的方式 &#125;;&#125;// spaceB.cpp#include &lt;iostream&gt;#include \"spaceB.h\"#include \"spaceA.h\"int SpaceB::a = 123;SpaceB::TestB::TestB() &#123; a = new SpaceA::TestA;&#125;SpaceB::TestB::~TestB() &#123; delete a; a = nullptr;&#125;void SpaceB::TestB::printB() &#123; std::cout &lt;&lt; \"SpaceB::TestB::printB()\" &lt;&lt; std::endl;&#125;// main.cpp#include &lt;iostream&gt;#include \"spaceB.h\"int main() &#123; SpaceB::TestB b; b.printB(); std::cout &lt;&lt; SpaceB::i &lt;&lt; std::endl; std::cout &lt;&lt; SpaceB::ci &lt;&lt; std::endl; std::cout &lt;&lt; SpaceB::eci &lt;&lt; std::endl; return 0;&#125; 链接性描述了名称在不同单元间共享外部链接性：可以在文件间共享非inline函数、命名空间中非静态函数、类成员函数和类静态成员函数类静态成员变量总有外部链接命名空间(不包括无名命名空间)中非静态变量内部链接性：只能由一个文件中的函数共享，编译后不会产生修饰名字，因此不与链接器打交道所有的声明命名空间(包括全局命名空间)中的静态自由函数、静态友元函数、静态变量的定义、const常量定义(除非在const限定声明之时或之前已经声明为extern)enum定义inline函数定义(包括自由函数和非自由函数)类(class、struct、union)的定义无链接性：不能共享，具有局部作用域，如局部变量、函数形参等跨语言链接：有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译12345extern \"C\" int Add(int left, int right);int main() &#123; Add(1,2); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"命名空间","slug":"命名空间","permalink":"https://ranjiahao.github.io/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"name":"链接性","slug":"链接性","permalink":"https://ranjiahao.github.io/tags/%E9%93%BE%E6%8E%A5%E6%80%A7/"}]},{"title":"预处理器","slug":"预处理器","date":"2019-06-30T16:00:00.000Z","updated":"2019-06-30T16:00:00.000Z","comments":true,"path":"2019/07/01/预处理器/","link":"","permalink":"https://ranjiahao.github.io/2019/07/01/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"C预处理器不是编译器的组成部分，它是编译过程中一个单独的步骤，本质上是一个文本替换工具，其在源代码编译之前对其进行一些文本性质的操作，它主要任务包括删除注释、头文件展开、定义和替换宏定义的符号以及条件编译的展开所有预处理器命令都是#开头，预处理指令不是语句，所以它们不会以分号结尾预处理：选项gcc -E test.c -o test.i预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中常见指令：#define，#include，#undef，#ifdef，#ifndef，#if，#else，#elif，#endif，#error，#pragma 预定义宏宏描述__DATE__文件被编译日期，一个以 “MMM DD YYYY” 格式表示的字符常量__TIME__文件被编译时间，一个以 “HH:MM:SS” 格式表示的字符常量__FILE__当前文件名，一个字符串常量__LINE__当前行号，一个十进制常量__STDC__当编译器以 ANSI 标准编译时，则定义为 1 #define1234567#define MAX 100 // 将所有MAX替换为100，增强可读性#define do_forever for(;;) //用更形象的符号来替换一种实现#define CASE break;case //在写case语句的时候自动把break写上#define DEBUG_PRINT printf(\"file:%s\\tline:%d\\t \\ date:%s\\ttime:%s\\n\", \\ __FILE__,__LINE__, \\ __DATE__,__TIME__) // 测试预定义宏 参数化的宏格式：#define name(parament-list) stuff其中的parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中注意：参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分替换过程：对参数进行检查，是否包含任何由#define定义的符号。如果是，它们首先被替换替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程注意事项：由于宏替换的本质是文本替换所以在定义的时候需要注意符号优先级12#define SQUARE(x) x * x#define SQUARE(x) ((x) * (x)) // 这样写会避免因符号优先级带来的错误 #与##把一个宏的参数转换为字符串常量时，使用字符串常量化运算符#12345#define PRINT(FORMAT, VALUE) \\ printf(\"the value of \" #VALUE \" is \"FORMAT \"\\n\", VALUE);... int i = 0; PRINT(\"%d\", i+3); // the value of i+3 is 3宏定义内的标记粘贴运算符##会合并两个参数123456789101112#define ADD_TO_SUM(num, value) \\ sum##num += value;...int sum1 = 0;int sum2 = 0;ADD_TO_SUM(1, 3); // 给sum1变量增加3ADD_TO_SUM(2, 4); // 给sum2变量增加4// 由于宏定义本质是文本替换，所以以下操作是错误的for (int i = 1; i &lt; 3; ++i) &#123; ADD_TO_SUM(i,1); // 给sumi变量增加1，sumi未定义，所以会报错&#125; 宏和函数宏的执行速度快，没有函数栈帧开销，但如果定义比较长的宏，代码长度会增加宏的参数与类型无关，所以不存在类型检查宏的书写比较复杂，需要考虑操作符优先级问题和副作用的参数不方便调试，不可递归 命令行定义12345// test.c#include &lt;stdio.h&gt;int main() &#123; printf(\"%d\\n\",MAX); // 直接编译会显示MAX未定义&#125;可以这样编译gcc -DMAX=7 test.c同一份代码，可以根据不同选项在不同环境下执行，同样-Uname将导致程序中符号name的初始定义被忽略 文件包含函数库文件包含#include &lt;filename&gt;编译器通过观察由编译器定义的一系列标准位置查找函数库头文件，如unix系统上的C编译器在/user/include目录查找函数库头文件本地文件包含#include &quot;filename&quot;标准允许编译器自行决定是否把本地形式的#include和函数库形式的#include区别对待，常见的策略就是在源文件所在的当前目录进行查找，如果未找到，编译器就像查找函数库头文件一样在标准位置查找本地文件","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"预处理器","slug":"预处理器","permalink":"https://ranjiahao.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"}]},{"title":"动态内存管理","slug":"动态内存管理","date":"2019-06-17T16:00:00.000Z","updated":"2019-06-17T16:00:00.000Z","comments":true,"path":"2019/06/18/动态内存管理/","link":"","permalink":"https://ranjiahao.github.io/2019/06/18/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"分配内存的函数 mallocvoid* malloc(size_t size);如果开辟成功，则返回一个指向开辟好空间的指针如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查如果参数size为0，malloc的行为是标准是未定义的，取决于编译器 freevoid free(void* ptr);如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的如果参数ptr是NULL指针，则函数什么事都不做 callocvoid* calloc(size_t num, size_t size);函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0 reallocvoid* realloc(void* ptr, size_t size);如果size比原来小，则前size个字节不变，后面的数据被截断，如果size比原来大，则原来的数据全部保留，这里存在两种情况：情况1：原有空间之后有足够大的空间，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化情况2：原有空间之后没有足够大的空间，在堆空间上另找一个合适大小的连续空间来使用，这样函数返回的是一个新的内存地址如果参数ptr是空指针，则类似malloc，返回指向开辟好空间的指针如果参数size为0，则类似free，返回空指针 allocavoid* alloca(size_t size);参数size是请求分配的字节数，返回所分配内存空间的首地址，如果size太大导致栈空间耗尽，结果是未定义的，alloca函数不是在堆上分配空间，而是在调用者函数的栈帧上分配空间，类似于C99的变长数组，当调用者函数返回时自动释放栈帧，所以不需要free。这个函数不属于C标准库，而是在POSIX标准中定义的 定义一个不易发生错误的内存分配器1234567891011121314151617181920212223242526272829// alloc.h#pragma once#include &lt;stdlib.h&gt;#define malloc 不要直接调用malloc!#define MALLOC(num, type) (type*)alloc(num * sizeof(type))extern void* alloc(size_t size);// alloc.c#include &lt;stdio.h&gt;#include \"alloc.h\"#undef mallocvoid* alloc(size_t size) &#123; void* new_mem; new_mem = malloc(size); if (!new_mem) &#123; printf(\"Out of memory!\\n\"); exit(1); &#125; return new_mem;&#125;// main.c#include \"alloc.h\"int main() &#123; int* new_memory; new_memory = MALLOC(25, int); /* ... */ return 0;&#125; 柔性数组C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员1234typedef struct st_type &#123; int i; int a[0]; //柔性数组成员，有些编译器会报错无法编译可以改成：int a[];&#125; type_a; 柔性数组的特点结构中的柔性数组成员前面必须至少一个其他成员sizeof返回的这种结构大小不包括柔性数组的内存包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小 柔性数组的优点方便内存释放，把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉，不用担心结构体内的成员也需要free利于访问速度，连续的内存有益于提高访问速度，也有益于减少内存碎片 new/delete操作符操作：new data-type;data-type可以是包括数组在内的任意内置类型数据，也可以是自定义的任何数据类型如：int* p = new int(3); delete p;在堆上申请空间，创建对象int并初始化为3int* p = new int[3]; delete[] p在堆上申请3个int大小空间，创建3个对象newnew底层调用先operator new函数申请空间，然后执行构造函数，完成对象的构造operator new底层调用malloc，当malloc申请空间成功时直接返回；申请空间失败尝试执行应对措施，若无应对措施则抛异常delete先在空间上执行析构函数，完成对象中资源的清理工作，调用operator delete函数释放对象的空间new T[N]先调用operator new[]（在operator new[]中实际调用operator new函数完成N个对象空间的申请）然后在申请的空间上执行N次构造函数delete[]先在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理然后调用operator delete[]释放空间（在operator delete[]中调用operator delete来释放空间） 定位new表达式定位new表达式是在已分配的原始内存空间中调用构造函数初始化一个对象Type* ptr = (Type*)malloc(sizeof(Type)); new(ptr) Type;如果构造函数有参数，需传参","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"动态内存","slug":"动态内存","permalink":"https://ranjiahao.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"}]},{"title":"标准IO库函数","slug":"标准IO库函数","date":"2019-06-15T16:00:00.000Z","updated":"2019-06-15T16:00:00.000Z","comments":true,"path":"2019/06/16/标准IO库函数/","link":"","permalink":"https://ranjiahao.github.io/2019/06/16/%E6%A0%87%E5%87%86IO%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"","text":"fopen/fclose打开文件就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识，以后用户程序就可以用这个标识对文件做各种操作，关闭文件则释放文件在操作系统中占用的资源，使文件的标识失效，用户程序就无法再操作这个文件了FILE* fopen(const char* filename, const char* mode);FILE是C标准库中定义的结构体类型，其中包含文件描述符、I/O缓冲区和当前读写位置等信息，调用者不必知道FILE结构体都有哪些成员，文件指针所指的FILE结构体的成员在库函数内部维护，调用者不应该直接访问这些成员，这样的指针称为不透明指针或者叫句柄filename可以是相对路径，也可以是绝对路径mode必选参数r：若文件存在，则以只读方式打开；若不存在，则出错w：若文件存在，则清空原有内容，以只写方式打开；若不存在，则创建新文件，以只写打开a：若文件存在，则以追加写的方式打开；若不存在，则创建新文件，以追加写打开mode可选可选b/t：t表示文本文件，b表示二进制文件，有些操作系统的文本文件和二进制文件格式不同，而在UNIX系统中，无论文本文件还是二进制文件都是由一串字节组成，t和b没有区分，用哪个都一样，也可以省略不写+：以可读可写方式打开12345// 打开一个文件时如果出错，fopen将返回NULL并设置errno，程序中应该做出错处理，通常这样写if ((fp = fopen(\"/tmp/file1\", \"r\")) == NULL) &#123; printf(\"error open file /tmp/file1!\\n\"); exit(1);&#125;int fclose(FILE* stream );把文件指针传给fclose可以关闭它所标识的文件，关闭之后该文件指针就无效了，不能再使用了。如果fclose调用出错（比如传给它一个无效的文件指针）则返回EOF并设置errno，EOF在stdio.h中定义：12345/* End of file character.Some things throughout the library rely on this being -1. */#ifndef EOF# define EOF (-1)#endif如果不调用fclose，在进程退出时系统会自动关闭文件，但是不能因此就忽略fclose调用 stdin/stdout/stderr我们经常用的printf打印到屏幕，scanf读键盘输入，也属于I/O操作，但不是对文件做I/O操作而是对终端设备做I/O操作。终端设备和文件一样也需要先打开后操作，终端设备也有对应的路径名，/dev/tty就表示和当前进程相关联的终端设备，它不表示磁盘上的一组数据，而是表示一个设备。用ls -l命令查看这个文件，显示文件类型、主设备号、次设备号等，主设备号标识内核中的一个设备驱动程序，次设备号标识该设备驱动程序管理的一个设备。内核通过设备号找到相应的驱动程序，完成对该设备的操作。设备文件没有文件尺寸这个属性的，因为设备文件在磁盘上不保存数据，对设备文件做读写操作并不是读写磁盘上的数据，而是在读写设备。UNIX的传统是Everything is a file，键盘、显示器、串口、磁盘等设备在/dev目录下都有一个特殊的设备文件与之对应，这些设备文件也可以像普通文件一样打开、读、写和关闭，使用的函数接口是相同的程序启动时（main函数还没开始执行前）会自动把终端设备打开三次，分别赋给三个FILE*指针stdin、stdout和stderr，这三个文件指针是libc中定义的全局变量，在stdio.h中声明，这三个文件指针的打开方式都是可读可写的，但通常stdin只用于读操作，称为标准输入，stdout只用于写操作，称为标准输出，stderr也只用于写操作，称为标准错误输出，通常程序的运行结果打印到标准输出，而错误提示打印到标准错误输出，所以fopen的错误处理写成这样更符合惯例：1234if ((fp = fopen(\"/tmp/file1\", \"r\")) == NULL) &#123; fputs(\"Error open file /tmp/file1\\n\", stderr); exit(1);&#125; errno与perror函数很多系统函数在错误返回时将错误原因记录在libc定义的全局变量errno中，每种错误原因对应一个错误码，errno在头文件errno.h中声明，是一个整型变量，所有错误码都是正整数如果在程序中打印错误信息时直接打印errno变量，打印出来的只是一个整数值，仍然看不出是什么错误，可以用perror或strerror函数将errno解释成字符串再打印12345FILE* fp = fopen(\"abcde\", \"r\");if (fp == NULL) &#123; perror(\"Open file abcde\"); exit(1);&#125;有些函数的错误码并不保存在errno中，而是通过返回值返回，就不能调用perror打印错误原因了，这时就要使用strerror：fputs(strerror(n), stderr); 以字节为单位的I/O函数int fgetc(FILE* stream);文件的打开方式必须是可读系统对于每个打开的文件都记录着当前读写位置在文件中的地址。当文件打开时，读写位置是0，每调用一次fgetc，读写位置向后移动一个字节，因此可以连续多次调用fgetc函数依次读取多个字节fgetc成功时返回读到一个字节，本来应该是unsigned char型的，但由于函数原型中返回值是int型，所以这个字节要转换成int型再返回，因为出错或读到文件末尾时fgetc将返回EOF，即-1，保存在int型的返回值中是0xffffffff，如果读到字节0xff，由unsigned char型转换为int型是0x000000ff，只有规定返回值是int型才能把这两种情况区分开，如果规定返回值是unsigned char型，那么当返回值是0xff时无法区分到底是EOF还是字节0xffint fputc(int character, FILE* stream);文件的打开方式必须是可写的（包括追加）每调用一次fputc，读写位置向后移动一个字节，因此可以连续多次调用fputc函数依次写入多个字节。但如果文件是以追加方式打开的，每次调用fputc时总是将读写位置移到文件末尾然后把要写入的字节追加到后面从终端设备输入时有两种方法表示文件结束，一种方法是在一行的开头输入Ctrl-D（如果不在一行的开头则需要连续输入两次Ctrl-D），另一种方法是利用Shell的Heredoc语法：1234$ .&#x2F;a.out &lt;&lt;END&gt; hello&gt; hey&gt; END&lt;&lt;END表示从下一行开始是标准输入，直到某一行开头出现END时结束。&lt;&lt;后面的结束符可以任意指定，不一定得是END，只要和输入的内容能区分开就行 操作读写位置的函数int fseek(FILE* stream, long int offset, int origin);long ftell(FILE* stream);void rewind(FILE* stream);fseek可以任意移动读写位置，origin参数含义：SEEK_SET从文件开头移动offset个字节SEEK_CUR从当前位置移动offset个字节SEEK_END从文件末尾移动offset个字节offset可正可负，负值表示向前（向文件开头的方向）移动，正值表示向后（向文件末尾的方向）移动，如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸，从原来的文件末尾到fseek移动之后的读写位置之间的字节都是0，成功返回0，出错返回-1并设置errnoftell可以返回当前的读写位置，成功返回当前读写位置，出错返回-1并设置errnorewind函数把读写位置移到文件开 以字符串为单位的I/O函数char* fgets(char* str, int num, FILE* stream);fgets从指定的文件中读一行字符到调用者提供的缓冲区中参数str是缓冲区的首地址，num是缓冲区的长度，该函数从stream所指的文件中读取以’\\n’结尾的一行（包括’\\n’在内）存到缓冲区str中，并且在该行末尾添加一个’\\0’组成完整的字符串，成功时str指向哪返回的指针就指向哪，出错或者读到文件末尾时返回NULL如果文件中的一行太长，fgets从文件中读了num-1个字符还没有读到’\\n’，就把已经读到的num-1个字符和一个’\\0’字符存入缓冲区，文件中剩下的半行可以在下次调用fgets时继续读如果一次fgets调用在读入若干个字符后到达文件末尾，则将已读到的字符串加上’\\0’存入缓冲区并返回，如果再次调用fgets则返回NULL，可以据此判断是否读到文件末尾fgets只适合读文本文件而不适合读二进制文件，因为文本文件中的所有字符都应该是可见字符，没有’\\0’，二进制文件可能有’\\0’（0x00字节）调用fgets之后就无法判断缓冲区中的’\\0’究竟是从文件读上来的字符还是由fgets自动添加的结束符int fputs(const char* str, FILE* stream);fputs向指定的文件写入一个字符串，缓冲区str中保存的是以’\\0’结尾的字符串，fputs将该字符串写入文件stream，但并不写入结尾的’\\0’，成功返回一个非负整数，出错返回EOF 以记录为单位的I/O函数size_t fread(void* ptr, size_t size, size_t count, FILE* stream);size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream);fread和fwrite用于读写记录，这里的记录是指一串固定长度的字节，比如一个int、一个结构体或者一个定长数组。参数size指出一条记录的长度，而count指出要读或写多少条记录，这些记录在ptr所指的内存空间中连续存放，共占size*count个字节，fread从文件stream中读出size*count个字节保存到ptr中，而fwrite把ptr中的size*count个字节写到文件stream中count是请求读或写的记录数，fread和fwrite返回的记录数有可能小于count指定的记录数。例如当前读写位置距文件末尾只有一条记录的长度，调用fread时指定count为2，则返回值为1。如果当前读写位置已经在文件末尾了，或者读文件时出错了，则fread返回0。如果写文件时出错了，则fwrite的返回值小于count指定的值 格式化I/O函数int fprintf(FILE* stream, const char* format, …);int sprintf(char* str, const char* format, …);int snprintf(char* s, size_t n, const char* format, …);int vprintf(const char* format, va_list arg);int vfprintf(FILE* stream, const char* format, va_list arg);int vsprintf(char* s, const char* format, va_list arg);int vsnprintf(char* s, size_t n, const char* format, va_list arg);fprintf打印到指定的文件stream中，sprintf并不打印到文件，而是打印到用户提供的缓冲区str中并在末尾加’\\0’，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，用snprintf更好 截断到n-1字节，再加上一个’\\0’写入缓冲区，也就是说snprintf保证字符串以’\\0’结尾。snprintf的返回值是格式化后的字符串长度（不包括结尾的’\\0’），如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断后四个函数在前四个函数名的前面多了个v，表示可变参数不是以…的形式传进来，而是以va_list类型传进来实现格式化打印错误的err_sys函数12345678910111213141516171819202122232425262728#define MAXLINE 80void err_sys(const char* fmt, ...) &#123; int err = errno; char buf[MAXLINE+1]; va_list ap; va_start(ap, fmt); vsnprintf(buf, MAXLINE, fmt, ap); snprintf(buf+strlen(buf), MAXLINE-strlen(buf), \":%s\", strerror(err)); strcat(buf, \"\\n\"); fputs(buf, stderr); va_end(ap); exit(1);&#125;int main(int argc, char *argv[]) &#123; FILE *fp; if (argc != 2) &#123; fputs(\"Usage: ./a.out pathname\\n\",stderr); exit(1); &#125; fp = fopen(argv[1], \"r\"); if (fp == NULL) err_sys(\"Line %d - Open file %s\", __LINE__, argv[1]); printf(\"Open %s OK\\n\", argv[1]); fclose(fp); return 0;&#125;printf并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数，所以如果实际参数和转换说明的类型不符，结果可能会有些意外。另外，如果s指向一个字符串，用printf(s)打印这个字符串可能得到错误的结果，因为字符串中可能包含%号而被printf当成转换说明，printf并不知道后面没有传其它参数，照样会从栈帧上取参数。所以比较保险的办法是printf(&quot;%s&quot;, s)int fscanf(FILE* stream, const char* format, …);int sscanf(const char* s, const char* format, …);int vscanf(const char* format, va_list arg);int vsscanf(const char* s, const char* format, va_list arg);int vfscanf(FILE* stream, const char* format, va_list arg);fscanf从指定的文件stream中读字符，而sscanf从指定的字符串s中读字符。后面三个以v开头的函数的可变参数不是以…的形式传进来，而是以va_list类型传进来scanf用输入的字符去匹配格式化字符串中的字符和转换说明，如果成功匹配一个转换说明，就给一个参数赋值，如果读到文件或字符串末尾就停止，或者如果遇到和格式化字符串不匹配的地方（比如转换说明是%d却读到字符A）就停止。如果遇到不匹配的地方而停止，scanf的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续 文件结束判定int feof(FILE* stream);在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束，而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束文本文件读取是否结束，判断返回值是否为EOF （fgetc），或者NULL（fgets）二进制文件的读取结束判断，判断返回值是否小于实际要读的个数因为feof()函数，并不是通过读取到文件的EOF来评判，这个文件是否为空它的工作原理是，如果光标所在位置后面有字符，返回0；如果没有，返回非0。它并不会读取相关信息，只是查看光标后是否还有内容。对于一个空文件来说，当程序打开它的时候，光标会停在文件的开头，但是由于文件里什么内容都没有存（EOF却是存在的）即整个文件就存贮了一个EOF。当程序打开文件，并直接调用feof()时，光标的位置后有EOF字符，然后就返回0了int ferror ( FILE* stream );如果出错则返回非零，否则返回0 C标准库的I/O缓冲区全缓冲：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的行缓冲：如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的无缓冲用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备除了写满缓冲区、写入换行符之外，行缓冲还有一种情况会自动做Flush操作。如果：用户程序调用库函数从无缓冲的文件中读取或者从行缓冲的文件中读取，并且这次读操作会引发系统调用从内核读取数据123456int main() &#123; char buf[20]; printf(\"Please input a line: \"); fgets(buf, 20, stdin); return 0;&#125;调用printf并不会把字符串写到设备，但紧接着调用fgets读一个行缓冲的文件（标准输入），在读取之前会自动Flush所有行缓冲，包括标准输出手动刷新缓冲区int fflush(FILE* stream);成功返回0，出错返回EOF并设置errno，fflush(NULL)可以对所有打开文件的I/O缓冲区做Flush操作","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"文件IO","slug":"文件IO","permalink":"https://ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6IO/"}]},{"title":"自定义类型总结","slug":"自定义类型总结","date":"2019-06-12T16:00:00.000Z","updated":"2019-06-12T16:00:00.000Z","comments":true,"path":"2019/06/13/自定义类型总结/","link":"","permalink":"https://ranjiahao.github.io/2019/06/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"结构的存储分配 内存对齐的意义平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问结构体的内存对齐是拿空间来换取时间的做法 内存对齐规则第一个成员在与结构体变量偏移量为0的地址处其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员大小的较小值。VS中默认的值为8，Linux中的默认值为4结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍 修改默认对齐数#pragma pack(8) //设置默认对齐数为8#pragma pack() //取消设置的默认对齐数，还原为默认对齐数 计算偏移量有两种方法：12345struct S &#123; int a; char b; double c;&#125; s;printf(&quot;%d\\n&quot;, ((char*)&amp;s.b - (char*)&amp;s));利用宏定义实现#define FIND(type, var) ((size_t)&amp;(((type*)0)-&gt;var))这样不需要实例化对象也可以，C标准库也有自带的，offsetof宏(stddef.h)offsetof(type, member) 返回值为指定成员开始存储的位置距离结构开始存储的位置偏移几个字节 位段位段的成员可以是int，signed int，unsigned int或者是char（属于整形家族）类型位段的空间上是按照需要以4个字节（int）或者1个字节（char）的方式来开辟的位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段 位段的跨平台问题int位段被当成有符号数还是无符号数是不确定的位段中最大位的数目不能确定（16位机器最大16，32位机器最大32）位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在 枚举枚举的优点：增加代码的可读性和可维护性和#define定义的标识符比较枚举有类型检查，更加严谨防止了命名污染（封装）便于调试使用方便，一次可以定义多个常量#define宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值1234567enum Color &#123; RED, GREEN, BLUE&#125;;enum Color clr = GREEN; // 只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。clr = 1; // 在C语言中可以这样赋值，因为C语言中枚举和整型是一种类型，而C++中枚举是一个单独的类型所以会报错 联合在union中所有的数据成员共用一个空间，所有的数据成员具有相同的起始地址在C++中，union成员默认属性页为public。union主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union联合的大小至少是最大成员的大小。当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍 联合的初始化联合变量可以被初始化，但这个初始值必须是联合第1个成员的类型，而且它必须位于一对花括号里面12345union &#123; int a; float b; char c[4];&#125; x = &#123; 5 &#125;; // 不能把这个类量初始化为一个浮点值或字符值，如果给出的初始值是任何其他类型，它就会转换为一个整数并赋值给x.a 一个有趣的问题123456789101112typedef struct str &#123; int len; char s[7];&#125; str;int main() &#123; str* f = NULL; if (f-&gt;s) &#123; // 这里会出错吗？ printf(\"%d\\n\", sizeof(f-&gt;s)); &#125; return 0;&#125;这样完全没有问题，并且输出结果为7用空指针访问成员变量为什么不会出错？我们可以测试下这个代码printf(&quot;%d\\n&quot;, f-&gt;s); // 输出为4其实，所谓变量，其实是内存地址的一个抽像名字罢了。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中不管结构体的实例是什么------访问其成员其实就是加成员的偏移量由于f为NULL，所以f-&gt;s就是给NULL加上偏移量4，并没有发生读取内存操作，但是如果这样：printf(&quot;%d\\n&quot;, f-&gt;s[1]); // 读取非法内存，会崩掉printf(&quot;%d&quot;, f-&gt;len); // 读取非法内存，会崩掉printf(&quot;%d&quot;, &amp;(f-&gt;len)); // 没有读取内存，不会崩掉","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"自定义类型","slug":"自定义类型","permalink":"https://ranjiahao.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"}]},{"title":"模拟实现strtok","slug":"模拟实现strtok","date":"2019-06-11T16:00:00.000Z","updated":"2019-06-11T16:00:00.000Z","comments":true,"path":"2019/06/12/模拟实现strtok/","link":"","permalink":"https://ranjiahao.github.io/2019/06/12/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strtok/","excerpt":"","text":"strtok函数原型：#include &lt;string.h&gt;char* strtok(char* str, const char* delimiters); 模拟实现1234567891011121314151617181920212223242526272829303132char* Strtok(char* str, const char* delim) &#123; static char* p = NULL; if (str) &#123; p = str; &#125; else if (!p) &#123; return NULL; &#125; str = p + strspn(p, delim); p = str + strcspn(str, delim); if (p == str) &#123; p = NULL; return NULL; &#125; if (*p) &#123; *p = '\\0'; ++p; &#125; else &#123; p = NULL; &#125; return str;&#125;int main() &#123; char str[] = \"My name is---ran jia hao---\"; char* pch; pch = Strtok(str, \" -\"); while (pch) &#123; printf(\"%s\\n\", pch); pch = Strtok(NULL, \" -\"); &#125; return 0;&#125; 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445char* strtok_r(char* string_org, const char* demial) &#123; static unsigned char* last; // 保存分隔后剩余的部分 unsigned char* str; // 返回的字符串 const unsigned char* ctrl = (const unsigned char*)demial; // 分隔字符 // 把分隔字符放到一个索引表中，定义32是因为ASCII字符表最多是0~255个，也是说用最大的255右移3位，也就是除以8一定会是32中的一个数 unsigned char map[32]; for (int count = 0; count &lt; 32; count++) &#123; map[count] = 0; &#125; // 把匹配字符放入表中 do &#123; map[*ctrl &gt;&gt; 3] |= (1 &lt;&lt; (*ctrl &amp; 7)); &#125; while (*ctrl++); // 原始字符串是否为空，如果为空表示第二次获取剩余字符的分隔部分 if (string_org) &#123; str = (unsigned char*)string_org; &#125; else &#123; str = last; &#125; // 在表中查找是否有匹配的字符，如果有略过 while ((map[*str &gt;&gt; 3] &amp; (1 &lt;&lt; (*str &amp; 7))) &amp;&amp; *str) &#123; str++; &#125; // 重置需要扫描的字符串 string_org = (char*)str; //开始扫描 for (; *str; str++) &#123; if (map[*str &gt;&gt; 3] &amp; (1 &lt;&lt; (*str &amp; 7))) &#123; *str++ = '\\0';//当找到时，把匹配字符填为0，并且把str指向下一位。 break; //退出循环 &#125; &#125; last = str; // 把剩余字符串的指针保存到静态变量last中。 if (string_org == (char*)str) &#123; return NULL; //没有找到，也就是没有移动指针的位置，返回NULL &#125; else &#123; return string_org; //找到了，返回之前字符串的头指针 &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"strtok","slug":"strtok","permalink":"https://ranjiahao.github.io/tags/strtok/"}]},{"title":"函数指针","slug":"函数指针","date":"2019-06-07T16:00:00.000Z","updated":"2019-06-07T16:00:00.000Z","comments":true,"path":"2019/06/08/函数指针/","link":"","permalink":"https://ranjiahao.github.io/2019/06/08/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","excerpt":"","text":"函数指针就是指向函数的指针，其值就是函数体的首地址。在底层，函数名就代表函数的首地址，所以把函数名直接指派给一个同类型的函数指针而不需要&amp;运算符，可以直接用函数名注册回调函数 调用的方式12345size_t(*pf)(const char*) = &amp;strlen;// &amp;操作符为可选的，函数名被使用时编译器会把它转换为函数指针，&amp;操作符只是显式地说明了编译器将隐式执行的任务int len = strlen(\"hehe\");len = (*pf)(\"hehe\");len = pf(\"hehe\");第一句简单地使用名字strlen直接调用函数，实际上执行过程是函数名strlen首先被转换成一个函数指针，该指针指向内存中函数的位置，然后函数调用操作符调用该函数，执行开始于这个地址的代码第二句对pf执行间接访问操作，它把函数指针转换为一个函数名。这个转换并不真正需要，编译器在执行函数调用操作符之前又会把它转换回去第三句和直接通过函数指针访问，这三句在效果上都是一样的 两段有意思的代码12345// 代码一(*(void(*)())0)();// 代码二void(*signal(int, void(*)(int)))(int);首先代码一(*(void(*)())0)()把(void(*)())0单独拿出来这是将int类型的0强转成void(*)()函数指针类型，然后在解引用，最后对函数指针解引用后调用用typedef简化：typedef void(*pFuc)();(*(pFuc)0)(); // 代码一等价于这个形式再来看看代码二void(*signal(int, void(*)(int)))(int);把signal(int, void(*)(int))单独拿出来，发现这是一个函数名为signal，形参为一个int类型和一个void(*)(int)的函数指针类型，外面的一层void(* )(int)是修饰其返回值类型的用typedef简化：typedef int(*pFuc)(int);pfuc signal(int, pFuc); 应用场景 回调函数函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数这里给出一段改进版的冒泡排序，可以做到一份代码同时实现升序和降序两种功能：12345678910111213141516171819202122232425262728293031323334353637383940typedef int(*Comp)(int, int);void Swap(int* a, int* b) &#123; int t = *a; *a = *b; *b = t;&#125;int Greater(int a, int b) &#123; return a &gt; b;&#125;int Less(int a, int b) &#123; return a &lt; b;&#125;void BubbleSort(int* arr, int size, Comp p) &#123; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size - 1 - i; ++j) &#123; if (p(arr[j + 1], arr[j])) &#123; Swap(&amp;arr[j], &amp;arr[j + 1]); &#125; &#125; &#125;&#125;int main() &#123; int a[5] = &#123; 1999, 723, 1007, 2019, 1212 &#125;; BubbleSort(a, 5, Greater); // 降序 for (int i = 0; i &lt; 5; ++i) &#123; printf(\"%d \", a[i]); &#125; putchar('\\n'); BubbleSort(a, 5, Less); // 升序 for (int i = 0; i &lt; 5; ++i) &#123; printf(\"%d \", a[i]); &#125; putchar('\\n'); return 0;&#125; 转移表转移表就是一个函数指针数组，可以降低函数的圈复杂度123456789101112131415161718192021222324252627282930313233343536int Add(int a, int b) &#123; return a + b;&#125;int Sub(int a, int b) &#123; return a - b;&#125;int Mul(int a, int b) &#123; return a * b;&#125;int Div(int a, int b) &#123; return a / b;&#125;int Menu() &#123; int input; printf(\"=======================\\n\"); printf(\"1.Add 2.Sub 3.Mul 4.Div\\n\"); printf(\"=======================\\n\"); printf(\"输入选择：\"); scanf(\"%d\", &amp;input); return input;&#125;int main() &#123; int x, y; typedef int(*pFuc)(int, int); pFuc arr[5] = &#123; 0, Add, Sub, Mul, Div &#125;; int choice = Menu(); printf(\"输入操作数：\"); scanf(\"%d %d\", &amp;x, &amp;y); printf(\"结果为%d\\n\", arr[choice](x, y)); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://ranjiahao.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"数组本质","slug":"数组本质","date":"2019-06-05T16:00:00.000Z","updated":"2019-06-05T16:00:00.000Z","comments":true,"path":"2019/06/06/数组本质/","link":"","permalink":"https://ranjiahao.github.io/2019/06/06/%E6%95%B0%E7%BB%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"数组的本质任何数组的元素在内存中都是连续字节存放的，数组下标必须是整数或整数表达式，并且下标操作符返回的是一个元素的引用：1234int arr[10] = &#123; 0 &#125;;arr[3] = 1; // 编译器计算地址arr+3*sizeof(int)，并且返回该地址的引用，和下边两句是语义上等价// int&amp; ri = arr[3];// ri = 1;使用[]引用数组元素的时候，编译器必须把它转成同类型指针然后编译，因为C/C++数组本身不会保存下标值和元素对象之间的对应关系1arr[3] = 1; // 转换为*(arr+3)=1;我们可以写一段代码验证：123int a = 10;int* p = &amp;a;printf(\"%d\", p[0]);这种做法是合理的，p[0]等价于*(p+0)12int arr[5] = &#123; 1, 2, 3, 4, 5 &#125;;printf(\"%d\", 2[arr]);这样编译器会自动转变成*(2+arr)和arr[2]是等价的 数组初始化静态变量初始化：存储于静态内存的数组只能在程序开始执行之前初始化一次，由链接器完成自动变量初始化：自动变量位于运行时堆栈中，每次所处的内存位置并不一定相同，编译器没有办法对这些位置进行初始化，所以自动变量在缺省的情况下是未初始化的，如果自动变量给出了初始值，每次进入所在作用域时，变量就会被一条隐式的赋值语句初始化，这条语句也是需要时间和空间的因此，如果在程序的执行流每次进入该函数（或代码块）时，每次初始化是不值得的，那么就将它声明为static 关于下标越界编译器对数组下标几乎无法执行静态检查，因为下标引用可以作用与任意的指针，而不仅仅是数组名。作用于指针的下标引用的有效性既依赖于该指针当时恰好指向什么内容，也依赖于下标的值，编译器要证实下标表达式的结果引用的元素和指针表达式所指向的元素属于同一个数组，这需要空间存储数组的位置和长度信息，程序运行时还需要时间来更新这些信息，以反映自动和动态分配的数组 二维数组在C/C++中以行序优先来存储的123int arr[3][4] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 &#125;;创建了arr数组，可以将他看作一个一维数组，包含三个元素，只不过每个元素恰好是包含4个整型元素的数组访问arr[1][2]时，通过arr这个int (*) [4]指针访问元素，编译器不需要知道行数3，但是必须要知道列数4 多维数组任何维数的数组都可以看做是由比它少一维的数组组成的一维数组，int a[3][4][5]可以看作3个4行5列的二维数组组成新的一维数组 数组名《C和指针》中提到，这个概念实际上以一种相当优雅的方式把一些完全不同的概念联系在一起数组名的值是一个常量指针，它的类型是指向其元素类型的常量指针，如上述arr就是int* const arr，由于不能仅通过数组名（不用下标和迭代）遍历数组，所以两个数组不能直接赋值。需要注意的是数组名具有一些和指针完全不同的特征比如，数组有确定的元素个数，指针是一个标量值。编译器用数组名记住这些属性只有数组名在表达式中使用时，编译器才会为它产生一个指针常量这两种情况下数组名并不是指针：数组名作为sizeof操作符，或单目操作符&amp;的操作数时，sizeof返回整个数组的长度，对数组名取地址返回的是指向数组的指针 数组和指针之间的关系123int a[10] &#x3D;&gt; int*const a;int b[3][4] &#x3D;&gt; int(*const b)[4];int c[3][4][5] &#x3D;&gt; int(*const c)[4][5]; 数组传递123void test(int arr[], int size) &#123; printf(\"%d\\n\", sizeof(arr)); // 是4而不是400&#125;12int arr[100] = &#123; 0 &#125;;printf(\"%d\\n\", sizeof(arr)); // 400数组名的值就是首元素的地址，自然传递的时候是值传递，函数内部创建一个该指针的拷贝编译器会改写成这样void test(int* arr, int size)在32位系统下指针是4个字节，函数内部下标访问编译器就会自动转换成为*(arr+i)并且可以修改arr的值如果想按值传递数组，可以封装成struct对于多维数组，必须传入除了第一维以外所有维的长度。ElemType arr[m][n][o]...[x][y][z]和指针类型由这样的关系：ElemType(*const arr)[n][o]...[x][y][z] 数组的动态创建C++动态创建二维数组注意事项：12char* p = new char[5][4]; // 这是错误的定义方法char(*p)[4] = new char[5][4]; // 正确，语义等价","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://ranjiahao.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"可变参数列表简单模拟实现printf","slug":"可变参数列表简单模拟实现printf","date":"2019-06-02T16:00:00.000Z","updated":"2019-06-02T16:00:00.000Z","comments":true,"path":"2019/06/03/可变参数列表简单模拟实现printf/","link":"","permalink":"https://ranjiahao.github.io/2019/06/03/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0printf/","excerpt":"","text":"声明格式type VarArgFunc(type FixedArg1, type FixedArg2, …);参数分为固定参数和可选参数两部分。固定参数至少一个，可选参数数目不定。 stdarg宏可变参数列表是通过宏来实现的，定义于stdarg.h头文件中，是标准库的一部分。这个头文件声明了一个类型va_list和三个宏va_start、va_arg和va_end，我们可以定义一个类型为va_list的变量，与这几个宏配合使用来访问参数的值12345typedef char * va_list;#define _INTSIZEOF(n) ( (sizeof(n)+sizeof(int)-1) &amp; ~(sizeof(int)-1) )#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )#define va_arg(ap, type) ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )#define va_end(ap) ( ap = (va_list)0 )_INTSIZEOF宏考虑到某些系统需要内存地址对齐，由于参数列表中的可变参数部分没有原型，所以可变参数传递给函数的值都将执行缺省参数类型提升。从宏名看应按照sizeof(int)即堆栈粒度对齐，即参数在内存中的地址均为sizeof(int)=4的倍数。例如，若在1≤sizeof(n)≤4，则_INTSIZEOF(n)＝4；若5≤sizeof(n)≤8，则_INTSIZEOF(n)=8va_start宏根据(va_list)&amp;v得到第一个可变参数前的一个固定参数在堆栈中的内存地址，加上_INTSIZEOF(v)即v所占内存大小后，使ap指向固定参数后下个参数固定参数的地址用于va_start宏，因此不能声明为寄存器变量（地址无效）或作为数组类型（长度难定）va_arg宏取得type类型的可变参数值。首先ap+=_INTSIZEOF(type)即ap跳过当前可变参数而指向下个变参的地址；然后ap-_INTSIZEOF(type)得到当前变参的内存地址，类型转换后返回当前变参值va_end宏使ap不再指向有效的内存地址。该宏的某些实现定义为((void*)0)编译时不会为其产生代码，调用与否并无区别。但某些实现中va_end宏用于函数返回前完成一些必要的清理工作：如va_start宏可能以某种方式修改堆栈，导致返回操作无法完成，va_end宏可将有关修改复原；又如va_start宏可能对参数列表动态分配内存以便于遍历va_list，va_end宏可释放此前动态分配的内存。因此，从使用va_start宏的函数中退出之前，必须调用一次va_end宏函数内可多次遍历可变参数，但每次必须以va_start宏开始，因为遍历后ap指针不再指向首个变参 实现简易的myPrintf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 该函数无返回值，即不记录输出的字符数目；接受\"%c\"按字符输出、\"%d\"按整数输出、\"%s\"按字符串输出void printch(char c) &#123; putchar(c);&#125;void printdec(int i) &#123; if (i) &#123; printdec(i / 10); putchar(i % 10 + '0'); &#125;&#125;void printstr(char* str) &#123; while (*str) &#123; putchar(*str); ++str; &#125;&#125;void myPrintf(char* str, ...) &#123; va_list arg; va_start(arg, str); while (*str) &#123; if (*str == '%') &#123; ++str; switch (*str) &#123; case 'c': &#123; char c = va_arg(arg, char); printch(c); break; &#125; case 'd': &#123; int i = va_arg(arg, int); printdec(i); break; &#125; case 's': &#123; char* s = va_arg(arg, char*); printstr(s); break; &#125; default: break; &#125; ++str; &#125; else &#123; putchar(*str); ++str; &#125; &#125; va_end(arg);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"可变参数列表","slug":"可变参数列表","permalink":"https://ranjiahao.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"}]},{"title":"指针总结","slug":"指针总结","date":"2019-05-31T16:00:00.000Z","updated":"2019-05-31T16:00:00.000Z","comments":true,"path":"2019/06/01/指针总结/","link":"","permalink":"https://ranjiahao.github.io/2019/06/01/%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"指针的本质可执行程序是由指令、数据和地址组成的。当CPU访问内存单元时，必须把内存单元的地址加载到地址总线上，同时将内存电路的“读写控制”设置为有效，然后内存单元中的数据就通过数据总线流向了接受寄存器中，或者结果寄存器中的值流向目标内存单元中，这就是内存读写周期，而内存单元地址就是指针的值 定义指针类型的注意事项虽然类型名和*的组合是一种新的类型，但是编译器解释的时候会将*和后面的变量名结合1int* a, b, c;这样定义的话a为int类型指针，b和c还是int类型的变量全局指针变量的默认初始值是NULL，而non-static局部指针必须显示指定初始值；所以任何指针应在声明的同时初始化它，要么赋有效地址，要么置空 指针有实际意义的运算(1) 自增运算，表示指向下一个元素(2) 自减运算，表示指向上一个元素(3) 加整数i，表示向后递进i个元素(4) 减整数i，表示向前递进i个元素(5) 同类型指针相减，表示计算它们之间的元素个数(6) 指针赋值，把一个指针值赋给另一个指针(7) 指针比较（&gt; &lt; == != &gt;= &lt;=）标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针进行比较，但不允许与指向数组第一个元素之前的那个内存位置的指针进行比较(8) 取地址和反引用12345int arr[10] = &#123; 0 &#125;;printf(\"%p\\n\", arr); // arr是首元素的地址printf(\"%p\\n\", arr + 1); // 编译器改写成为arr+1*sizeof(int)printf(\"%p\\n\", &amp;arr); // &amp;arr是数组的地址，虽然值和arr一样但是表示的对象不同printf(\"%p\\n\", &amp;arr + 1);// 编译器改写成为&amp;arr+1*sizeof(arr)注意void*类型指针不能参与算术运算、不能解引用，只能赋值、比较、和sizeof()操作 字符指针的误区C/C++中默认char*表示字符串：1234char ch = 'a';char* pChar = &amp;ch;cout &lt;&lt; pChar &lt;&lt; endl; // 编译器会错把字符指针当作字符串cout &lt;&lt; *pChar &lt;&lt; endl; // 正确用法：输出一个字符在初始化字符数组的时候可以这样：12char message[] = &#123; \"Hello\" &#125;;char message2[] = \"Hello\";尽管看上去第二种好像是一个char*类型的字符串常量指针，实际上并不是，它和第一种写法是等价的也就是说当用于初始化一个字符数组时，它就是一个初始化列表，在其他任何地方，它都表示一个字符串常量比如这样：123char* p = \"Hello\";const char* pArr[3] = &#123; \"Hello\", \"C\", \"C++\" &#125;;// 指针数组char arr[][6] = &#123; \"Hello\", \"C\", \"C++\" &#125;; // 这里是值拷贝 数组指针数组指针它是一个指针，但它是指向数组的指针12345int(*ptr1)[10] = NULL;int(*ptr2)[10] = ptr1 + 1;printf(\"%d\\n\", ptr1); // 0printf(\"%d\\n\", ptr2); // 40printf(\"%d\\n\", ptr2 - ptr1);// 1数组指针加减整数，加减的基本单位是整个数组，如上述例子，ptr1为0，ptr2=ptr1+1，但是ptr2不为1，而是40，跳过整个含有10个int类型的数组；但是ptr2-ptr1还是1，并不是40，这是因为基本单位是整个数组（40个字节的数组）每40个字节，对应1个单位，所以结果为1 指针数组指针数组它是一个数组，但它的每一个元素是指针1234int a = 0;int b = 0;int c = 0;int* arr[3] = &#123; &amp;a, &amp;b, &amp;c &#125;;arr[3]中的三个元素都是int*类型的，其中数组名arr的值是一个二级指针","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://ranjiahao.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"类型转换","slug":"类型转换","date":"2019-05-21T05:14:00.000Z","updated":"2019-05-21T05:14:00.000Z","comments":true,"path":"2019/05/21/类型转换/","link":"","permalink":"https://ranjiahao.github.io/2019/05/21/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"整型提升C/C++的整型算术运算总是至少以缺省整型类型的精度来进行的为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型表达式的运算要在CPU内执行，CPU内整型运算器的操作数的字节长度一般是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时也要先转换为CPU内整型操作数的标准长度。通用CPU是难以直接实现两个8比特字节直接相加运算所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算如果是unsigned类型的那么高位补0如果是signed类型的那么高位补符号位这里需要注意的是char的长度≤short int的长度≤int的长度这意味着short int与int的长度相等的可能。这种情形下，unsigned short就无法提升为int表示，只能提升为unsigned int（一般情况下short占2个字节，某些时候short会占4个字节） 算术转换常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：long doubledoublefloatunsigned long longlong longunsigned longlongunsigned intint比如int+unsigned int，int类型的操作数就要先提升到unsigned int然后进行计算如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算警告： 但是算术转换要合理，要不然会有一些潜在的问题：12float f = 3.14;int num = f;//隐式转换，会有精度丢失这里发生的隐式类型转换是这样的：在内存上创建一个const int类型的只读临时变量，其数值是3（将小数点后面舍去）然后将其赋值给num，所以会有精度丢失 测试1234567891011char c;unsigned char uc;unsigned short us;c = 128;uc = 128;us = c + uc;printf(\"0x%x\\n\", us);us = (unsigned char)c + uc;printf(\"0x%x\\n\", us);us = c + (char)uc;printf(\"0x%x\\n\", us);第一次是这样的过程：c = 128;uc = 128;us = c + uc;由于c是char类型，uc是unsigned char类型他们相加就会提升到int类型：1111 1111 1111 1111 1111 1111 1000 0000 c（char类型提示规则：高位补符号位）0000 0000 0000 0000 0000 0000 1000 0000 uc（unsigned char提升规则：高位补0）0000 0000 0000 0000 0000 0000 0000 0000 这个int类型的计算结果放在寄存器中然后将寄存器中的值放入us中，由于us是unsigned short类型所以舍掉前两个字节，就成了0x0第二次是这样的过程：c = 128;uc = 128;us = (unsigned char)c + uc;同样c是char类型，uc是unsigned char类型，将c强转成unsigned类型，他们相加会提升到int类型：0000 0000 0000 0000 0000 0000 1000 0000 c（unsigned char提升规则：高位补0）0000 0000 0000 0000 0000 0000 1000 0000 uc（unsigned char提升规则：高位补0）0000 0000 0000 0000 0000 0001 0000 0000 这个int类型的计算结果放在寄存器中然后将寄存器中的值放入us中，由于us是unsigned short类型所以舍掉前两个字节，就成了0x10第三次是这样的过程：c = 128;uc = 128;us = c + (char)uc;同样c是char类型，uc是unsigned char类型，将c强转成unsigned char类型，他们相加会提升到int类型：1111 1111 1111 1111 1111 1111 1000 0000 c（char类型提示规则：高位补符号位）1111 1111 1111 1111 1111 1111 1000 0000 uc（char类型提示规则：高位补符号位）1111 1111 1111 1111 1111 1111 0000 0000 这个int类型的计算结果放在寄存器中然后将寄存器中的值放入us中，由于us是unsigned short类型所以舍掉前两个字节，就成了0xff00","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://ranjiahao.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"浮点数的存储","slug":"浮点数的存储","date":"2019-05-20T05:14:00.000Z","updated":"2019-05-20T05:14:00.000Z","comments":true,"path":"2019/05/20/浮点数的存储/","link":"","permalink":"https://ranjiahao.github.io/2019/05/20/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8/","excerpt":"","text":"IEEE 754规定任意一个二进制浮点数V可以表示成下面的形式：V=(−1)S×M×2EV=(-1)^S×M×2^EV=(−1)S×M×2E例如下图是32位单精度浮点数存储模型（64位的双精度浮点数最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M）其中S表示符号位，当S=0，V为正数；当S=1，V为负数M表示有效数字，1≤M&lt;2（规约形式）E表示指数位eg:十进制6.125，用拈加法写成二进制是110.001，等价于1.10001×22。可以得出S=0，M=1.10001，E=2十进制-6.125，写成二进制是-110.001，等价于-1.10001×22。那么，S=1，M=1.10001，E=2由于M默认这个数的第一位总是1，因此可以被舍去，只保存后面的小数部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，就可以保存24位有效数字指数偏差E为一个无符号整数，如果是单精度浮点数，E为8位，它的取值范围为0~255；如果是双精度浮点数E为11位，它的取值范围为0~2047。科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127(01111111)对于11位的E，这个中间数是1023。 比如，210的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001，127在这里叫做指数偏移值规约形式的浮点数如果浮点数中指数部分的编码值0&lt;E≤2e−20&lt;E\\leq2^e-20&lt;E≤2e−2其中的e为存储指数的比特的长度（E不全为0或1）比如，单精度(32-bit)的规约形式浮点数在指数偏移值的值域为[00000001,11111110]，M的范围是[000…000,111…111]=&gt;23-biteg:十进制0.5的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0×2(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:0 01111110 00000000000000000000000非规约形式的浮点数E全为0，M非零，这时，浮点数的指数E等于-126（或者-1022）即为真实值，需要注意的是这里并不是-127（这样是为了保证中间数据近似连续）有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数（规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0）这样做是为了表示±0，以及接近于0的很小的数字±0E全为0，M全为0，表示±0（正负取决于符号位S）±∞E全为1，M全为0，表示±∞（正负取决于符号位S）NaNE全为1，M不全为0，表示这个数不是一个数（NaN） 测试1234567int n = 9;float* pFloat = (float*)&amp;n;printf(\"n的值为：%d\\n\", n);printf(\"*pFloat的值为：%f\\n\", *pFloat);*pFloat = 9.0;printf(\"num的值为：%d\\n\", n);printf(\"*pFloat的值为：%f\\n\", *pFloat);第一部分：int类型的9在内存中是这样存储的（32位环境）0000 0000 0000 0000 1001将它的地址强转成float类型后：其符号位S=08位的指数E=0000 0000由于指数为全是0，它属于非规约形式的浮点数，尾数小于1且大于0，所以M=0.00000000000000000001001（小数点后有23位）因此，浮点数V就写成：V=(-1)0× 0.00000000000000000001001×2(-126)=1.001×2(-146)它表示一个接近于0的很小的数字，十进制表示就是0.000000第二部分：float类型的9.0在内存中是这样存储的（32位环境）9.0=&gt;1001.0=&gt;1.001×23=&gt; s=0, M=1.001,E=3+127=1300 10000010 001 0000 0000 0000 0000 0000强转成十进制，就是1091567616","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://ranjiahao.github.io/categories/C-C/"}],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"https://ranjiahao.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"}]}]}