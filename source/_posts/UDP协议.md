---
title: UDP协议
date: 2020-07-06 00:00:00
categories: Linux
tags:
    - UDP
toc: true
---

* 无连接：UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，知道了对端的IP和端口就可以随时发送数据
* 不可靠：应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上，即使出现网络拥堵，UDP也无法进行流量控制等避免网络堵塞行为，此外，传输途中即使出现丢包，UDP也不负责重发，也不保证包序，需要应用层来保证这些，报头短，不需要可靠传输，所以传输速度快
* 面向数据报：应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并（如果发送端调用一次sendto，发送100个字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节；而不能循环调用10次recvfrom，每次接收10个字节）不能够灵活的控制读写数据的次数和数量
* UDP没有真正意义上的发送缓冲区，sendto会直接将整个报文交给内核，由内核将数据传给网络层协议后进行后续的传输动作。UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃
* 全双工通信：UDP的socket既能读，也能写，udp在协议栈层面实现了广播功能：通过给一个ip地址发送数据，实现将数据发送到局域网所有主机  
* 通常被用在包总量较少的通信（DNS、SNMP等）、即时通信、限定于LAN等特定网络中的应用通信、广播通信（广播，多播）RIP、DHCP等

协议格式：
![img1](img1.png)
16位包长度：限制了UPD报文总长度，包含包头在内不能超过64K，如果需要传输的数据超过64K，就要在应用层手动分包，多次发送，并在接收端手动拼装
16位校验和：数据传输过程中会产生误码，0可能变为1，1可能变为0，所以需要校验，以16比特为单位对报文进行取反求和，若进位则将进位加到校验和字段中。接收端接收到校验和后，执行相同的操作，得到检验和结果为全1，则数据未出错
由于UDP首部只有五元组中的源端口和目标端口，余下三项都在IP首部里，若其他三项信息被破坏则就可能导致该收包的应用收不到包，不该收到包的应用却收到了包，为了解决这个问题，就引入了伪首部的概念，此外IPv6的IP首部无校验和字段，TCP或UDP通过伪首部，得以对5元组进行校验，实现即使在IP首部并不可靠的情况下仍然能提供可靠的通信传输
伪首部：
![image-20200820152924511](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200820152924511.png)
伪首部的明智之处在于，用它来计算校验和，我们能提供这些保护，而不必真的发送为报头本身的那些域。从而消除了用在伪真报头中的TCP的IP域的重复使用；避免了冗余和带宽的浪费。其缺点在于这种计算校验和的方法需要更多的时间和精力