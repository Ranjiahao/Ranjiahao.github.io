<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ranjiahao.github.io/"/>
  <updated>2020-06-16T16:00:00.000Z</updated>
  <id>https://ranjiahao.github.io/</id>
  
  <author>
    <name>Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程的创建、终止、等待、分离</title>
    <link href="https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/"/>
    <id>https://ranjiahao.github.io/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E3%80%81%E7%AD%89%E5%BE%85%E3%80%81%E5%88%86%E7%A6%BB/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-06-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线程都是轻量级进程，内核并不知道用户级线程的存在，该用户级线程的实现是通过用户级线程库POSIX来完成的，链接这些线程函数库时要加上&quot;-lpthread&quot;选项，指定要链接的库名</p><h1 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h1><blockquote><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code><br>thread: 输出型参数返回线程ID（用户态线程ID）<br>attr: 设置线程的属性，attr为NULL表示使用默认属性<br>start_routine: 是个函数地址，线程启动后要执行的函数<br>arg: 传给线程启动函数的参数<br>成功返回0；失败返回错误码<br>传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。pthreads函数出错时不会设置全局变量errno（大部分其他POSIX函数会这样做）而是将错误码通过返回值返回pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，读取返回值要比读取线程内的errno变量的开销小</p></blockquote><p>pthread_t实际是一个unsigned long类型，其本质就是一个进程地址空间上的一个地址，NPTL提供<code>pthread_t pthread_self(void);</code>函数来查看<br>创建一个线程就是创建一个pcb，但是线程中还有一些独有的数据，加载动态库就是在进程地址空间中的共享区，而我们用的NPTL函数本身就是动态库函数，所以线程独有的信息都在共享区，操作系统在共享区开辟了一块空间来存放每个线程独有的数据（栈、线程局部存储信息、线程在用户态的描述）而pthread_t就指向这个空间的地址，也可以使用命令pstack [进程id(线程组id)]查看<br>我们平常使用ps -L 查看到的pid就是线程组id，而LWP就是调度实体的线程id（内核级线程id）也叫轻量级进程id，Linux提供了gettid系统调用来返回其线程id（内核级线程id），可是glibc并没有将该系统调用封装起来，在开放接口来共程序员使用。如果确实需要获得线程ID，可以采用如下方法：<code>#include &lt;sys/syscall.h&gt; pid_t tid; tid = syscall(SYS_gettid);</code></p><h1 id="线程终止"><a class="markdownIt-Anchor" href="#线程终止"></a> 线程终止</h1><ol><li><p>从线程 return，如果是从主线程return，相当于exit，所有线程都结束</p></li><li><p>线程自己调用pthread_exit来终止自己</p></li></ol><blockquote><p><code>void pthread_exit(void *value_ptr);</code><br>value_ptr: 输出型参数，该线程退出时的退出码，注意不要指向一个局部变量，因为当线程的调用函数退出时，局部变量也就销毁了</p></blockquote><ol start="3"><li>一个线程可以调用pthread_cancel终止同一进程中的另一进程</li></ol><blockquote><p><code>int pthread_cancel(pthread_t thread);</code><br>参数传pthread_self()时终止自己，成功返回0，失败返回错误码</p></blockquote><h1 id="进程等待"><a class="markdownIt-Anchor" href="#进程等待"></a> 进程等待</h1><p>当一个线程退出时，如果空间没有被释放，新创建的线程也不会利用退出线程的资源，会发生内存泄漏，因此新线程在退出时主线程要通过等待的方式回收退出线程的资源并获取新线程退出时的状态</p><blockquote><p><code>int pthread_join(pthread_t thread, void **value_ptr);</code><br>value_ptr: 由于线程终止时返回一个指针，这个指针一般指向全局变量或者malloc分配的空间，所以进程等待接收参数的时候需要传入一个一级指针的地址来接收参数，成功返回0；失败返回错误码</p></blockquote><p>注意：该函数是以阻塞的方式进行等待的，thread线程以不同的方式终止，得到的线程终止状态也是不同的：</p><ul><li>线程以return的方式终止，value_ptr指向的空间中保存return返回的值</li><li>线程以pthread_exit的方式终止，value_ptr指向的空间中保存传给pthread_exit的参数</li><li>线程被别的线程调用pthread_cancel的方式终止，value_ptr指向的空间中保存常数PTHREAD_CANCELED，<code>#define PTHREAD_CANCELED (void\*)-1;</code></li><li>如果不关心新线程的退出状态，直接将value_ptr设置为NULL即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry1</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry2</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadEntry3</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread3\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread3 is running~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2, t3;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, ThreadEntry1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, ThreadEntry2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t3, <span class="literal">NULL</span>, ThreadEntry3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret;</span><br><span class="line">    pthread_join(t1, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread1 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_join(t2, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread2 return, return code %d\n"</span>, *(<span class="keyword">int</span>*)ret);</span><br><span class="line">    <span class="built_in">free</span>(ret);</span><br><span class="line">    pthread_cancel(t3);</span><br><span class="line">    pthread_join(t3, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == PTHREAD_CANCELED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Thread3 return, return code PTHREAD_CANCELED\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"></p><p>我们说父子进程的执行顺序不一定，但是我们却很难看到子进程先于父进程执行，这里却很容易可以看到线程执行顺序不一定，这是因为每次创建一个进程的代价比较大，所以父进程就有很大的概率去执行，而线程的创建代价比较小，所以很容易看到执行顺序不一定这个结果，但是线程等待是串行的</p><h1 id="线程分离"><a class="markdownIt-Anchor" href="#线程分离"></a> 线程分离</h1><p>在默认情况下创建的线程是joinable的，线程退出后，要对其进行pthread_join操作，否则无法回收资源，造成内存泄漏，如果不关心线程的返回值，那么join就是一个负担，这个时候我们可以告诉操作系统线程退出时，由操作系统自动回收资源</p><blockquote><p><code>int pthread_detach(pthread_t thread);</code><br>也可以是线程自己分离：pthread_detach(pthread_self());一个分离的线程异常退出，整个进程也会异常退出，joinable和detached是两个对立的状态，两者不可能同时存在</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中，目前线程的实现是用Native POSIX Thread Libary，这种实现下每个用户级线程对应一个内核中的调度实体即内核级线程，拥有自己的进程描述符（task_struct结构体）在CPU的角度，一个PCB（进程描述符）就代表一个进程，Linux下的线
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://ranjiahao.github.io/2020/06/16/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-15T16:00:00.000Z</published>
    <updated>2020-06-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1><p>进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过pcb实现的，所以linux下线程就是一个pcb，一个进程中的线程公用同一个虚拟地址空间，相较与传统pcb更加轻量化，也被称为轻量级进程。操作系统资源分配是直接分配给整个线程组，这个线程组就是进程，所以进程是资源分配的基本单位，而线程是进程实际运作的基本单位，cpu通过调度pcb来实现程序的调度，所以线程是调度的基本单位，ps -L中LWP为轻量级进程id，pid为这个线程组id<br>一个进程中的线程共享：</p><ol><li>同一虚拟地址空间：本质共享同一页表</li><li>文件描述符表：一个线程修改了一个文件，其他的线程访问到的文件也都改变</li><li>每种信号的处理方式(SIG_IGN、SIG_DFL或者自定义的信号处理函数)</li><li>未决信号集：只要进程收到了信号，也就意味着所有线程收到了信号</li><li>当前工作目录、用户id和组id</li></ol><p>由于进程中的各个线程共用同一个虚拟地址空间，为了保证程序的合理性所以各个线程有自己的信息：</p><ol><li>线程ID</li><li>栈：防止调用栈混乱</li><li>一组寄存器：线程的上下文信息</li><li>errno：防止线程的errno被另一个线程覆盖</li><li>信号屏蔽字：防止线程在执行重要操作时被打断</li><li>调度优先级：各线程要被调度，就必须有优先级</li></ol><h1 id="线程的优缺点"><a class="markdownIt-Anchor" href="#线程的优缺点"></a> 线程的优/缺点</h1><p>优点：</p><ul><li>线程的创建与销毁成本更低，创建一个进程，我们需要给他分配虚拟地址空间，这个空间占用了一部分资源。创建一个线程，不需要分配虚拟地址空间，节约资源，增快了效率，销毁也比较快</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多，不需要切换页表，只用切换一小部分数据，效率较高</li><li>由于线程组中线程公用同一虚拟地址空间，所以相比进程线程间通信比较方便，只需知道地址就能访问同一空间</li><li>能充分利用多处理器的可并行数量，比如4核CPU，需要不停歇的进行CPU的运算操作，用四个线程运算操作，CPU占用率可达到400%（Linux下）充分利用了硬件资源，处理CPU密集型程序通常执行流个数为CPU核心数+1，若创建线程很多而CPU资源不够多，则大量进程切换调度成本会提高</li><li>I/O密集型应用，为了提高性能，将I/O操作重叠，多任务并行处理，多磁盘可以实现同时处理，线程可以同时等待不同的I/O操作</li></ul><p>缺点：</p><ul><li>缺乏保护访问控制、健壮性降低，需要考虑线程安全问题，异常以及系统调用exit会直接针对整个进程</li><li>性能损失，若CPU密集型程序线程的数量比可用的处理器多则增加了额外的同步和调度开销</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程与线程&quot;&gt;&lt;/a&gt; 进程与线程&lt;/h1&gt;&lt;p&gt;进程是一个线程组，线程是进程中的一条执行流（如，一个进程中的main函数，是由线程执行起来的），这个执行流在linux下是通过p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="线程" scheme="https://Ranjiahao.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>智能指针模拟实现</title>
    <link href="https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ranjiahao.github.io/2020/06/13/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源</p><h1 id="auot_ptr"><a class="markdownIt-Anchor" href="#auot_ptr"></a> auot_ptr</h1><p>模拟实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~AutoPtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt;&amp; ap)</span><br><span class="line">        : _ptr(ap._ptr) &#123;</span><br><span class="line">        <span class="comment">// 转移资源管理权</span></span><br><span class="line">        ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    AutoPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt;&amp; ap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="comment">// 转移资源管理权</span></span><br><span class="line">            _ptr = ap._ptr;</span><br><span class="line">            ap._ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 像指针一样的操作</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bug：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AutoPtr&lt;T&gt; ap(<span class="keyword">new</span> T);</span><br><span class="line">AutoPtr&lt;T&gt; copy(ap);<span class="comment">// 拷贝后把ap对象的指针赋空了，通过ap对象访问资源时就会出bug（除非每次判断ap._ptr是否不为空）</span></span><br></pre></td></tr></table></figure><p>所以auto_ptr根本用不了</p><h1 id="c11-unique_ptr"><a class="markdownIt-Anchor" href="#c11-unique_ptr"></a> C++11 unique_ptr</h1><p>也叫scoped_ptr(boost库)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UniquePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UniquePtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~UniquePtr() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr并没有去实现类似scoped_array的unique_array，因为标准库中有vector</span></span><br><span class="line">    <span class="comment">// T&amp; operator[](size_t index) &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="comment">// const T&amp; operator[](size_t index) const &#123;</span></span><br><span class="line">    <span class="comment">//     return _ptr[index];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C++11</span></span><br><span class="line">    UniquePtr(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UniquePtr &amp; <span class="keyword">operator</span>=(UniquePtr&lt;T&gt; <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比auto_ptr，简单粗暴的防拷贝，勉强可以使用，但没有从根本解决问题</p><h1 id="c11-shared_ptr"><a class="markdownIt-Anchor" href="#c11-shared_ptr"></a> C++11 shared_ptr</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SharedPtr(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        : _ptr(ptr)</span><br><span class="line">        , _pRefCount(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">        , _pMutex(<span class="keyword">new</span> mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~SharedPtr() &#123; Release(); &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp)</span><br><span class="line">        : _ptr(sp._ptr)</span><br><span class="line">        , _pRefCount(sp._pRefCount)</span><br><span class="line">        , _pMutex(sp._pMutex) &#123;</span><br><span class="line">        AddRefCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            Release();</span><br><span class="line">            <span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pRefCount = sp._pRefCount;</span><br><span class="line">            _pMutex = sp._pMutex;</span><br><span class="line">            AddRefCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁或者使用加1的原子操作</span></span><br><span class="line">        _pMutex-&gt;lock();</span><br><span class="line">        ++(*_pRefCount);</span><br><span class="line">        _pMutex-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* _pRefCount; <span class="comment">// 引用计数</span></span><br><span class="line">    T* _ptr;         <span class="comment">// 指向管理资源的指针</span></span><br><span class="line">    mutex* _pMutex;  <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="仿函数删除器"><a class="markdownIt-Anchor" href="#仿函数删除器"></a> 仿函数删除器</h1><p>上面代码析构函数是用delete来释放资源的，但是我们可能用以下几种方式申请资源：<br><code>SharedPtr&lt;int&gt; p(new int);</code><br><code>SharedPtr&lt;FILE&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int&gt; mp = ((int*)malloc(sizeof(int)));</code><br>这时候使用delete来释放，可能会出错，这时候就需要自定义删除方式，我们只需对上面代码稍加修改即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义我们自己的删除方式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Delete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Free</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Close</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE*&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fclose(p);</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">D</span> = <span class="title">Delete</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他都不变，修改析构函数即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 引用计数减1，如果减到0，则释放资源</span></span><br><span class="line">        _pMutex.lock();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            D()(_ptr); <span class="comment">// 创建匿名对象，并调()重载</span></span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex.unlock();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：<br><code>SharedPtr&lt;int&gt; np(new int);</code><br><code>SharedPtr&lt;FILE, Close&lt;FILE&gt;&gt; fp(fopen(&quot;./test&quot;,&quot;r&quot;));</code><br><code>SharedPtr&lt;int, Free&lt;int&gt;&gt; mp((int*)malloc(sizeof(int)));</code></p><h2 id="shared_ptr的循环引用"><a class="markdownIt-Anchor" href="#shared_ptr的循环引用"></a> shared_ptr的循环引用</h2><p>shared_ptr并非完美，也有小缺陷</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _prev;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node1(<span class="keyword">new</span> ListNode);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;ListNode&gt; node2(<span class="keyword">new</span> ListNode);</span><br><span class="line">    node1-&gt;_next = node2;</span><br><span class="line">    node2-&gt;_prev = node1;</span><br><span class="line">&#125; <span class="comment">// 这里会导致内存泄漏</span></span><br></pre></td></tr></table></figure><p><img src="img1.png" alt="img1"><br>出作用域后node1和node2对象被释放<br><img src="img2.png" alt="img2"><br>但是引用计数不为0，_date不会被释放，造成内存泄漏</p><p>当然,C++11库中也给出了响应的解决方法,就是weak_ptr</p><h2 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h2><p>weak_ptr要和shared_ptr搭配使用，在进行如上的赋值时，并不进行引用计数的加加操作，这也保证了在释放的时候不会因为引用计数不为0而没有正确释放，造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _data;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _next;</span><br><span class="line">    ~ListNode() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~ListNode()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="c11-守卫锁"><a class="markdownIt-Anchor" href="#c11-守卫锁"></a> C++11 守卫锁</h1><p>lock_guard利用RAII思想，通过对象的生命周期控制锁的生命周期构造加锁，析构解锁，防止死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Mutex</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LockGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LockGuard(Mutex&amp; mtx)</span><br><span class="line">        :_mutex(mtx) &#123;</span><br><span class="line">        _mutex.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    ~LockGuard() &#123;</span><br><span class="line">        _mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    LockGuard(<span class="keyword">const</span> LockGuard&lt;Mutex&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 必须使用引用，保证同一个互斥量对象</span></span><br><span class="line">    Mutex&amp; _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fuc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="comment">// 进入作用域构造lg对象，加锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        LockGuard&lt;mutex&gt; lg(mtx);</span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">        <span class="comment">// ...code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出了作用域析构lg对象，解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAII：利用对象生命周期来控制程序资源，在构造时获取资源，析构的时释放资源&lt;/p&gt;&lt;h1 id=&quot;auot_ptr&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#auot_ptr&quot;&gt;&lt;/a&gt; auot_ptr&lt;/h1&gt;&lt;p&gt;模拟实现：&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://Ranjiahao.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>多态及其原理</title>
    <link href="https://ranjiahao.github.io/2020/06/08/%E5%A4%9A%E6%80%81%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://ranjiahao.github.io/2020/06/08/%E5%A4%9A%E6%80%81%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态的构成条件"><a class="markdownIt-Anchor" href="#多态的构成条件"></a> 多态的构成条件</h1><ol><li>必须通过父类的指针或者引用调用虚函数</li><li>被调用的函数必须是虚函数，且子类必须对父类的虚函数进行重写</li><li>inline、静态成员、构造函数不可为虚函数</li></ol><h1 id="虚函数的重写"><a class="markdownIt-Anchor" href="#虚函数的重写"></a> 虚函数的重写</h1><p>子类中有一个跟父类完全相同的虚函数(返回值类型、函数名字、参数列表完全相同)称子类的虚函数重写了基类的虚函数。（虚函数同样存在于代码段）</p><p>重写父类虚函数时，子类虚函数不加virtual关键字时，也可以构成重写（继承后父类虚函数被继承下来了在子类依旧保持虚函数属性）但不建议这样使用</p><p><strong>两个例外</strong></p><ol><li>协变（父类与子类虚函数返回值类型不同)<br>父类虚函数返回有继承关系的父类对象的指针或者引用，子类虚函数返回有继承关系子类对象的指针或者引用时，称为协变</li><li>析构函数的重写(子类与父类析构函数的名字不同)<br>若父类的析构函数为虚函数，则子类析构函数只要定义，无论是否加virtual，都与父类析构函数构成重写，编译后析构函数的名称统一处理成destructor</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Person()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person* p1 = <span class="keyword">new</span> Person;</span><br><span class="line">    Person* p2 = <span class="keyword">new</span> Student;</span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// Person()</span></span><br><span class="line">    <span class="keyword">delete</span> p2; <span class="comment">// Student() ~Person()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c11-override和final"><a class="markdownIt-Anchor" href="#c11-override和final"></a> C++11 override和final</h1><p>函数名字写错无法构成重载，类似这种错误在编译期间是不会报出的，所以C++11提供了override和final两个关键字，可以帮助用户检测是否重写</p><p>父类中final:修饰虚函数，表示该虚函数不能再被继承<br><code>virtual void Fuc() final {}</code><br>子类中override:检查子类虚函数是否重写了父类某个虚函数，如果没有编译会报错<br><code>virtual void Fuc() override {}</code></p><h1 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h1><p>虚函数后面加上 =0，则此函数为纯虚函数。包含纯虚函数的类为抽象类，不能实例化出对象。只有子类继承后重写纯虚函数，才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承</p><h1 id="多态的原理"><a class="markdownIt-Anchor" href="#多态的原理"></a> 多态的原理</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fuc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span>:</span> <span class="keyword">public</span> AAA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(AAA* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;Fuc3();</span><br><span class="line">    a-&gt;Fuc2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AAA a;</span><br><span class="line">    BBB b;</span><br><span class="line">    Test(&amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VS下调试我们发现：<br>父类a对象中除了_a成员，还多一个_vfptr的void**类型指针在对象前面（前后跟平台有关）这个指针我们叫做虚函数表指针，一个含有虚函数的类中至少有一个虚函数表指针，虚函数的地址要被放到虚函数表中</p><p>子类b对象中除了_b成员，也多一个_vfptr指针（两个指针不同）<br><img src="img1.png" alt="img1"></p><h1 id="虚函数表"><a class="markdownIt-Anchor" href="#虚函数表"></a> 虚函数表</h1><p>本质是一个存虚函数指针的指针数组（存在于代码段、编译阶段生成），此数组最后面放了一个nullptr</p><p>只有虚函数指针才会放在这个表中（为了实现多态）</p><p>Func3完成了重写，所以b的虚表中存的是覆盖的BBB::Func3（重写是语法层的叫法，覆盖是原理层的叫法）</p><p>子类将父类中的虚表内容拷贝一份到子类虚表中，如果子类重写了基类中某个虚函数，就用子类自己的虚函数指针覆盖虚表中父类的虚函数指针，子类自己新增加的虚函数按其在子类中的声明次序增加到子类虚表的最后</p><h2 id="多继承中的虚函数表"><a class="markdownIt-Anchor" href="#多继承中的虚函数表"></a> 多继承中的虚函数表</h2><p>虚表个数： 直接父类的个数<br>子类新增的虚函数：存放在第一个直接父类的虚表末尾(按声明顺序存放）<br>如：</p><p>Base1: 函数func1(virtual),func2(virtual) 数据b1</p><p>Base2: 函数func1(virtual),func2(virtual) 数据b2</p><p>Derive: 函数func1(virtual),func3(virtual) 数据d1----&gt;内存模型：<br><img src="img2.png" alt="img2"></p><h2 id="为什么达到多态必须父类对象的指针或引用调用虚函数"><a class="markdownIt-Anchor" href="#为什么达到多态必须父类对象的指针或引用调用虚函数"></a> 为什么达到多态必须父类对象的指针或引用调用虚函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    a-&gt;Fuc3();</span><br><span class="line">&#x2F;&#x2F; a中存的是b对象的指针，将a移动到eax中</span><br><span class="line">00CF2138  mov         eax,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; [eax]是取eax值指向的内容，b对象头4个字节（虚表指针）移动到了edx</span><br><span class="line">00CF213B  mov         edx,dword ptr [eax]  </span><br><span class="line">00CF213D  mov         esi,esp  </span><br><span class="line">00CF213F  mov         ecx,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; 由于虚标指针数组第二个是Fuc3函数，通过edx+4找到函数指针，放到eax</span><br><span class="line">00CF2142  mov         eax,dword ptr [edx+4]  </span><br><span class="line">&#x2F;&#x2F; call eax中的函数指针，运行时在对象中找函数地址</span><br><span class="line">00CF2145  call        eax  </span><br><span class="line">00CF2147  cmp         esi,esp  </span><br><span class="line">00CF2149  call        __RTC_CheckEsp (0CF12EEh)  </span><br><span class="line">    a-&gt;Fuc2();</span><br><span class="line">00CF214E  mov         ecx,dword ptr [a]  </span><br><span class="line">&#x2F;&#x2F; 由于Fuc2不是虚函数，编译时已经从符号表确定了函数地址</span><br><span class="line">00CF2151  call        AAA::Fuc2 (0CF1546h)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BBB b;</span><br><span class="line">    b.Fuc3(); <span class="comment">// 虽然Fuc3是虚函数但是由对象直接调用，不满足多态直接call地址</span></span><br><span class="line">    <span class="comment">// 001D2A4A  lea         ecx,[b]  </span></span><br><span class="line"><span class="comment">// 001D2A4D  call        BBB::Fuc3 (01D1541h)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印虚函数表"><a class="markdownIt-Anchor" href="#打印虚函数表"></a> 打印虚函数表</h2><p>VS监视窗口中看不见Func3和Func4，只能自定义打印虚表函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AAA::Fuc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBB</span>:</span> <span class="keyword">public</span> AAA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fuc4</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BBB::Fuc4()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVTable</span><span class="params">(<span class="keyword">void</span>(**vTable)())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"虚表地址："</span> &lt;&lt; vTable &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vTable[i] != <span class="literal">nullptr</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 可能死循环，因为编译器有时在虚表最后面没有放nullptr，生成-&gt;清理解决方案，编译即可</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 第"</span> &lt;&lt; i &lt;&lt; <span class="string">"个虚函数地址为：0x"</span> &lt;&lt; vTable[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        vTable[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BBB b;</span><br><span class="line">    <span class="comment">// VS下对象模型前四个字节是虚标指针，所以强转成int*在解引用去除前四个字节</span></span><br><span class="line">    <span class="comment">// 再强转成void(**)()类型的函数指针</span></span><br><span class="line">    <span class="keyword">void</span>(**vTableb)() = (<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)&amp;b);</span><br><span class="line">    PrintVTable(vTableb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多继承子类虚函数表访问方法"><a class="markdownIt-Anchor" href="#多继承子类虚函数表访问方法"></a> 多继承子类虚函数表访问方法</h2><p>如：<br>Base1: 函数func1,func2(virtual) 数据b1</p><p>Base2: 函数func1,func2(virtual) 数据b2</p><p>Derive: 函数func1,func3(virtual) 数据d1</p><p><strong>访问Derive中Base2的虚表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">// 取出d的地址，强转成 char* 加上Base1大小个字节</span></span><br><span class="line"><span class="comment">// 强转成 int* 再解引用取出前四个字节，其内容就是虚表指针</span></span><br><span class="line">PrintVTable((<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)&amp;d + <span class="keyword">sizeof</span>(Base1))));</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">// 利用切片操作</span></span><br><span class="line">Base2* pd = &amp;d;</span><br><span class="line">PrintVTable((<span class="keyword">void</span>(**)())(*(<span class="keyword">int</span>*)pd));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态的构成条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多态的构成条件&quot;&gt;&lt;/a&gt; 多态的构成条件&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;必须通过父类的指针或者引用调用虚函数&lt;/li&gt;&lt;li&gt;被调用的函数必须是虚函数，且子类必须对父类的虚函数进
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="多态" scheme="https://Ranjiahao.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数" scheme="https://Ranjiahao.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>继承总结</title>
    <link href="https://ranjiahao.github.io/2020/06/07/%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/"/>
    <id>https://ranjiahao.github.io/2020/06/07/%E7%BB%A7%E6%89%BF%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-06-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>继承机制是代码复用重要的手段，允许在保持原有类特性的基础上进行扩展，产生子类</p><h1 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h1><p>public继承：继承父类中的public和protected成员，访问限定符不变</p><p>private继承：继承父类中的public和protected成员，访问限定符变为private</p><p>protected继承：继承父类中的public和protected成员，访问限定符变为protected</p><p><strong>基类的private成员，也被继承在派生类中，但不可访问</strong><br>class默认继承方式是private，struct默认继承方式是public</p><h1 id="基类和派生类对象赋值转换"><a class="markdownIt-Anchor" href="#基类和派生类对象赋值转换"></a> 基类和派生类对象赋值转换</h1><ul><li>子类对象/地址可以直接赋值给父类的对象/引用/指针，会进行切片操作</li><li>父对象不能赋值给子类对象，但父类指针可以通过强制类型转换赋值给子类指针，但是可能出现越界</li></ul><h1 id="继承中的作用域"><a class="markdownIt-Anchor" href="#继承中的作用域"></a> 继承中的作用域</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">int</span> _no = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _no = <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    <span class="comment">// 父类和子类都有独立的作用域</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.Student::_no &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.Person::_no &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 子类成员会屏蔽父类对同名成员的直接访问</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s._no &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="派生类的默认成员函数"><a class="markdownIt-Anchor" href="#派生类的默认成员函数"></a> 派生类的默认成员函数</h1><ul><li><p>构造函数：</p><p>子类构造函数先自动调用父类构造函数初始化父类部分的成员</p><p>如果父类没有默认构造函数，则必须在子类构造函数的初始化列表阶段显示调用</p></li><li><p>拷贝构造函数：</p><p>默认拷贝构造会自动调用父类的拷贝构造</p><p>显式定义子类的拷贝构造，编译器默认调用的父类构造函数</p><p>显式调用父类拷贝构造，会进行切片操作</p></li><li><p>operator=：</p><p>默认生成的赋值运算符会自动调用父类的赋值运算符</p><p>显式定义子类的赋值运算符， 编译器不会自动调用父类的赋值运算符</p></li><li><p>析构函数：</p><p>父类与子类析构构成同名隐藏：编译器底层修改的析构函数的名字，为了支持多态</p><p>子类析构函数会在被调用完成后自动调用父类的析构函数清理基类成员。保证子类对象先清理子类成员再清理父类成员的顺序</p><p>父类析构在任何情况下编译器都会自动调用，不需要显式调用</p></li></ul><h1 id="c11-final"><a class="markdownIt-Anchor" href="#c11-final"></a> C++11 final</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个不可继承的类</span></span><br><span class="line"><span class="comment">// C++98中构造函数私有化，子类中调不到父类的构造函数。无法继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NonInherit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NonInherit() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11中final禁止继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonInherit</span> <span class="title">final</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承与友元-静态"><a class="markdownIt-Anchor" href="#继承与友元-静态"></a> 继承与友元、静态</h1><p>友元关系不能继承，子类友元不能访问子类私有和保护成员</p><p>父类定义static静态成员，则整个继承体系里面只有一个这样的成员</p><h1 id="虚拟继承"><a class="markdownIt-Anchor" href="#虚拟继承"></a> 虚拟继承</h1><p>菱形继承有数据冗余和二义性的问题，所以虚拟继承可以解决数据冗余和二义性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class="line">    D x;</span><br><span class="line">    x._a = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class="line">    x.B::_a = <span class="number">3</span>;</span><br><span class="line">    x.B::_a = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class B: public A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// class C: public A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通菱形继承模型</p><p><img src="img1.png" alt="img1"></p><p>虚拟菱形继承模型</p><p><img src="img2.png" alt="img2"></p><h1 id="继承与组合"><a class="markdownIt-Anchor" href="#继承与组合"></a> 继承与组合</h1><ul><li>继承是一种is-a的关系。每个子类对象都是一个父类对象。</li><li>组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。</li></ul><p>继承生成子类的复用被称为白箱复用：在继承方式中，父类的内部细节对子类可见 ，一定程度破坏了父类封装，基类的改变，对子类影响大。子类和父类依赖关系强，耦合度高</p><p>对象组合是另一种复用选择，要求被组合的对象具有良好定义的接口。被称为黑箱复用：对象的内部细节不可见。组合类之间没有很强的依赖关系，耦合度低。</p><p><mark>优先使用对象组合，而不是类继承。</mark></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继承机制是代码复用重要的手段，允许在保持原有类特性的基础上进行扩展，产生子类&lt;/p&gt;&lt;h1 id=&quot;继承方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承方式&quot;&gt;&lt;/a&gt; 继承方式&lt;/h1&gt;&lt;p&gt;public继承：继承父类中的public和
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://Ranjiahao.github.io/categories/C-C/"/>
    
    
      <category term="继承" scheme="https://Ranjiahao.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>僵尸进程与孤儿进程详解</title>
    <link href="https://ranjiahao.github.io/2020/06/06/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ranjiahao.github.io/2020/06/06/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h1><p>linux中，正常情况下，子进程和父进程是一个异步过程，父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait系列系统调用取得子进程的终止状态。如果子进程退出，而父进程并没有调用wait获取子进程的状态信息，那么子进程的task_struct结构及少数资源仍然保存在系统中，这个子进程称为僵死进程。之所以保留task_struct，是因为task_struct里面保存了进程的pid、退出码、以及一些统计信息，父进程很可能会关心这些信息。比如$?变量就保存了最近一个退出的前台进程的退出码，这个退出码就来自于僵尸进程的task_struct结构</p><h2 id="观察一个僵尸进程"><a class="markdownIt-Anchor" href="#观察一个僵尸进程"></a> 观察一个僵尸进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* zombie.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">     <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         perror(<span class="string">"fork error"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"parent id:%d\n"</span>, getpid());</span><br><span class="line">         sleep(<span class="number">10</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"child id:%d\n"</span>, getpid());                                                                                       </span><br><span class="line">         sleep(<span class="number">3</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="gif1.gif" alt="gif1"></p><p>打开两个终端一个终端运行程序，另一个终端执行命令<br><code>while :; do clear; ps -aux |grep zombie; sleep 0.5; done</code></p><p>运行后可以看到3秒内子进程和父进程均进入S睡眠状态，三秒后子进程执行exit，这时子进程状态变为Z，再过7秒后，两个进程都退出</p><h2 id="僵尸进程的危害"><a class="markdownIt-Anchor" href="#僵尸进程的危害"></a> 僵尸进程的危害</h2><p>进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（pid、退出状态、运行时间等）直到父进程wait时才释放。如果父进程不调用wait的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的（ulimit -a查看）可能导致系统不能创建新的进程</p><h1 id="孤儿进程"><a class="markdownIt-Anchor" href="#孤儿进程"></a> 孤儿进程</h1><p>正如上文所说，子进程和父进程是一个异步过程，如果父进程退出，子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（1号）所收养，并由init进程对它们完成状态收集工作。这样的子进程叫孤儿进程。每当有一个孤儿进程，内核就把其父进程设置为init，init进程会循环等待它的已经退出的子进程</p><h2 id="观察一个孤儿进程"><a class="markdownIt-Anchor" href="#观察一个孤儿进程"></a> 观察一个孤儿进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* orphan.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent id:%d\n"</span>, getpid());</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child id:%d\n"</span>, getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="gif2.gif" alt="gif2"></p><p>打开两个终端一个终端运行程序，另一个终端执行命令<br><code>while :; do clear; ps aux |grep orphan; sleep 0.5; done</code></p><p>运行后可以看到3秒内子进程和父进程均正常，三秒后父进程执行exit，这时子进程的ppid变为1，再过7秒后，这个进程退出</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>事实上，任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个僵尸进程的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理，所以这么说来孤儿进程并不会有什么危害</p><h1 id="如何解决避免僵尸进程"><a class="markdownIt-Anchor" href="#如何解决避免僵尸进程"></a> 如何解决/避免僵尸进程</h1><p><strong>解决方法</strong>：<br>杀死父进程，僵尸进程会变成僵尸孤儿进程，1号进程会扫描其子进程，把Z状态进程回收。<br>直接发信号（-9等信号）去处理僵尸进程是无效的，因为僵尸进程已经退出了，只保留了task_struct结构体及少数资源</p><p><strong>避免方法</strong>：</p><ol><li>先执行一次fork在创建的子进程中再次fork，然后将第一次fork的进程退出，第二个子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程管理，防止僵尸进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程再创建子进程</span></span><br><span class="line">        id = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fork error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 让第一个子进程退出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first process exit!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程的子进程睡眠30s保证第一个子进程退出，这样子进程的子进程的父亲就是init进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"second process is sleeping~~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程处理第一个子进程退出</span></span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) != id) &#123;</span><br><span class="line">        perror(<span class="string">"waite error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"father process exit!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样进程产生子进程的父进程就变成init进程了，就不需要父进程阻塞等待</p><ol start="2"><li>通过信号机制异步回收，最理想处理方式</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> id;</span><br><span class="line">    <span class="comment">// 处理僵尸进程</span></span><br><span class="line">    <span class="keyword">while</span> ((id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait child:%d\n"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建捕捉子进程退出信号</span></span><br><span class="line">    signal(SIGCHLD,handler);</span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child:%d exit\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待子进程先退出</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于UNIX 的历史原因还有另外一种办法：父进程调用sigaction将SIGCHLD的处理动作置为SIG_IGN这样fork出来的子进程在终止时会自动清理掉，不会产生僵尸进程，也不会通知父进程。系统默认的忽略动作和用户用sigaction函数自定义的忽略通常是没有区别的，但这是一个特例，Linux可用，但不保证在其它UNIX系统上都可用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;僵尸进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#僵尸进程&quot;&gt;&lt;/a&gt; 僵尸进程&lt;/h1&gt;&lt;p&gt;linux中，正常情况下，子进程和父进程是一个异步过程，父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="僵尸进程" scheme="https://Ranjiahao.github.io/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="https://Ranjiahao.github.io/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程信号</title>
    <link href="https://ranjiahao.github.io/2020/06/03/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
    <id>https://ranjiahao.github.io/2020/06/03/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>信号是一种软件中断，信号在linux中提供了异步处理的方法，将内核和进程联系起来，是操作系统内部交互的机制<br>kill -l指令查看所有信号</p><h1 id="信号产生"><a class="markdownIt-Anchor" href="#信号产生"></a> 信号产生</h1><ul><li><p>键盘输入产生一个硬件中断（电信号）到cpu，被OS获取，解释成信号（软件），发送给目标前台进程<br>ctrl-c: 2号信号(SIGINT)，终止当前运行进程，只能发给前台进程，一个命令后面加个&amp;可以放到后台运行Shell不必等待进程结束<br>ctrl-: 3号信号(SIGQUIT)，终止进程并且产生coredump文件<br>ctrl-z: 20号信号(SIGTSTP)，挂起一个进程<br>ctrl-d: 不是发送信号，而是表示一个特殊的二进制值，表示 EOF</p></li><li><p>通过硬件异常产生信号<br>CPU: 0作为除数时，CPU运算单元会产生异常，产生8号信号（SIGFPE）<br>MMU: 访问内存越界或者非法的时候，MMU发现当前内存不合法，就会通知OS向该进程发送11号信号（SIGSEGV）</p></li><li><p>调用系统函数向进程发送信号<br>系统调用，给某个进程发送某个信号<code>int kill(pid_t pid, int signo);</code><br>库函数<code>int raise(int signo);</code>底层封装kill了<br>库函数<code>void abort(void);</code>使当前进程接收到信号SIGABRT而异常终止</p></li><li><p>软件条件产生信号<br>管道所有读端关闭，写操作会触发13号信号（SIGPIPE）<br><code>unsigned int alarm(unsigned int seconds);</code>seconds秒后，操作系统会发送14号闹钟信号（SIGALRM）</p></li></ul><p>信号递达：实际执行信号的处理动作<br>信号未决：从信号产生到信号递达之间的状态<br>信号阻塞：如果一个信号被阻塞，那它在产生时处于未决状态，不会被递达，只有解除该信号后，才被递达(信号忽略是在递达之后可选的一种处理动作)</p><h1 id="信号处理方式"><a class="markdownIt-Anchor" href="#信号处理方式"></a> 信号处理方式</h1><p>信号有三种处理方式</p><ol><li>忽略某个信号，不做任何处理</li><li>对该信号的处理保留系统的默认值，典型的缺省动作是终止进程</li><li>用户定义处理函数，由信号处理<code>sighandler_t signal(int signum, sighandler_t handler);``typedef void (*sighandler_t)(int);</code></li></ol><p>内核处理过程：</p><p><img src="img1.png" alt="img1"></p><p>sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程</p><h1 id="信号排队"><a class="markdownIt-Anchor" href="#信号排队"></a> 信号排队</h1><p>对于每一个进程，内核会用一个pending位图来标记信号的处理状态。如果一个信号还未被目标进程处理，那么对应位置就被标记为1。内核向进程递送新的信号时，会查看进程对应的pending中，该信号对应的位置是否为1<br>若为1则有挂起的信号，Unix传统的做法，内核将直接丢弃这一信号，不可靠信号(1~31)。而后Linux对此做出了一些改进，内核会为每个进程维护一组队列(queue)，有挂起信号时，就将新来的信号排队(enqueue)，可靠信号(34~64)<br>位图用sigset_t表示，而队列就是一个双向链表，链表头结点包含在进程对应的task_struct中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="阻塞信号"><a class="markdownIt-Anchor" href="#阻塞信号"></a> 阻塞信号</h1><p><img src="img2.png" alt="img2"></p><p>每个信号都有两个标志位分别表示阻塞(block)和未决(pending)还有一个函数指针表示处理动作。信号产生时,内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。图中第一个信号未阻塞也未产生，当它递达时执行默认处理动作。第二个信号信号产生过，但被阻塞，暂时不能递达。在没有解除阻塞之前不能忽略这个信号，第三个信号未产生，一旦产生信号将被阻塞，它的处理动作是用户自定义函数sighandler</p><h1 id="信号集操作函数"><a class="markdownIt-Anchor" href="#信号集操作函数"></a> 信号集操作函数</h1><blockquote><p>int sigemptyset(sigset_t *set); // 初始化set所指向的信号集全0<br>int sigfillset(sigset_t *set); // 初始化set所指向的信号集全1<br>int sigaddset (sigset_t *set, int signo); // 将signo对应位图设置为1<br>int sigdelset(sigset_t *set, int signo); // 将signo对应位图设置为0<br>int sigismember（const sigset_t *set, int signo); // 判断信号集中是否包含信号signo<br>返回值：成功返回0，失败返回-1。sigismember成功返回0或者1</p><p>int sigprocmask(int how, const sigset_t *set, sigset_t *oset);<br>若oset非空，则当前信号屏蔽字通过oset传出，若set是非空,则更改信号屏蔽字<br>how:<br>SIG_BLOCK: 添加到当前信号屏蔽字中的信号，相当于mask = mask|set<br>SIG_UNBLOCK: 从当前信号屏蔽字中解除的信号，相当于mask = mask&amp;~set<br>SIG_SETMASK: 设置当前信号屏蔽字为set，相当于mask = set<br>返回值：成功返回0，失败返回-1<br>int sigpending（sigset_t* set); 读取当前进程的未决信号集，成功返回0，失败返回-1</p></blockquote><ul><li>SIGKILL(9号)和SIGSTOP(19号)不可被阻塞、不可被忽略、不可被自定义</li></ul><p>演示代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印未决信号集函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpending</span><span class="params">(<span class="keyword">sigset_t</span> pending)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 1 ~ 31信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;pending, i)) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置2号信号为屏蔽信号</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, <span class="number">2</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">sigset_t</span> pending;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 每秒打印一次未决信号</span></span><br><span class="line">        sigpending(&amp;pending);</span><br><span class="line">        printpending(pending);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">            raise(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6s后解除对2号信号的屏蔽</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0000000000000000000000000000000<br>0000000000000000000000000000000<br>0000000000000000000000000000000<br>0100000000000000000000000000000<br>0100000000000000000000000000000<br>0100000000000000000000000000000</p><p>前三秒没有任何信号产生，3秒后raise向进程发送了2号信号，但是2号信号为阻塞状态，所以信号产生后不会被递达的，6秒后解除了对2号信号的屏蔽，此时2号信号被递达去执行默认处理动作退出</p><h1 id="sigaction"><a class="markdownIt-Anchor" href="#sigaction"></a> sigaction</h1><blockquote><p>int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);<br>读取和修改与指定信号相关联的处理动作<br>若act非空，则根据act修改该信号的处理动作。若oact非空，则通过oact传出该信号原来的处理动作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>(*sa_handler)(<span class="keyword">int</span>); <span class="comment">// 信号的处理动作</span></span><br><span class="line"><span class="keyword">void</span>(*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>*);</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask; <span class="comment">//当正在执行信号处理动作时，希望屏蔽的信号。当处理结束后，自动解除屏蔽</span></span><br><span class="line"><span class="keyword">int</span> sa_flags; <span class="comment">// SA_SIGINFO使用sa_sigaction作为信号处理函数</span></span><br><span class="line"><span class="keyword">void</span>(*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="使用coredump"><a class="markdownIt-Anchor" href="#使用coredump"></a> 使用coredump</h1><p>进程异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，事后可以用调试器检查core文件以查清错误原因，PCB中存在此进程允许产生core文件的大小(Resource Limit)，core文件中可能包含用户密码等敏感信息，默认是不产生core文件的，可以用ulimit命令改变Shell进程的Resource Limit，允许core文件最大为1024K: $ ulimit -c 1024子进程的PCB由Shell进程复制而来，所以也具有和Shell进程相同的Resource Limit值gdb调试启动后，可以使用core-file [corefilename]查看信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;信号是一种软件中断，信号在linux中提供了异步处理的方法，将内核和进程联系起来，是操作系统内部交互的机制&lt;br&gt;kill -l指令查看所有信号&lt;/p&gt;&lt;h1 id=&quot;信号产生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#信号产生&quot;&gt;&lt;/a&gt; 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="信号" scheme="https://Ranjiahao.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>内核态与用户态</title>
    <link href="https://ranjiahao.github.io/2020/06/01/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/"/>
    <id>https://ranjiahao.github.io/2020/06/01/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在32位操作系统下，虚拟地址空间为4G，也就是说一个进程的最大的地址空间为4G。操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。对Linux操作系统而言，最高的1G字节由内核使用。低3G字节由各个进程使用</p><p>换句话说，最高1G内核空间是被所有进程共享，剩余3G才归进程自己使用</p><h1 id="区分内核空间与用户空间的意义"><a class="markdownIt-Anchor" href="#区分内核空间与用户空间的意义"></a> 区分内核空间与用户空间的意义</h1><p>CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</p><h1 id="内核态与用户态"><a class="markdownIt-Anchor" href="#内核态与用户态"></a> 内核态与用户态</h1><p>Linux系统只使用了Ring0和Ring3两个运行级别。当进程运行在Ring3级别时被称为运行在用户态，而运行在Ring0级别时被称为运行在内核态。运行在Ring3级别时被称为运行在用户态，运行在Ring0级别时被称为运行在内核态<br>在内核态下，进程运行在内核地址空间中，此时CPU可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问<br>在用户态下，进程运行在用户地址空间中，被执行的代码要受到CPU的检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段中I/O许可位图中规定的可访问端口进行直接访问。</p><p>我们可以将每个处理器在任何指定时间点上的活动概括为下列三者之一：</p><ul><li><p>运行于用户空间，执行用户进程</p></li><li><p>运行于内核空间，处于进程上下文，代表某个特定的进程执行</p></li><li><p>运行于内核空间，处于中断上下文（保证中断服务程序能够在第一时间响应和处理中断请求，然后快速地退出），与任何进程无关，处理某个特定的中断</p></li></ul><p>用户态到内核态的转换概况来说有三种方式分别为系统调用、软中断和硬件中断</p><h1 id="linux系统结构图"><a class="markdownIt-Anchor" href="#linux系统结构图"></a> Linux系统结构图</h1><p>从内核空间和用户空间的角度看整个Linux系统的结构，从下往上依次为：硬件 -&gt; 内核空间 -&gt; 用户空间</p><p><img src="img1.png" alt="img1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在32位操作系统下，虚拟地址空间为4G，也就是说一个进程的最大的地址空间为4G。操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="内核态与用户态" scheme="https://Ranjiahao.github.io/tags/%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>动态库静态库与软硬链接</title>
    <link href="https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>https://ranjiahao.github.io/2020/05/20/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2020-05-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态库"><a class="markdownIt-Anchor" href="#静态库"></a> 静态库</h1><p>静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可执行文件之后不再依赖静态库。所以速度会较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 生成静态库</span><br><span class="line">$ gcc -c test1.c test2.c</span><br><span class="line">$ ar -rc libmylib.a test1.o test2.o # ar是gnu归档工具，rc表示(replace and create)</span><br><span class="line">$ ar -tv libmylib.a # 查看静态库中的目录列表 t:列出静态库中的文件 v:verbose 详细信息</span><br></pre></td></tr></table></figure><h1 id="动态库"><a class="markdownIt-Anchor" href="#动态库"></a> 动态库</h1><p>动态库（.so）：程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。动态库链接的可执行文件仅仅包含它用到的函数入口地址的一个表，而不是外部函数所在目标文件的整个机器码，在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制到内存中，动态库可以在多个程序间共享，所以动态链接使得可执行文件更小，节省了磁盘空间。操作系统采用虚拟内存机制允许物理内存中的一份动态库被要用到该库的所有进程共用，节省了内存和磁盘空间，但是，每次使用时，都要去调用动态库，所以速度会相对较慢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 生成动态库</span><br><span class="line">$ gcc -c -fPIC test1.c test2.c # -fPIX产生位置无关码</span><br><span class="line">$ gcc -shared test1.o test2.o -o libmylib.so # -sharde表示生成共享库格式</span><br></pre></td></tr></table></figure><h1 id="使用库"><a class="markdownIt-Anchor" href="#使用库"></a> 使用库</h1><p><code>$ gcc main.c -I ./include -L. -lmylib</code><br>-L: 指定库路径（默认是从usr/lib 或 usr/local/lib中寻找库文件）<br>-l: 指定库名（去掉lib以及版本号）<br>-I: 指定头文件搜索路径<br>可以将路径添加到环境变量LIBRARY_PATH中代替-L<br>运行动态库：由于动态链接在运行时需要动态库，所以要么拷贝.so文件到系统共享库路径下；要么添加路径到环境变量LD_LIBRARY_PATH中；或者在目录/etc/ld.so.conf.d/中创建mylib.conf，并且在其中填写存放动态库的路径，保存退出后，使用ldconfig命令更新/ld.so.conf.d目录<br>gcc默认动态链接，如果想使用第三方静态库，不能使用-static选项，因为-static选项是生成静态链接可执行程序，所有库都使用静态库，我们只希望这个第三方库使用静态库而不是所有，因此我们将第三方库拷贝到指定目录下然后使用-L选项指定路径，链接的就是静态库</p><h1 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h1><p>创建方式 ln srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln tmp tmp.hard</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode相同，而链接数从1变成了2<br>删除文件时干了两件事情：1.在目录中将对应的记录删除 2.将硬连接数-1，如果为0，则将对应<br>的磁盘释放</p><h1 id="软链接"><a class="markdownIt-Anchor" href="#软链接"></a> 软链接</h1><p>创建方式 ln -s srcfile destfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch tmp</span><br><span class="line">$ ln -s tmp tmp.soft</span><br><span class="line">$ ll -i</span><br></pre></td></tr></table></figure><p>我们发现两个文件的inode不相同，而tmp.soft的文件大小为被链接文件所给路径的长度</p><h1 id="链接的访问"><a class="markdownIt-Anchor" href="#链接的访问"></a> 链接的访问</h1><p><img src="img1.png" alt="img1"></p><p>硬链接hard link本质上和file没区别，与源文件file共用一个inode节点，通过inode来访问数据，而软链接soft link本质上是一个独立的文件，有自己的inode节点和自己的data block其中保存着file的路径，通过路径访问源文件</p><p>所以删除源文件，软链接文件失效；硬链接只是链接数-1，删除了目录文件data block中保存的目录项。由于软链接通过路径访问，硬链接通过inode访问，所以软链接可以跨分区，而硬链接不可跨分区，目录本身也是跨分区的所以不能设置硬链接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#静态库&quot;&gt;&lt;/a&gt; 静态库&lt;/h1&gt;&lt;p&gt;静态库（.a）：程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库，所以会导致可执行文件的代码量增多。但生成可
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="动态库静态库" scheme="https://Ranjiahao.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="软硬链接" scheme="https://Ranjiahao.github.io/tags/%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="https://ranjiahao.github.io/2020/05/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://ranjiahao.github.io/2020/05/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机械硬盘的物理存储机制"><a class="markdownIt-Anchor" href="#机械硬盘的物理存储机制"></a> 机械硬盘的物理存储机制</h1><p>一个硬盘有多张盘片叠成，不同盘片有编号<br>每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号<br>每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位<br>N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位<br>所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位</p><h1 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h1><p>硬盘分区本质是硬盘这个物理概念转换成区这个逻辑概念，为下一步格式化做准备。<br>第一扇区有硬盘主引导记录及分区表， MBR扇区由引导代码(446bytes)、MBR分区表(64bytes)、MBR结束标志(2bytes)3部分构成，一共占用512bytes。MBR放有最基本的引导加载程序，是系统开机启动的关键环节，而分区表则跟分区有关，它记录了硬盘分区的相关信息，分区表仅有64bytes，最多只能记彔四块分区（分区其实就是对分区表进行设置），也可以设置成主分区+逻辑分区，这时也是最多4个分区号码，但是变成了4 = 3 + 1其中4是主分区和扩展分区加起来最多4个，3是主分区，1是扩展分区，占用了一个主分区号，从5开始都是逻辑分区。扩展分区的磁盘总量等于一个逻辑分区的磁盘总量。本质是利用额外的扇区来记录更多的分区信息。扩展分区不同于主分区，它本身并没有内容，它是为进一步逻辑分区提供空间的，只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区<br>最好单独分一个swap区，当有数据被存放在物理内存里面，但是这些数据又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap置换空间当中，而将速度较快的物理内存空间释放出来给真正需要的程序使用</p><h1 id="ext2文件系统"><a class="markdownIt-Anchor" href="#ext2文件系统"></a> ext2文件系统</h1><p><img src="img1.png" alt="img1"></p><p>Boot Block: 这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的MBR， 也就是这样才能实现多重引导的功能<br>Block group: ext2文件系统会根据分区的大小划分为数个Block Group<br>Super Block: 存放文件系统本身的结构信息，一般大小为1024bytes。记录的信息主要有: bolck 和 inode的总量，未使用的block和inode的数量，是否被挂载，一个block(1k|2k|4k mke2fs -b可以设置)，和inode(128bytes)的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了<br>Group Descriptor Table: 块组描述符，描述块组属性信息，这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段分别介于哪一个block号码之间<br>Block Bitmp: 记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用<br>inode Bitmap: 每个bit表示一个inode是否空闲可用<br>inode Table: 存放文件属性 如文件大小/权限/所有者，数据地址，最近修改时间等(ls -i可查看)<br>Date blocks：存放文件内容</p><p>创建一个新文件主要有以下几个操作：</p><ol><li>存储属性，内核通过inode Bitmap找到一个空闲的inode节点</li><li>存储数据，内核通过Block Bitmap找到了n个空闲块，将内核缓冲区的数据复制到块中</li><li>记录分配情况，内核在inode Table记录块列表等信息</li><li>添加文件名到目录，内核将入口（inode，filename等信息）添加到目录文件的block中，文件名和inode之间的对应关系将文件名和文件的内容及属性连接起来</li></ol><ul><li>所以文件名的记录是在目录的block当中，「新增/删除/更名文件名」与目录的w权限有关</li><li>stat file_name命令可查看这些信息</li></ul><h1 id="inode直接间接区"><a class="markdownIt-Anchor" href="#inode直接间接区"></a> inode直接/间接区</h1><p>inode要记录的资料非常多，却只有128bytes，因为inode记录block 号码的区域定义为12个直接，一个间接，一个双间接与一个三间接记录区<br>直接记录：里面有12个直接指向block号码的对照，这12条记录就能够直接取得block号码<br>间接记录：再拿一个block来当作记录block号码的记录区，如果文件太大时，就会使用间接的block来记录号码。同理，如果文件持续长大，那么就会利用所谓的双间接，第一个block仅再指出下一个记录号码的block在哪里，实际记录的在第二个block当中。依此类推，三间接就是利用第三层block来记录号码<br>12个直接指向： 12 * 1K = 12K<br>间接： 256 * 1K = 256K，block号码的记录占4bytes，因此1K的大小能够记录256笔记录<br>双间接： 256 * 256k = 64M，第一层block会指定256个间接<br>三间接：256 * 64M = 16G，第一层block会指定256个双间接</p><h1 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> vfs</h1><p>在一个区被格式化为一个文件系统之后，它就可以被Linux操作系统使用了，只是这个时候Linux操作系统还找不到它，所以我们还需要把这个文件系统注册进Linux操作系统的文件体系里，这个操作就叫挂载，把对不同文件系统的访问交给了VFS（虚拟文件系统），VFS能访问和管理各种不同的文件系，每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用</p><p><img src="img2.png" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机械硬盘的物理存储机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#机械硬盘的物理存储机制&quot;&gt;&lt;/a&gt; 机械硬盘的物理存储机制&lt;/h1&gt;&lt;p&gt;一个硬盘有多张盘片叠成，不同盘片有编号&lt;br&gt;每张盘片上的存储颗粒成环形一圈圈地排布，每一圈
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="文件系统" scheme="https://Ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>系统文件IO</title>
    <link href="https://ranjiahao.github.io/2020/05/16/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/"/>
    <id>https://ranjiahao.github.io/2020/05/16/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h1><p>文件描述符就是从0开始的整数，打开文件时，操作系统在内存中要创建相应的数据结构file来描述目标文件，而进程执行系统文件IO，必须让进程和文件关联起来。所以每个进程都有一个指针files, 指向一张表files_struct，表中包涵一个指针数组，每个元素都是一个指向打开文件的指针，本质上，文件描述符就是数组的下标</p><p><img src="img1.png" alt="img1"></p><h1 id="openclose"><a class="markdownIt-Anchor" href="#openclose"></a> open/close</h1><blockquote><p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>int open(const char *pathname, int flags);<br>int open(const char *pathname, int flags, mode_t mode);</p></blockquote><p>pathname: 要打开或创建的目标文件<br>flags: 一个或者多个常量进行或运算，构成flags<br>O_RDONLY: 只读打开，O_WRONLY: 只写打开，O_RDWR: 读，写打开。这三个常量，必须指定一个且只能指定一个<br>O_CREAT: 若文件不存在，则创建。需要使用mode选项，来指明新文件的访问权限<br>O_APPEND: 追加写打开<br>O_TRUNC: 打开文件截断为0<br>mode: 文件访问权限，如，0664，这里真实权限为mode &amp; ~umask，umask(0)设置权限掩码<br>返回值: 成功返回文件描述符，失败返回-1并设置errno</p><h1 id="close"><a class="markdownIt-Anchor" href="#close"></a> close</h1><blockquote><p>#include &lt;unistd.h&gt;<br>int close(int fd);</p></blockquote><p>fd: 文件描述符<br>返回值: 成功返回0，失败返回-1并设置errno</p><h1 id="writeread"><a class="markdownIt-Anchor" href="#writeread"></a> write/read</h1><blockquote><p>#include &lt;unistd.h&gt;<br>ssize_t write(int fd, const void *buf, size_t count);<br>ssize_t read(int fd, void *buf, size_t count);</p></blockquote><p>fd: 文件描述符<br>buf: 写入到文件描述符的指定的缓冲区/从文件描述符fd将字节数读入的缓冲区<br>count: 写入到文件描述符的字节数/从文件描述符读入的字节数<br>返回值: 成功返回写入/读入字节数，失败返回-1并设置errno</p><h1 id="lseek"><a class="markdownIt-Anchor" href="#lseek"></a> lseek</h1><blockquote><p>#include &lt;sys/types.h&gt;<br>#include &lt;unistd.h&gt;<br>off_t lseek(int fd, off_t offset, int whence);</p></blockquote><p>fd: 文件描述符<br>offset: 偏移量<br>whence:<br>SEEK_SET: 文件偏移量将被设置为offset<br>SEEK_CUR: 文件偏移量将被设置为当前文件偏移量加上offset，offset可正可负<br>SEEK_END: 文件偏移量将被设置为文件长度加上offset，offset可正可负<br>返回值: 成功返回新的偏移量，失败返回-1并设置errno</p><h1 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h1><h2 id="文件描述符分配原则"><a class="markdownIt-Anchor" href="#文件描述符分配原则"></a> 文件描述符分配原则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"myfile"</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// '\n'只能针对标准输出文件刷新缓冲区</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后我们发现本来应该输出到显示器上的内容却输出到了myfile当中，其中fd=1，所以文件描述符的分配原则为最小未使用原则</p><h2 id="dup2系统调用"><a class="markdownIt-Anchor" href="#dup2系统调用"></a> dup2系统调用</h2><blockquote><p>#include &lt;unistd.h&gt;<br>int dup2(int oldfd, int newfd);<br>让newfd下标对应的指针也指向oldfd下标对应的指针所指向的文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"myfile"</span>, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"hehe\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, arr, <span class="built_in">strlen</span>(arr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd: %d\n"</span>, fd);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// '\n'只能针对标准输出文件刷新缓冲区</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结束后文件myfile中<br>hehe<br>fd: 3</p><h1 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h1><p>一般C库函数写入文件时是全缓冲的，而写入显示器是行缓冲</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str1 = <span class="string">"printf\n"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"fwrite\n"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str3 = <span class="string">"write\n"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, str1);</span><br><span class="line">    fwrite(str2, <span class="built_in">strlen</span>(str2), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, str3, <span class="built_in">strlen</span>(str3));</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行./a.out发现输出<br>printf<br>fwrite<br>write<br>但是运行./a.out &gt; file，则file文件中printf和fwrite被打印了两次，write还是一次</p><p>这是因为’\n’刷新缓冲区的作用只对标准输出有用，而对于普通文件来说数据的缓冲方式由行缓冲变成了全缓冲，而我们放在缓冲区中的数据，就不会被立即刷新，fork的时候，子进程会连缓冲区中数据一起拷贝，write没有变化，说明它没有用户级缓冲<br>C库当中的FILE结构体内(/usr/include/libio.h)包含了用户态的缓冲区定义，以及文件描述符，本质上都是通过文件描述符来访问的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件描述符&quot;&gt;&lt;/a&gt; 文件描述符&lt;/h1&gt;&lt;p&gt;文件描述符就是从0开始的整数，打开文件时，操作系统在内存中要创建相应的数据结构file来描述目标文件，而进程执行系统文件IO，必
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="文件IO" scheme="https://Ranjiahao.github.io/tags/%E6%96%87%E4%BB%B6IO/"/>
    
  </entry>
  
  <entry>
    <title>SystemV消息队列</title>
    <link href="https://ranjiahao.github.io/2020/05/13/SystemV%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://ranjiahao.github.io/2020/05/13/SystemV%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-05-12T16:00:00.000Z</published>
    <updated>2020-05-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列是一种以链表式结构组织的数据，存放在内核中，是三个IPC对象类型中最具数据操作性的数据传送方式，可以根据数据类型来检索消息，有同步互斥机制，面向数据报，全双工通信<br>我们可以通过命令查看/删除系统中已有的消息队列<br><code>ipcs -q</code>/<code>ipcrm -q [msqid]</code><br>相关操作（系统调用）：</p><h1 id="消息队列创建打开"><a class="markdownIt-Anchor" href="#消息队列创建打开"></a> 消息队列创建/打开</h1><blockquote><p><code>int msgget(key_t key, int msgflg);</code><br>第一个参数key：给这个消息队列分配的密钥，同创建共享内存一样，系统返回对应共享内存的标识符，失败返回-1，并设置errno<br>第二个参数msgflg: IPC_CREAT如果不存在就创建，IPC_EXCL如果已经存在则返回失败，位或权限位：可以设置消息队列的访问权限<br>每创建一个消息队列，就会在用户空间组织这样的一个数据结构，用来设置或返回消息队列的信息</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span> <span class="comment">// 消息队列第一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span> <span class="comment">// 消息队列最后一个节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_cbytes; <span class="comment">// 当前队列字节数据      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qnum; <span class="comment">// 队列中的消息数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qbytes; <span class="comment">// 队列中最大字节数</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 时间属性</span></span><br><span class="line">    <span class="comment">// 最近接收和发送消息的进程pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="添加消息到消息队列中"><a class="markdownIt-Anchor" href="#添加消息到消息队列中"></a> 添加消息到消息队列中</h1><blockquote><p><code>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</code><br>msgid:msgget函数返回的消息队列标识符<br>msgp:指向准备发送的消息，是一个用户自定义的结构体<br>msgsz:消息⻓度，不含消息类型，最大长度MSGMAX<br>msgflg:IPC_NOWAIT队列满非阻塞，返回EAGAIN错误，0阻塞</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msgp的格式：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype; <span class="comment">// 必须大于0</span></span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>]; <span class="comment">// 消息的长度，实际是一柔性数组，在实际使用时有用户自主指定大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将数据添加到队列尾，并且更新msg_last<br><img src="img1.png" alt="img1"></p><h1 id="从消息队列中接收消息"><a class="markdownIt-Anchor" href="#从消息队列中接收消息"></a> 从消息队列中接收消息</h1><blockquote><p><code>ssize_t msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg);</code><br>msgid: msgget函数返回的消息队列标识符<br>msgp: 指针指向准备接收的消息<br>msgsz: 是msgp指向的消息⻓度，不含消息类型<br>msgtype: 它可以实现接收优先级的简单形式<br>若 = 0 - 读取消息队列中最早的消息，以先进先出的方式读取消息<br>若 &gt; 0 - 读取消息队列类型为msgtyp最早的消息<br>若 &lt; 0 - 读取消息队列中，消息类型小于或等于msgtyp绝对值的消息中最小消息类型的最早消息<br>msgflg: IPC_NOWAIT设置非阻塞，MSG_NOERROR表示消息大小超过msgsz时被截断，MSG_EXCEPT表示接收类型不等于msgtyp的第一条消息<br>成功返回实际放到msgp⾥去的字符个数，失败返回-1，并设置errno</p></blockquote><h1 id="控制消息队列"><a class="markdownIt-Anchor" href="#控制消息队列"></a> 控制消息队列</h1><blockquote><p><code>int msgctl(int msqid,int cmd,struct msqid_ds* buf);</code><br>msgid: msgget函数返回的消息队列标识符<br>cmd:<br>IPC_RMID删除消息队列， IPC_STAT IPC_SET<br>cmd: IPC_RMID删除消息队列、IPC_STAT获取消息队列的当前关联值、IPC_SET根据buf设置消息队列关联值<br>buf: 保存着消息队列的模式状态和访问权限的数据结构，输入输出型参数<br>成功返回0；失败返回-1，并设置errno</p></blockquote><h1 id="从内核看本质"><a class="markdownIt-Anchor" href="#从内核看本质"></a> 从内核看本质</h1><p>内核维护着一个消息队列的全局数据结构ipc_ids，其中有一个指针指向一个数组。每当创建一个IPC对象内核就会创建一个ipc_perm，并且将它的地址放到结构体ipc_id中，这个数组就是这个结构体ipc_id组成的数组，数组最大的个数就是MSGMNI，所以说消息队列<mark>随内核持续</mark>，直到内核重新自举或者显示删除该对象为止。类似还有信号量、共享内存<br><img src="img2.png" alt="img2"></p><h1 id="代码实现server和client的交互"><a class="markdownIt-Anchor" href="#代码实现server和client的交互"></a> 代码实现server和client的交互</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/MessageQueue" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/MessageQueue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息队列是一种以链表式结构组织的数据，存放在内核中，是三个IPC对象类型中最具数据操作性的数据传送方式，可以根据数据类型来检索消息，有同步互斥机制，面向数据报，全双工通信&lt;br&gt;我们可以通过命令查看/删除系统中已有的消息队列&lt;br&gt;&lt;code&gt;ipcs -q&lt;/code&gt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>SystemV信号量</title>
    <link href="https://ranjiahao.github.io/2020/05/12/SystemV%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://ranjiahao.github.io/2020/05/12/SystemV%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-05-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了防止出现因多个进程同时访问一个共享资源引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。信号量就可以提供这样的一种访问机制，确保多个线程在对共享内存这样的共享资源同时读写时，使之实现同步与互斥，也就是说信号量用来<mark>调协进程对公共资源的访问的</mark><br>信号量本质上是一个计数器，也是临界资源，进程对其访问都是原子操作，信号量记录着临界资源的个数<br>信号量可以使用ipcs -s查看<br>使用ipcrm -s [semid]删除</p><h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1><p>信号量只能进行等待和发送信号两种操作，即P(sv)和V(sv)<br>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程并将其PCB放入队列中<br>V(sv)：如果等待队列中有其他进程因等待sv而被挂起，就让一个恢复运行，如果没有进程因等待sv而挂起，就给它加1<br>所以一个信号量不仅包含临界资源的数目，还必须维护一个队列<br>实际应用中信号量是不能单独定义的，而是定义一个信号量集，其中包含一组信号量，同一信号集中的信号量使用同一个引用ID，每个信号量集有一个与之对应的结构体，其中记录着各种信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">// 指向sem结构数组，数组中每一个元素对应一个信号量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">// 信号量的个数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 时间相关描述</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中struct sem才是信号量的描述结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">// 信号量的值</span></span><br><span class="line">    <span class="keyword">pid_t</span> semid; <span class="comment">// 上一次进行操作的进程号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt; <span class="comment">// 等待可利用资源出现的进程数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">// 等待全部资源可被独占的进程数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统中的限制：<br>SEMVMX最大的信号值<br>SEMMNI系统允许的最大信号量集个数<br>SEMMNS系统允许的最大信号量个数<br>SEMMSL每个信号集中最大的信号量个数</p><h1 id="创建打开信号集"><a class="markdownIt-Anchor" href="#创建打开信号集"></a> 创建/打开信号集</h1><blockquote><p><code>int semget(key_t key, int nsems, int semflg);</code><br>参数key和semflg用法和共享内存相同<br>nsems: 信号量集中创建的信号量数量，如果创建信号集，sem_nsems将被设置为nsems；如果打开一个已存在的信号集，此参数就被忽略<br>如果调用成功，则返回信号量集合标识符，否则返回-1，并设置error</p></blockquote><h1 id="操作信号量集原子操作"><a class="markdownIt-Anchor" href="#操作信号量集原子操作"></a> 操作信号量集（原子操作）</h1><blockquote><p><code>int semop(int semid, struct sembuf *sops, unsigned nsops);</code><br>semid: semget返回的信号量集标识符<br>sops: 为sembuf结构数组指针，每一个元素表示一个操作，这个函数是一个原子操作，一旦执行就将执行数组中所有的操作<br>nsops: 为数组中元素的个数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num; <span class="comment">// 表示信号量集中某一信号量序号(0~ipc_perm.sem_nsems)</span></span><br><span class="line">    <span class="keyword">short</span> sem_op; <span class="comment">// 所执行的操作，如-1表示P操作消耗一个临界资源， 1表示V操作释放了一个临界资源</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// 0表示没资源时阻塞等待，IPC_NOWAIT非阻塞，SEM_UNDO（将已申请的信号量还原为初识状态，即刚开始获得这个信号量时的状态）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制信号量集"><a class="markdownIt-Anchor" href="#控制信号量集"></a> 控制信号量集</h1><blockquote><p><code>int semctl(int semid, int semnum, int cmd, ...);</code><br>semid: semget返回的信号集标识符<br>semnum: 信号集中信号量的序号<br>cmd: 将要采取的动作<br>根据cmd参数具体内容，IPC_RMID删除信号量，可能有第四个参数，是一个联合体，当cmd为GET时返回对应值<br>成功返回0，失败返回-1，设置errno</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 用于SETVAL/GETVAL命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">// 用于IPC_STAT/IPC_SET命令，输入/输出型参数表示存放信号量集数据结构缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>* _<span class="title">buf</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作演示"><a class="markdownIt-Anchor" href="#操作演示"></a> 操作演示</h1><p>子进程循环输出A和A到显示器上这2个A中间不可被打断<br>父进程循环输出B和B到显示器上这2个B中间不可被打断</p><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/Semaphore" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了防止出现因多个进程同时访问一个共享资源引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。信号量就可以提供这样的一种访问机制，确保多个线程在对共享内存这样的共享资源同时读写时，使之实现同步与互斥，也就是说信
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>SystemV共享内存</title>
    <link href="https://ranjiahao.github.io/2020/05/07/SystemV%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>https://ranjiahao.github.io/2020/05/07/SystemV%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</id>
    <published>2020-05-06T16:00:00.000Z</published>
    <updated>2020-05-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>共享内存就是将同一块物理内存映射到不同进程虚拟内存的共享区域，实现两个进程间通信。一旦这样的内存映射到进程地址空间的共享区，这些进程间数据传递不再涉及到内核，不再通过执行进入内核的系统调用来传递彼此的数据，所以说共享内存是最快的IPC形式<br>我们可以通过命令查看/删除系统中已有的共享内存<br><code>ipcs -m</code>/<code>ipcrm -m [shmid]</code><br>相关操作（系统调用）：</p><h1 id="创建共享内存"><a class="markdownIt-Anchor" href="#创建共享内存"></a> 创建共享内存</h1><p><code>int shmget(key_t key, size_t size, int shmflg);</code><br>key:进程对共享内存的访问都是间接的，需要提供一个参数key（非0整数，可为ftok() 的返回值，也可以用自己的宏）来告诉操作系统需要哪个共享内存，然后系统返回对应共享内存的标识符，失败返回-1，并设置errno<br>size:共享内存大小，PAGE_SIZE页面大小(4096)的整数倍，因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍<br>shmflg:由九个权限标志构成，用法和创建文件时使用的mode模式标志是一样的<br>IPC_CREAT：如果不存在就创建<br>IPC_EXCL： 如果已经存在则返回失败<br>位或权限位：共享内存位或权限位后可以设置共享内存的访问权限，格式和 open() 函数的 mode_t 一样，但可执行权限未使用</p><p><strong>共享内存数据结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* operation perms */</span></span><br><span class="line">    <span class="keyword">int</span> shm_segsz; <span class="comment">/* size of segment (bytes) */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_atime; <span class="comment">/* last attach time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_dtime; <span class="comment">/* last detach time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> shm_ctime; <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> shm_cpid; <span class="comment">/* pid of creator */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> shm_lpid; <span class="comment">/* pid of last operator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> shm_nattch; <span class="comment">/* no. of current attaches */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> shm_unused; <span class="comment">/* compatibility */</span></span><br><span class="line">    <span class="keyword">void</span> *shm_unused2; <span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line">    <span class="keyword">void</span> *shm_unused3; <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="建立映射关系"><a class="markdownIt-Anchor" href="#建立映射关系"></a> 建立映射关系</h1><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code><br>shmid: 共享内存标识（shmget返回值）<br>shmaddr: 映射地址，通常为空，让系统来选择共享内存的地址；若不为NULL且shmflg无SHM_RND标记，若设置SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍<br>shmflg:<br>SHM_RDONLY:只读<br>0:共享内存具有可读可写权限<br>返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1，并设置errno</p><h1 id="解除映射"><a class="markdownIt-Anchor" href="#解除映射"></a> 解除映射</h1><p><code>int shmdt(const void *shmaddr);</code><br>shmaddr: 由shmat所返回的指针<br>成功返回0；失败返回-1，并设置errno</p><h1 id="控制共享内存"><a class="markdownIt-Anchor" href="#控制共享内存"></a> 控制共享内存</h1><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></p><p>shmid:由shmget返回的共享内存标识码<br>cmd:IPC_RMID删除共享内存、IPC_STAT获取共享内存的当前关联值、IPC_SET根据buf设置共享内存关联值。注意：共享内存删除不会直接删除，而是判断映射连接数是否为0，为0直接删除否则拒绝后续其他进程的映射连接，为0时自动删除<br>buf:保存着共享内存的模式状态和访问权限的数据结构，输入输出型参数<br>成功返回0；失败返回-1</p><p>共享内存并未提供同步机制，一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，比如信号量</p><h1 id="关于函数ftok"><a class="markdownIt-Anchor" href="#关于函数ftok"></a> 关于函数ftok</h1><p>shmget函数中的第一个参数key相当于共享内存的钥匙，可以通过它能访问唯一的内存区域。由于key和内存是一一对应的，所以我们不难想到用这块内存的inod节点来生成密钥，这就有了ftok函数<br><code>系统调用key_t ftok(const char *pathname, int proj_id);</code><br>pathname就时你指定的文件名(该文件必须是存在而且可以访问的)，proj_id是子序号，虽然为int，但是只有8个比特被使用(0-255)<br>成功返回key值，失败返回-1</p><p>生成规则：返回的整数IPC键由proj_id的低序8位，struct stat中st_dev成员的低序8位，st_ino的低序16位组合而成</p><p>注意事项：<br>pathname指定的目录（文件）不能在程序运行期间删除或创建。因为文件每次创建时由系统赋予的索引节点可能不一样。这样一来，通过同一个pathname与proj_id就不能保证生成同一个IPC键</p><h1 id="代码实现server和client的交互"><a class="markdownIt-Anchor" href="#代码实现server和client的交互"></a> 代码实现server和client的交互</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/ipc/SharedMemory" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/ipc/SharedMemory</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;共享内存就是将同一块物理内存映射到不同进程虚拟内存的共享区域，实现两个进程间通信。一旦这样的内存映射到进程地址空间的共享区，这些进程间数据传递不再涉及到内核，不再通过执行进入内核的系统调用来传递彼此的数据，所以说共享内存是最快的IPC形式&lt;br&gt;我们可以通过命令查看/删除系
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>管道</title>
    <link href="https://ranjiahao.github.io/2020/05/06/%E7%AE%A1%E9%81%93/"/>
    <id>https://ranjiahao.github.io/2020/05/06/%E7%AE%A1%E9%81%93/</id>
    <published>2020-05-05T16:00:00.000Z</published>
    <updated>2020-05-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个进程各自有不同的用户地址空间，都是独立运行，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程把数据从用户空间拷到内核缓冲区，另一个进程再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信<br>我们常用 ‘|’ 符号来用一个命令来处理另一个命令的显示结果<br><code>cat test.c | less</code><br>这个过程本质上是创建cat进程传入参数test.c然后这个进程从用户态切换到内核态，将数据拷贝到内核中的缓冲区中，然后less进程切换到内核态取走缓冲区中的数据，返回用户态并处理数据。这个内核中的缓冲区就叫管道<br>管道的生命周期随进程，进程结束以后，相应的管道也会自动释放。有同步互斥机制、面向字节流的通信、半双工通信</p><h1 id="匿名管道"><a class="markdownIt-Anchor" href="#匿名管道"></a> 匿名管道</h1><blockquote><p>系统调用<br><code>int pipe(int pipefd[2]);</code><br>fd为输出型参数，传入一个空数组，返回文件描述符数组，fd[0]表示读端fd[1]表示写端，成功返回0，失败返回错误代码-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"creat pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程写数据，关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> mesg[] = <span class="string">"I am child"</span>;</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], mesg, <span class="built_in">strlen</span>(mesg));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child write:%s\n"</span>, mesg);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程读数据，关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> mesg[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], mesg, <span class="number">1023</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"father read:%s\n"</span>, mesg);</span><br><span class="line">        &#125;</span><br><span class="line">        waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="gif1.gif" alt="gif1"><br>父进程创建fd[2]数组，子进程fork后，fork了fd中的文件描述符，因此他们可以共同访问内核中的缓冲区（管道），也就是说这种方式仅适用与具有亲缘关系的进程<br><img src="img1.png" alt="img1"></p><h1 id="命名管道"><a class="markdownIt-Anchor" href="#命名管道"></a> 命名管道</h1><p>由于匿名管道只可用于具亲缘关系的进程间通信，所以我们要实现非亲缘进程间的通信就需要给这个内核中的缓冲区起个名字，使进程可以通过管道名字访问到这个内核中的缓冲区，进而实现进程间通信</p><p>可以通过mkfifo命令直接创建管道文件(此文件本质还是内核中的缓冲区)<br><code>mkfifo filename</code><br>或者通过库函数<br><code>int mkfifo(const char *filename,mode_t mode);</code><br>第一个参数为所要创建管道的全路径名，第二个参数为创建管道的权限，这里需要注意的是，该值会受到umask值的影响，所以最好先将umask的值设置为000</p><p><strong>打开规则</strong>：</p><p>open打开的时候可以通过参数O_NONBLOCK设置非阻塞</p><p>若只读打开：<br>阻塞直到有相应进程为写而打开该FIFO<br>O_NONBLOCK: 若没有进程为写而打开该FIFO，则立即返回成功</p><p>若只写打开：<br>阻塞直到有相应进程为读而打开该FIFO<br>O_NONBLOCK: 若没有进程为读而打开该FIFO，则立刻返回失败，错误码为ENXIO</p><p><strong>演示代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_write.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file = <span class="string">"./tmp.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果文件不是因为已经存在而报错，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(file, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo_read.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file = <span class="string">"./tmp.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果文件不是因为已经存在而报错，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">read</span>(fd, buf, <span class="number">1023</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"read error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"write closed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"buf:[%s]\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="管道读写规则"><a class="markdownIt-Anchor" href="#管道读写规则"></a> 管道读写规则</h1><p>如果管道所有的写端都关闭，那么read循环读取完数据后返回0<br>如果写端没全部关闭，但是又不写入数据，则读端一直阻塞等待，等写端写入数据后读取</p><p>如果管道所有的读端都关闭，执行write时会产生SIGPIPE信号，导致write进程退出，进程异常终止<br>如果读端没全部关闭，但是缓冲区已经满了，则写端一直阻塞等待，等有空间在写入</p><p>若设置O_NONBLOCK则当管道满时或没有数据可读时返回-1，设置errno值为EAGAIN</p><p>当要写入的数据量不大于PIPE_BUF时（ulimit -a查看），linux将保证写入的原子性</p><p>那么系统分配的管道大小是多少呢？我们可以通过命令<br><code>cat /proc/sys/kernel/msgmax</code>查看</p><h1 id="从内核看管道"><a class="markdownIt-Anchor" href="#从内核看管道"></a> 从内核看管道</h1><p>进程向管道中写数据本质上就是创建一块内核空间并且将这个空间的inode信息放入f_inode中，将f_op设置为对这块内存的操作（读写等）然后将若干信息组织起来形成file结构体，并且将这个结构体的指针添加到进程的文件描述符数组中，这是进程就可以操作这个块内核空间了，另一个进程若想进行通信，就要使用相同的f_inode而f_op可以不同</p><h1 id="利用管道实现minishell"><a class="markdownIt-Anchor" href="#利用管道实现minishell"></a> 利用管道实现minishell</h1><p><a href="https://github.com/Ranjiahao/Linux/tree/master/MiniShell" target="_blank" rel="noopener">https://github.com/Ranjiahao/Linux/tree/master/MiniShell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个进程各自有不同的用户地址空间，都是独立运行，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程把数据从用户空间拷到内核缓冲区，另一个进程再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信&lt;br&gt;我们常用 ‘|’ 符号来用一个命令来处理另一个命令的显
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="ipc" scheme="https://Ranjiahao.github.io/tags/ipc/"/>
    
  </entry>
  
  <entry>
    <title>进程程序替换</title>
    <link href="https://ranjiahao.github.io/2020/05/03/%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2/"/>
    <id>https://ranjiahao.github.io/2020/05/03/%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行<br>系统调用：<br><code>int execve(const char* path, char* const argv[], char* const envp[]);</code><br>库函数：<br><code>int execl(const char* path, const char* arg, ...);</code><br><code>int execlp(const char* file, const char* arg, ...);</code><br><code>int execle(const char* path, const char* arg, ...,char* const envp[]);</code><br><code>int execv(const char* path, char* const argv[]);</code><br><code>int execvp(const char* file, char* const argv[]);</code><br><code>int execvpe(const char* file, char* const argv[], char* const envp[]);</code><br>规律：exec必选<br><strong>v和l必须选其一</strong></p><ul><li>l(list) : 表示参数采用列表</li><li>v(vector) : 参数用数组</li></ul><p><strong>e、p可选可不选</strong></p><ul><li>p(path) : 有p自动搜索环境变量PATH</li><li>e(env) : 表示自己维护环境变量</li></ul><p>如果调用成功则加载新的程序从启动代码开始执行，不返回<br>如果调用出错则返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123;<span class="string">"PATH=/bin:/usr/bin"</span>, <span class="string">"TERM=console"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="comment">// l和v</span></span><br><span class="line">execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">execv(<span class="string">"/bin/ls"</span>, argv);</span><br><span class="line"><span class="comment">// p和e</span></span><br><span class="line">execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">execve(<span class="string">"/bin/ls"</span>, argv, envp);</span><br></pre></td></tr></table></figure><p>这些库函数在调用时候，如果参数采用列表格式首先将参数替换成数组形式，然后如果有相对路径就在底层替换成绝对路径，然后根据自己维护的环境变量或者shell的环境变量组织envp，而后调execve接口<br>我们发现函数和进程之间有些许相似性：<br>c语言中，一个函数和一个函数可以通过return/call来通信，这类似与进程间的exit/exec&amp;fork，进程可以fork/exec，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来返回值。调用它的进程可以通过wait来获取exit的返回值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当进程调用exec函数执行磁盘里另一个程序时，并不创建新进程，调用前后进程id并未改变，新进程的数据和代码会替换掉物理内存中的数据段和代码段，从而虚拟根据页表找到的数据和代码都会别替换成新的，所以当进程开始执行时，就要从要执行的程序开始执行&lt;br&gt;系统调用：&lt;br&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程终止与wait参数status</title>
    <link href="https://ranjiahao.github.io/2020/05/02/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E4%B8%8Ewait%E5%8F%82%E6%95%B0status/"/>
    <id>https://ranjiahao.github.io/2020/05/02/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E4%B8%8Ewait%E5%8F%82%E6%95%B0status/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见进程退出方法"><a class="markdownIt-Anchor" href="#常见进程退出方法"></a> 常见进程退出方法</h1><ol><li>exit或_exit退出<br>_exit系统调用函数：<code>void _exit(int status);</code><br>参数status定义了进程的终止状态，父进程通过wait获取该值。<br>虽然status是int，但是仅有低8位可以被父进程所用，实际上就是子进程的返回值。<br>exit库函数：<code>void exit(int status);</code><br>和_exit唯一的区别是退出前执行用户通过atexit或on_exit定义的清理函数然后刷新缓存关闭所有打开的流，最后调用_exit函数退出</li><li>return退出，和exit一样，exec/exit针对进程间通信，就像call/return针对函数间通信</li><li>信号终止</li></ol><h1 id="常见进程等待方法"><a class="markdownIt-Anchor" href="#常见进程等待方法"></a> 常见进程等待方法</h1><ol><li>wait系统调用函数（阻塞）<code>pid_t wait(int* status);</code><br>status为输出型参数，NULL表示不关心子进程状态<br>返回值：成功返回被等待进程的pid，失败返回-1</li><li>waitpid系统调用函数<br><code>pid_ t waitpid(pid_t pid, int* status, int options);</code><br>参数pid若为-1则等待任意一个进程，若&gt;0则等待特定的进程<br>参数options若为0则阻塞，若为WNOHANG则非阻塞</li></ol><h1 id="wait参数statu"><a class="markdownIt-Anchor" href="#wait参数statu"></a> wait参数statu</h1><p>status不仅仅是一个int类型参数，可以看作是一个位图<br>只研究其低16位：<br><img src="img1.png" alt="img1"><br>我们可以通过status &amp; 0x7f来判断异常信号是否为0；<br>若为0，则正常退出，然后可以通过(status &gt;&gt; 8) &amp; 0xff来获取子进程返回值。<br>sys/wait.h中提供了一些宏来简化这些操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">    <span class="comment">// 正常退出：((status) &amp; 0x7f) == 0</span></span><br><span class="line">    <span class="comment">// 打印退出码：(status &gt;&gt; 8) &amp; 0xff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child return: %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">    <span class="comment">// 异常退出：((signed char) (((status) &amp; 0x7f) + 1) &gt;&gt; 1) &gt; 0</span></span><br><span class="line">    <span class="comment">// 打印异常信号值：(status) &amp; 0x7f</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child signal: %d\n"</span>, WTERMSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见进程退出方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常见进程退出方法&quot;&gt;&lt;/a&gt; 常见进程退出方法&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;exit或_exit退出&lt;br&gt;_exit系统调用函数：&lt;code&gt;void _exit(int s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>fork、vfork、clone、system、popen</title>
    <link href="https://ranjiahao.github.io/2020/05/01/fork%E3%80%81vfork%E3%80%81clone%E3%80%81system%E3%80%81popen/"/>
    <id>https://ranjiahao.github.io/2020/05/01/fork%E3%80%81vfork%E3%80%81clone%E3%80%81system%E3%80%81popen/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-04-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h1><blockquote><p>系统调用：<code>pid_t fork(void);</code><br>子进程返回0，父进程返回子进程pid<br>出错返回-1，子进程不会被创建，会设置errno</p></blockquote><p>错误原因可能是：系统中有太多的进程，实际用户的进程数超过了限制，命令ulimit -a中max user processes可查看用户最大能创建的进程数<br>fork后，就有两个二进制代码相同的进程，都运行到相同的地方，由调度器决定谁先执行。<br>子进程是父进程的一份拷贝，代码共享，数据独有<br>代码共享：共享代码段，父子进程的指令双方都能看到<br>数据独有：数据段、堆、栈</p><h2 id="fork都做了那些事"><a class="markdownIt-Anchor" href="#fork都做了那些事"></a> fork都做了那些事？</h2><p>进程调用fork，由用户态切换到内核态<br>分配新的内存块和内核数据结构给子进程<br>将父进程部分数据结构内容拷贝至子进程<br>添加子进程到系统进程列表当中<br>fork返回，开始调度器调度</p><h2 id="写实拷贝"><a class="markdownIt-Anchor" href="#写实拷贝"></a> 写实拷贝</h2><p>通常，父子代码共享，父子再不写入时，数据也是共享的，子进程复制了父进程的task_struct，系统堆栈空间和页面表<br>任意一方写入时，便在物理空间中创建一份副本进行修改，并且映射到相同的虚拟地址空间中</p><p>也就是说：父进程和子进程共享物理页帧而不是复制页帧。只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的。当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的</p><h1 id="vfork"><a class="markdownIt-Anchor" href="#vfork"></a> vfork</h1><blockquote><p>系统调用<code>pid_t vfork(void);</code><br>调用方法和返回值和fork相同</p></blockquote><p>说起fork就不得不提类似的vfork，它直接共享了父进程的虚拟空间、物理空间，所以如果子进程（轻量级进程）修改数据则父进程会收到影响。也就是说子进程不可以return或者exit。但是可以_exit退出</p><p>子进程会导致父进程挂起，除非子进程exit或者execve才会唤起父进程</p><p>vfork存在的意义是为了快速创建进程，并且通过程序替换来运行其他程序，因为共享地址空间可以减少拷贝时间。但是自从fork实现写实拷贝后，此接口就几乎被淘汰了</p><h1 id="clone"><a class="markdownIt-Anchor" href="#clone"></a> clone</h1><blockquote><p>系统调用：<code>int clone(int (*fn)(void*), void* child_stack, int flags, void* arg);</code><br>fn 是需要执行的函数指针，即 clone 出来的子进程需要执行的函数内容。<br>child_stack 就明显是给子进程分配的系统堆栈空间的位置。（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值）<br>flags 用于描述子进程需要从父进程中继承哪些部分的内容，因此通过这个值可以控制产生进程、线程、甚至非父子关系而是兄弟关系的进程等等，功能强大（可以说是一个轻量级进程的系统调用）<br>arg就是传给子进程的参数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid:%d\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* <span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="number">8192</span>);</span><br><span class="line">    <span class="comment">// clone()第二个参数指定的是栈空间，栈是反向增长，</span></span><br><span class="line">    <span class="comment">// 所以这里传入申请的空间的尾部</span></span><br><span class="line">    <span class="keyword">int</span> pid = clone(&amp;Test, (<span class="keyword">char</span>*)<span class="built_in">stack</span>+<span class="number">8192</span>, CLONE_PARENT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Father pid:%d, child pid:%d\n"</span>, getpid(), pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="system"><a class="markdownIt-Anchor" href="#system"></a> system</h1><blockquote><p>库函数<code>int system(const char *command);</code><br>system()执行通过创建子进程执行/bin/sh -c命令指定的命令，并在命令完成后返回,在执行命令的时候,SIGCHLD将被阻塞，SIGINT和SIGQUIT将被忽略。<br>command:命令参数是指向包含shell命令行的以null结尾的字符串的指针。这个命令被传递给/bin/sh使用。<br>返回值:<br>fork()失败,返回-1<br>exec()失败,返回值相当于执行了exit(127)<br>参数command为NULL时返回1<br>system在执行期间调用进程会一直等待shell命令执行完成(waitpid等待子进程结束)才返回</p></blockquote><h1 id="popenpclose"><a class="markdownIt-Anchor" href="#popenpclose"></a> popen/pclose</h1><blockquote><p>库函数：<br><code>FILE *popen(const char *command, const char *type);</code><br><code>int pclose(FILE *stream);</code></p></blockquote><p>popen会调用fork产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令，参数type可用r代表读取，w代表写入。依照此type的值，popen会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可以利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中，若成功则返回文件指针，否则返回NULL,错误原因存在于errno中<br>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* fd = popen(<span class="string">"./cin"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fd, <span class="string">"hehe"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 保证popen打开的进程先退出</span></span><br><span class="line">    pclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cin.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ test.cc -o test</code><br><code>g++ cin.cc -o cin</code><br>然后执行<br><code>./cin</code><br><code>./test</code><br>一秒后输出<strong>hehe</strong><br>这个一个异步执行的过程：test进程调用popen后fork一个子进程调用exec函数去执行command，然后cin进程启动阻塞到cin&gt;&gt;阶段，同时popen返回管道的描述符，fprintf将数据写入管道中，此时cin就被唤醒，打印数据信息<br>如果不加sleep函数，可能父进程在子进程还没打印的时候先退出，就会变成孤儿进程，因此可能在标头之后打印。</p><h1 id="do_fork"><a class="markdownIt-Anchor" href="#do_fork"></a> do_fork</h1><blockquote><p>内核函数：<code>do_fork(unsigned long clone_flag, unsigned long usp, structpt_regs)</code><br>fork、vfork、clone最底层涉及到的都是 do_fork() 这个调用，只是传入参数不同，clone 可以认为就是个 do_fork() 的API外衣</p></blockquote><p>其中clone_flag为：</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>CLONE_PARENT</td><td>创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td></tr><tr><td>CLONE_FS</td><td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td></tr><tr><td>CLONE_FILES</td><td>子进程与父进程共享相同的文件描述符（file descriptor）表</td></tr><tr><td>CLONE_NEWNS</td><td>在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td></tr><tr><td>CLONE_SIGHAND</td><td>子进程与父进程共享相同的信号处理（signal handler）表</td></tr><tr><td>CLONE_PTRACE</td><td>若父进程被trace，子进程也被trace</td></tr><tr><td>CLONE_VFORK</td><td>父进程被挂起，直至子进程释放虚拟内存资源</td></tr><tr><td>CLONE_VM</td><td>子进程与父进程运行于相同的内存空间</td></tr><tr><td>CLONE_PID</td><td>子进程在创建时PID与父进程一致</td></tr><tr><td>CLONE_THREAD</td><td>Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td></tr></tbody></table><p>任何一位被置1了则表明创建的子进程和父进程共享该位对应的资源</p><p>vfork中clone_flag = CLONE_VFORK | CLONE_VM |SIGCHLD<br>这表示子进程和父进程共享地址空间、共享相同的信号处理表，同时do_fork会检查CLONE_VFORK，如果该位被置1了，子进程会把父进程的地址空间锁住，直到子进程退出或执行exec时才释放该锁</p><p>fork中clone_flag=SIGCHLD</p><h1 id="两道有意思的面试题"><a class="markdownIt-Anchor" href="#两道有意思的面试题"></a> 两道有意思的面试题</h1><p><strong>判断创建几个进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fork() &amp;&amp; fork()) || fork()) &#123;</span><br><span class="line">        fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为8个，可以通过pstree命令查看：<br><img src="img1.png" alt="img1"><br>分析：<br>主进程从左到右，子进程从上到下执行。<br><img src="img2.png" alt="img1"></p><p><strong>判断输出*的个数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出6个*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出8个*，注意没有\n来刷新缓冲区，则子进程会拷贝父进程缓冲区中的数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fork&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork&quot;&gt;&lt;/a&gt; fork&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;系统调用：&lt;code&gt;pid_t fork(void);&lt;/code&gt;&lt;br&gt;子进程返回0，父进程返回子进程p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="fork" scheme="https://Ranjiahao.github.io/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>main函数的三个参数</title>
    <link href="https://ranjiahao.github.io/2020/04/17/main%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
    <id>https://ranjiahao.github.io/2020/04/17/main%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>C程序总是从main函数开始执行的，main函数的原型是：<br><code>int main(int argc, char* argv[], char* env[])</code></p><h1 id="argc与argv"><a class="markdownIt-Anchor" href="#argc与argv"></a> argc与argv</h1><p>argc表示传入main函数的参数个数<br>argv[]表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d]=[%s]\n"</span>,i,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段程序<code>gcc main.c -o main</code>生成可执行程序main<br><code>./main</code>运行：输出结果为argv[0]=[./main]<br><code>./main -a abc</code>运行：输出结果为<br>argv[0]=[./main]<br>argv[1]=[-a]<br>argv[2]=[abc]</p><p>可以总结出以下几点：<br>argv[0] 指向程序运行的全路径名 　　<br>argv[1] 指向在DOS命令行中执行程序名后的第一个字符串 　　<br>argv[2] 指向执行程序名后的第二个字符串<br>…<br>argv[argc]为NULL</p><h1 id="env"><a class="markdownIt-Anchor" href="#env"></a> env</h1><p>每个进程都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以NULL结尾的环境字符串，env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value 为ENVVAR的对应值<br>环境变量通常具有全局特性，系统设置更加方便(切换用户会还原)</p><h2 id="常见的环境变量"><a class="markdownIt-Anchor" href="#常见的环境变量"></a> 常见的环境变量</h2><p>PATH: 命令的搜索路径<br>HOME: 用户家目录<br>SHELL: 当前Shell通常是/bin/bash</p><h2 id="环境变量相关命令"><a class="markdownIt-Anchor" href="#环境变量相关命令"></a> 环境变量相关命令</h2><p><code>echo $(NAME)</code>可以查看指定环境变量<br><code>export (val)</code>声明一个新的环境变量<br><code>env</code>显示所有环境变量<br><code>unset (NAME)</code>清除环境变量<br><code>set</code>显示本地定义的shell变量和环境变量</p><h2 id="通过代码查看环境变量"><a class="markdownIt-Anchor" href="#通过代码查看环境变量"></a> 通过代码查看环境变量</h2><p>由于环境变量具有继承特性，我们可以创建进程来继承shell的环境变量并且打印出来</p><ul><li>通过第三个参数获得</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过libc中定义的全局变量environ获取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; environ[i]; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过系统调用接口获取或设置环境变量</li></ul><p>getenv 和putenv 也是定义在stdlib.h 中，函数原型如下：</p><p><code>char *getenv(const char *name);</code><br><code>int putenv(char *str);</code></p><h2 id="main执行和main执行"><a class="markdownIt-Anchor" href="#main执行和main执行"></a> ./main执行和main执行</h2><p>有些指令可以直接执行，不需要带路径，而我们写的可执行程序必须要加上路径，这是由于默认的搜索路径为PATH，我们只需将PATH修改即可：<br><code>PATH=$PATH:./</code><br>但是需要注意的是不要覆盖PATH防止类似ls的命令用不了</p><h2 id="是否应该使用第三个参数env"><a class="markdownIt-Anchor" href="#是否应该使用第三个参数env"></a> 是否应该使用第三个参数env</h2><p>ISO C/ISO C++ ,POSIX 标准都不支持main三个参数的定义形式，VC和GNU编译器都扩展了main函数的定义，所以目前可以这样使用。如果要编写更加可移植的程序，应该使用全局环境变量environ来代替env的作用，如果要访问特定的环境变量，应该使用getenv和putenv函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C程序总是从main函数开始执行的，main函数的原型是：&lt;br&gt;&lt;code&gt;int main(int argc, char* argv[], char* env[])&lt;/code&gt;&lt;/p&gt;&lt;h1 id=&quot;argc与argv&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="环境变量" scheme="https://Ranjiahao.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>进程基础</title>
    <link href="https://ranjiahao.github.io/2020/04/16/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://ranjiahao.github.io/2020/04/16/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>进程是程序执行时的一个实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，是当前状态和相关系统资源描述的活动单元</p><h1 id="进程与可执行程序的区别"><a class="markdownIt-Anchor" href="#进程与可执行程序的区别"></a> 进程与可执行程序的区别</h1><p>可执行程序是指令和数据的集合，作为一种数据资料长期存在，是一个静态概念。而进程是可执行程序的一次执行过程，是有生命期，是暂时的，是一个动态概念。所以同一个可执行程序可以对应多个进程</p><h1 id="进程标识方法"><a class="markdownIt-Anchor" href="#进程标识方法"></a> 进程标识方法</h1><h2 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h2><p>进程信息被放在一个叫做进程控制块的数据结构，linux下就是task_struct结构体，其中主要内容有：<br>标识符：PID标识和PPID等<br>状态：任务状态，退出代码，退出信号等<br>优先级：相对于其他进程的优先级<br>程序计数器：程序中即将被执行的下一条指令的地址<br>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针<br>上下文数据：进程执行时处理器的寄存器中的数据<br>I／O状态信息：包括显示的IO请求，分配给进程的IO设备和被进程使用的文件列表<br>记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等<br>其他信息</p><h2 id="pid与ppid"><a class="markdownIt-Anchor" href="#pid与ppid"></a> PID与PPID</h2><p>标识和区分进程的ID，是在当前linux系统中唯一的非负整数。进程运行时PID由操作系统随机分配，同一个程序运行两次会产生两个进程，也就有两个不同的PID</p><p>每个进程除了一定有PID还会有PPID(1号进程除外)通过PPID可以找到父进程的信息</p><p>PID为1的进程是由内核创建的init进程，其他子进程都是由它衍生出来，所有进程都来自于一个进程，所以Linux的进程模型也叫做进程树<br>查看方式：<br>可以通过/proc系统文件夹查看<br>通过top、pidof或者ps -ef命令来查看<br>通过系统调用函数getpid()getppid()</p><h1 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h1><p>R运行状态：并不意味着进程一定在运行中，同一时刻可能有多个进程处于此状态，这些进程的task_struct结构被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）它表明进程要么是在运行中，要么在运行队列里。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行</p><p>S可中断睡眠状态：意味着进程在等待某时间的发生（如，等待资源），这些进程的task_struct结构被放入对应事件的等待队列中，当这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒</p><p>D不可中断的睡眠状态：指进程不响应异步信号，因此无法用kill杀掉，除非reboot，通常此状态是在等待IO，比如磁盘IO，网络IO，其他外设IO</p><p>T暂停状态、t跟踪状态：可以通过发送SIGSTOP信号，暂停状态，这个被暂停的进程可以通过发送SIGCONT信号让进程继续运行。跟踪状态是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于跟踪状态，跟踪状态的进程不能响应sigcont信号而被唤醒，只能等到调试进程通过ptrace系统调用执行</p><p>X死亡状态：这个状态只是一个返回状态，你不会在任务列表里看到这个状态</p><p>Z僵尸进程：当子进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码</p><h1 id="进程优先级"><a class="markdownIt-Anchor" href="#进程优先级"></a> 进程优先级</h1><p>cpu资源分配的先后顺序，就是指进程的优先级。由于linux是多任务环境的，所以配置优先级可以改善系统性能。还可以把进程运行到指定的CPU上，把不重要的进程安排到某个CPU，可大大改善系统整体性能</p><h2 id="pri与ni"><a class="markdownIt-Anchor" href="#pri与ni"></a> PRI与NI</h2><p>命令ps -l可查看进程的PRI与NI，PRI为进程的优先级，越小优先级别越高；NI为优先级修正数值；所以PRI(new)=PRI(old)+NI，所以，调整进程优先级，Linux下，就是调整进程NI值。NI其取值范围是-20至19，一共40个级别，PRI默认为80</p><h2 id="更改ni"><a class="markdownIt-Anchor" href="#更改ni"></a> 更改NI</h2><p>进入top后按“r”–&gt;输入进程PID–&gt;输入nice值<br>renice -n (ni_val) -p (pid)<br>nice -n (ni_val) ./exe —在运行的时候直接设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是程序执行时的一个实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，是当前状态和相关系统资源描述的活动单元&lt;/p&gt;&lt;h1 id=&quot;进程与可执行程序的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程与可执行程序的区别
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://Ranjiahao.github.io/categories/Linux/"/>
    
    
      <category term="进程" scheme="https://Ranjiahao.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
